---
title: ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
date: 2021-11-21 15:35:28
permalink: /pages/b9f504/
---

## ğŸ“ƒ é¢˜ç›®æè¿°

é¢˜ç›®é“¾æ¥ï¼š[105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

ç»™å®šä¸€æ£µæ ‘çš„å‰åºéå† preorder ä¸ä¸­åºéå†  inorderã€‚è¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

ç¤ºä¾‹ 1:

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```


ç¤ºä¾‹ 2:

```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```

## ğŸ”” è§£é¢˜æ€è·¯

å’Œä¸Šä¸€é¢˜çš„æ€è·¯ä¸€æ¨¡ä¸€æ ·

ä¸­åºéå†ï¼šå·¦æ ¹å³ï¼Œå‰åºéå†ï¼šæ ¹å·¦å³

æ ¹æ®å‰åºéå†çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œåœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®ï¼Œç„¶åå°±å¯ä»¥åˆ’åˆ†å·¦å³å­æ ‘äº†


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // å·¦é—­å³å¼€
        return buildTree1(preorder, 0, preorder.length,
                          inorder, 0, inorder.length);
    }

    /**
     * @param preorder (å·¦é—­å³å¼€)
     * @param preLeft preorder æ•°ç»„çš„èµ·å§‹ä¸‹æ ‡
     * @param preRight preorder æ•°ç»„çš„ç»ˆæ­¢ä¸‹æ ‡
     * @param inorder (å·¦é—­å³å¼€)
     * @param inLeft inorder æ•°ç»„çš„èµ·å§‹ä¸‹æ ‡
     * @param inRight inorder æ•°ç»„çš„ç»ˆæ­¢ä¸‹æ ‡
     * @return
     */
    private TreeNode buildTree1(int[] preorder, int preLeft, int preRight,
                                int[] inorder, int inLeft, int inRight) {
        // æ²¡æœ‰å…ƒç´ äº†
        if (inRight - inLeft < 1) {
            return null;
        }
        // åªæœ‰ä¸€ä¸ªå…ƒç´ äº†
        if (inRight - inLeft == 1) {
            return new TreeNode(inorder[inLeft]);
        }

        // å‰åºæ•°ç»„çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹
        TreeNode root = new TreeNode(preorder[preLeft]);
        // åœ¨ä¸­åºæ•°ç»„ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®
        int index = inLeft;
        for (; index < inRight; index ++) {
            if (inorder[index] == root.val) {
                break;
            }
        }

        // æ„å»ºå·¦å­æ ‘
        root.left = buildTree1(preorder, preLeft + 1, preLeft + (index - inLeft),
                               inorder, inLeft, index);
        // æ„å»ºå³å­æ ‘
        root.right = buildTree1(preorder, preLeft + (index - inLeft) + 1, preRight,
                                inorder, index + 1, inRight);

        return root;
    }
}
```

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20211121154757.png)

## ğŸ’¥ å¤æ‚åº¦åˆ†æ

- ç©ºé—´å¤æ‚åº¦ï¼šO(LogN)
- æ—¶é—´å¤æ‚åº¦ï¼šO(N)

