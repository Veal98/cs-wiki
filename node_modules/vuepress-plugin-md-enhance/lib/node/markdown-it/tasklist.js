"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Token = require("markdown-it/lib/token");
const utils_1 = require("./utils");
// leading whitespace in a list item is already trimmed off by markdown-it
const startsWithTodoMarkdown = (token) => token.content.indexOf("[ ] ") === 0 ||
    token.content.indexOf("[x] ") === 0 ||
    token.content.indexOf("[X] ") === 0;
const isTaskListItem = (tokens, index) => {
    return ((0, utils_1.isInlineToken)(tokens[index]) &&
        (0, utils_1.isParagraphToken)(tokens[index - 1]) &&
        (0, utils_1.isListItemToken)(tokens[index - 2]) &&
        startsWithTodoMarkdown(tokens[index]));
};
const generateCheckbox = (token) => {
    const checkbox = new Token("html_inline", "", 0);
    checkbox.content = `<input type="checkbox" class="task-list-item-checkbox" ${token.content.indexOf("[ ] ") === 0 ? "" : 'checked="checked"'} disabled="disabled">`;
    return checkbox;
};
// these next two functions are kind of hacky; probably should really be a
// true block-level token with .tag=='label'
const beginLabel = () => {
    const token = new Token("html_inline", "", 0);
    token.content = "<label>";
    return token;
};
const endLabel = () => {
    const token = new Token("html_inline", "", 0);
    token.content = "</label>";
    return token;
};
const afterLabel = (content, id) => {
    const token = new Token("html_inline", "", 0);
    token.content =
        '<label class="task-list-item-label" for="' +
            id +
            '">' +
            content +
            "</label>";
    token.attrs = [["for", id]];
    return token;
};
const todoify = (token, state, options) => {
    token.children = token.children || [];
    // add checkbox input
    token.children.unshift(generateCheckbox(token));
    // remove the checkbox syntax letter
    token.children[1].content = token.children[1].content.slice(3);
    token.content = token.content.slice(3);
    if (options.label)
        if (options.labelAfter) {
            token.children.pop();
            const id = `task-item-${state.env.tasklists++}`;
            token.children[0].content =
                token.children[0].content.slice(0, -1) + ' id="' + id + '">';
            token.children.push(afterLabel(token.content, id));
        }
        else {
            token.children.unshift(beginLabel());
            token.children.push(endLabel());
        }
};
exports.default = (md, { label = true, labelAfter = true } = {}) => {
    md.core.ruler.after("inline", "github-task-lists", (state) => {
        const tokens = state.tokens;
        if (!state.env.tasklists)
            state.env.tasklists = 0;
        for (let i = 2; i < tokens.length; i++) {
            if (isTaskListItem(tokens, i)) {
                todoify(tokens[i], state, { label, labelAfter });
                (0, utils_1.setTokenAttr)(tokens[i - 2], "class", "task-list-item");
                (0, utils_1.setTokenAttr)(tokens[(0, utils_1.getParentTokenIndex)(tokens, i - 2)], "class", "task-list-container");
            }
        }
        return true;
    });
};
//# sourceMappingURL=tasklist.js.map