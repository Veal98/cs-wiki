import type { Markdown, MarkdownOptions } from '@vuepress/markdown';
import type { App } from '../app';
import type { Page, PageOptions } from '../page';
declare type PromiseOrNot<T> = Promise<T> | T;
declare type Closable = {
    close(): void;
};
export declare type Hook<Exposed, Normalized = Exposed, Result = Normalized extends (...args: any) => infer U ? U extends Promise<infer V> ? V : U : void> = {
    exposed: Exposed;
    normalized: Normalized;
    result: Result;
};
export declare type LifeCycleHook<T extends unknown[] = []> = Hook<(app: App, ...args: T) => PromiseOrNot<void>>;
export declare type ExtendsHook<T> = Hook<(extendable: T, app: App) => PromiseOrNot<void>>;
export declare type ClientConfigFileHook = Hook<string | ((app: App) => PromiseOrNot<string>), (app: App) => Promise<string>>;
export declare type ReturnObjectHook = Hook<Record<string, any> | ((app: App) => PromiseOrNot<Record<string, any>>), (app: App) => Promise<Record<string, any>>>;
/**
 * List of hooks
 */
export interface Hooks {
    onInitialized: LifeCycleHook;
    onPrepared: LifeCycleHook;
    onWatched: LifeCycleHook<[watchers: Closable[], restart: () => Promise<void>]>;
    onGenerated: LifeCycleHook;
    extendsMarkdownOptions: ExtendsHook<MarkdownOptions>;
    extendsMarkdown: ExtendsHook<Markdown>;
    extendsPageOptions: ExtendsHook<PageOptions>;
    extendsPage: ExtendsHook<Page>;
    extendsBundlerOptions: ExtendsHook<any>;
    clientConfigFile: ClientConfigFileHook;
    alias: ReturnObjectHook;
    define: ReturnObjectHook;
}
/**
 * Name of hooks
 */
export declare type HooksName = keyof Hooks;
/**
 * Exposed hooks API that can be accessed by a plugin
 */
export declare type HooksExposed = {
    [K in HooksName]: Hooks[K]['exposed'];
};
/**
 * Normalized hooks
 */
export declare type HooksNormalized = {
    [K in HooksName]: Hooks[K]['normalized'];
};
/**
 * Result of hooks
 */
export declare type HooksResult = {
    [K in HooksName]: Hooks[K]['result'];
};
/**
 * Hook item
 */
export interface HookItem<T extends HooksName> {
    pluginName: string;
    hook: HooksNormalized[T];
}
/**
 * Hook items queue
 */
export interface HookQueue<T extends HooksName> {
    name: T;
    items: HookItem<T>[];
    add: (item: HookItem<T>) => void;
    process: (...args: Parameters<HooksNormalized[T]>) => Promise<HooksResult[T][]>;
}
export {};
