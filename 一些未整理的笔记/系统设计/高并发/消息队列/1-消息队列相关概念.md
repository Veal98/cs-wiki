# 📧 消息队列相关概念

---

## 1. 什么是消息队列 Message Queue

**我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用**。消息队列是分布式系统中重要的组件，<u>使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性</u>。目前使用较多的消息队列有 `ActiveMQ`，`RabbitMQ`，`Kafka`，`RocketMQ`，我们后面会一一对比这些消息队列。

另外，我们知道队列 Queue 是一种**先进先出**的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3... 对于消费者就会按照 1,2,3...的顺序来消费。

## 2. 为什么要使用消息队列

### ① 通过异步处理提高系统性能（削峰、减少响应所需时间）

**发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。**

例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。

只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。

<img src="https://gitee.com/veal98/images/raw/master/img/20201124141151.png" style="zoom:50%;" />

如上图，**在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。**

通过以上分析我们可以得出**消息队列具有很好的削峰作用的功能**——即**通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。** 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：

![](https://gitee.com/veal98/images/raw/master/img/20201124141236.png)

因为**用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败**。因此使用消息队列进行异步处理之后，需要**适当修改业务流程进行配合**，比如**用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功**，以免交易纠纷。这就类似我们平时手机订火车票和电影票。

### ③ 降低系统耦合性

**如果模块之间不直接进行调用，模块之间耦合度就会很低**，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。

通过使用消息队列，**一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用**。

<img src="https://gitee.com/veal98/images/raw/master/img/20201124141349.png" style="zoom: 50%;" />

**在此业务环境下，消息队列使利用`发布-订阅模式`工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。** 从上图可以看到**消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合**，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。**对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计**。

> 💡 `发布-订阅模式`是 **JMS 规范** 两种消息模型中的一种，另外 **AMQP 协议** 还提出了五种消息模型，见下文

**另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。**

## 3. 使用消息队列带来的问题

- **系统可用性降低：** 在加入MQ之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入MQ之后你就需要去考虑了
- **系统复杂性提高：** 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题
- **一致性问题：** 消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息，就会导致数据不一致的情况

## 4. 消息模型

### ① JMS 两种消息模型

`JMS（JAVA Message Service, java消息服务）`是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。**JMS（JAVA Message Service，Java消息服务）API 是一个消息服务的标准或者说是规范**，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。

**`ActiveMQ ` 就是基于 JMS 规范实现的。**

**JMS 定义了五种不同的消息正文格式，以及调用的消息类型**，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

- `StreamMessage `-- Java原始值的数据流
- `MapMessage`--一套名称-值对
- `TextMessage`--一个字符串对象
- `ObjectMessage`--一个序列化的 Java对象
- `BytesMessage`--一个字节的数据流

#### 点对点模型 P2P

**一个生产者向一个特定的队列发布消息，只有一个消费者从该队列中读取消息**；

生产者不需要在接收者消费该消息期间处于运行状态，接收者也同样不需要在消息发送时处于运行状态；每一个成功处理的消息都由接收者签收；多个消费者对于队列内的消息是竞争消费关系，每个消费者只能收到队列中的一部分消息。

![](https://gitee.com/veal98/images/raw/master/img/20201124141849.png)

#### 发布/订阅模型 Pub/Sub

**一个生产者向一个特定的队列发布消息，0 个或多个订阅者可以接受来自特定消息主题的消息**；

发布者需要创建一个`订阅主题（Topic）`以便客户能够购订阅并保持持续的活动以接受消息，**一个订阅主题是由至少一个队列（Queue）组成的，除非订阅者创建了持久的订阅，在订阅者未连接时发布的消息将在订阅者重新连接时重新发布**，每个消费者都能收到全量的消息。

![](https://gitee.com/veal98/images/raw/master/img/20201124141856.png)

### ② AMQP 五种消息模型

AMQP，即 `Advanced Message Queuing Protocol`，一个提供统一消息服务的**应用层**标准 **高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准, 为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

**`RabbitMQ `就是基于 AMQP 协议实现的。**

AMQP  提供了五种消息模型：

- **direct exchange**
- **fanout exchange**
- **topic change**
- **headers exchange**
- **system exchange**

本质来讲，后四种和 JMS 的 Pub/Sub 模型没有太大差别，仅是在路由机制上做了更详细的划分

### ③ JMS vs AMQP

|   对比方向   | JMS                                     | AMQP                                                         |
| ---------- | --------------------------------------- | ------------------------------------------------------------ |
|     定义     | Java API                                | 协议                                                         |
|    跨语言    | 否                                      | 是                                                           |
|    跨平台    | 否                                      | 是                                                           |
| 支持消息类型 | 提供两种消息模型：①Peer-2-Peer;②Pub/sub | 提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分； |
| 支持消息类型 | 支持 5 种消息类型                       | byte[]（二进制）                                             |

**总结：**

- **AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范**。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。
- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。
- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。

## 5. 常见的消息队列对比

| 对比方向 | 概要                                                         |
| -------- | ------------------------------------------------------------ |
| 吞吐量   | 万级的 `ActiveMQ` 和 `RabbitMQ `的吞吐量（`ActiveMQ `的性能最差）要比 十万级甚至是百万级的 `RocketMQ `和 `Kafka `低一个数量级。 |
| 可用性   | 都可以实现高可用。`ActiveMQ` 和 `RabbitMQ` 都是基于主从架构实现高可用性。`RocketMQ `基于分布式架构。 `kafka `也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 时效性   | `RabbitMQ `基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。 |
| 功能支持 | 除了 `Kafka`，其他三个功能都较为完备。 `Kafka `功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
| 消息丢失 | `ActiveMQ `和 `RabbitMQ `丢失的可能性非常低， `RocketMQ` 和 `Kafka `理论上不会丢失。 |

**总结：**

- 😥 `ActiveMQ` 的社区算是比较成熟，但是较目前来说，`ActiveMQ `的性能比较差，而且版本迭代很慢，**不推荐使用**。

- `RabbitMQ `在吞吐量方面虽然稍逊于 `Kafka `和 `RocketMQ `，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 `RabbitMQ` 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。

  👍 **如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，`RabbitMQ `一定是你的首选。**

  👍 **如果是大数据领域的实时计算、日志采集等场景，用 `Kafka `是业内标准的，绝对没问题**，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。

- `RocketMQ `阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 `RocketMQ `有阿里巴巴的实际业务场景的实战考验。`RocketMQ `社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险.

- `kafka `的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 `kafka `最好是支撑较少的 topic 数量即可，保证其超高吞吐量。`kafka `唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性，天然适合大数据实时计算以及日志收集。

## 📚 References

- [Github - Advanced Java](https://doocs.gitee.io/advanced-java/#/./docs/distributed-system/distributed-system-interview)
- [Github - CS-Notes](http://cyc2018.gitee.io/cs-notes/#/notes/分布式?id=一、分布式锁)
- [Github - JavaGuide](https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/分布式?id=二-分布式事务)
- 《大型网站技术架构：核心原理与案例分析》
- [知乎 - 消息队列漫谈：什么是消息模型？](https://zhuanlan.zhihu.com/p/99791229)