# â­ é‡è¦é›†åˆæºç åˆ†æ

---

## 1. ArrayList æºç åˆ†æ

`ArrayList `çš„åº•å±‚æ˜¯**æ•°ç»„é˜Ÿåˆ—**ï¼Œç›¸å½“äºåŠ¨æ€æ•°ç»„ã€‚ä¸ Java ä¸­çš„æ•°ç»„ç›¸æ¯”ï¼Œå®ƒçš„å®¹é‡èƒ½åŠ¨æ€å¢é•¿ã€‚

- `ArrayList `ç»§æ‰¿äº† `AbstractList`ï¼Œå®ç°äº†Listã€‚å®ƒæ˜¯ä¸€ä¸ªæ•°ç»„é˜Ÿåˆ—ï¼Œæä¾›äº†ç›¸å…³çš„æ·»åŠ ã€åˆ é™¤ã€ä¿®æ”¹ã€éå†ç­‰åŠŸèƒ½ã€‚

- `ArrayList `å®ç°äº† `RandomAccess `æ¥å£ï¼Œ `RandomAccess `æ˜¯ä¸€ä¸ªæ ‡å¿—æ¥å£ï¼Œè¡¨æ˜å®ç°è¿™ä¸ªè¿™ä¸ªæ¥å£çš„ `List `é›†åˆæ˜¯æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®çš„ã€‚åœ¨ `ArrayList `ä¸­ï¼Œæˆ‘ä»¬å³å¯ä»¥é€šè¿‡å…ƒç´ çš„åºå·å¿«é€Ÿè·å–å…ƒç´ å¯¹è±¡ï¼Œè¿™å°±æ˜¯å¿«é€Ÿéšæœºè®¿é—®ã€‚

- `ArrayList `å®ç°äº†`Cloneable `æ¥å£ï¼Œå³è¦†ç›–äº†å‡½æ•° `clone()`ï¼Œèƒ½è¢«å…‹éš†ã€‚

- `ArrayList` å®ç°` java.io.Serializable` æ¥å£ï¼Œè¿™æ„å‘³ç€ `ArrayList` æ”¯æŒåºåˆ—åŒ–ï¼Œèƒ½é€šè¿‡åºåˆ—åŒ–å»ä¼ è¾“ã€‚

å’Œ `Vector `ä¸åŒï¼Œ**`ArrayList `ä¸­çš„æ“ä½œä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„**ï¼æ‰€ä»¥ï¼Œå»ºè®®åœ¨å•çº¿ç¨‹ä¸­æ‰ä½¿ç”¨ `ArrayList`ï¼Œè€Œåœ¨å¤šçº¿ç¨‹ä¸­å¯ä»¥é€‰æ‹© `Vector `æˆ–è€… `CopyOnWriteArrayList`ã€‚

âœ ä¸‹é¢æ˜¯`ArrayList` æ ¸å¿ƒæºç çš„è¯¦ç»†è§£è¯»ï¼š

```java
package java.util;

import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;


public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * é»˜è®¤åˆå§‹å®¹é‡å¤§å°
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * ç©ºæ•°ç»„ï¼ˆç”¨äºç©ºå®ä¾‹ï¼‰ã€‚
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

     //ç”¨äºé»˜è®¤å¤§å°ç©ºå®ä¾‹çš„å…±äº«ç©ºæ•°ç»„å®ä¾‹ã€‚
      //æˆ‘ä»¬æŠŠå®ƒä»EMPTY_ELEMENTDATAæ•°ç»„ä¸­åŒºåˆ†å‡ºæ¥ï¼Œä»¥çŸ¥é“åœ¨æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ æ—¶å®¹é‡éœ€è¦å¢åŠ å¤šå°‘ã€‚
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * ä¿å­˜ArrayListæ•°æ®çš„æ•°ç»„
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList æ‰€åŒ…å«çš„å…ƒç´ ä¸ªæ•°
     */
    private int size;

```

### â‘  æ„é€ å‡½æ•°

```java
 	/**
     * å¸¦åˆå§‹å®¹é‡å‚æ•°çš„æ„é€ å‡½æ•°ï¼ˆç”¨æˆ·å¯ä»¥åœ¨åˆ›å»ºArrayListå¯¹è±¡æ—¶è‡ªå·±æŒ‡å®šé›†åˆçš„åˆå§‹å¤§å°ï¼‰
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            //å¦‚æœä¼ å…¥çš„å‚æ•°å¤§äº0ï¼Œåˆ›å»ºinitialCapacityå¤§å°çš„æ•°ç»„
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //å¦‚æœä¼ å…¥çš„å‚æ•°ç­‰äº0ï¼Œåˆ›å»ºç©ºæ•°ç»„
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //å…¶ä»–æƒ…å†µï¼ŒæŠ›å‡ºå¼‚å¸¸
            throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
        }
    }

    /**
     *é»˜è®¤æ— å‚æ„é€ å‡½æ•°
     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA ä¸º0.åˆå§‹åŒ–ä¸º10ï¼Œä¹Ÿå°±æ˜¯è¯´åˆå§‹å…¶å®æ˜¯ç©ºæ•°ç»„ å½“æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ çš„æ—¶å€™æ•°ç»„å®¹é‡æ‰å˜æˆ10
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
     * æ„é€ ä¸€ä¸ªåŒ…å«æŒ‡å®šé›†åˆçš„å…ƒç´ çš„åˆ—è¡¨ï¼ŒæŒ‰ç…§å®ƒä»¬ç”±é›†åˆçš„è¿­ä»£å™¨è¿”å›çš„é¡ºåºã€‚
     */
    public ArrayList(Collection<? extends E> c) {
        //å°†æŒ‡å®šé›†åˆè½¬æ¢ä¸ºæ•°ç»„
        elementData = c.toArray();
        //å¦‚æœelementDataæ•°ç»„çš„é•¿åº¦ä¸ä¸º0
        if ((size = elementData.length) != 0) {
            // å¦‚æœelementDataä¸æ˜¯Objectç±»å‹æ•°æ®ï¼ˆc.toArrayå¯èƒ½è¿”å›çš„ä¸æ˜¯Objectç±»å‹çš„æ•°ç»„æ‰€ä»¥åŠ ä¸Šä¸‹é¢çš„è¯­å¥ç”¨äºåˆ¤æ–­ï¼‰      
            if (elementData.getClass() != Object[].class)
                //å°†åŸæ¥ä¸æ˜¯Objectç±»å‹çš„elementDataæ•°ç»„çš„å†…å®¹ï¼Œèµ‹å€¼ç»™æ–°çš„Objectç±»å‹çš„elementDataæ•°ç»„
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // å…¶ä»–æƒ…å†µï¼Œç”¨ç©ºæ•°ç»„ä»£æ›¿
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
```

### â‘¡ æ‰©å®¹æœºåˆ¶

#### â…  è‡ªåŠ¨æ‰©å®¹

 `ArrayList ` è‡ªåŠ¨æ‰©å®¹å‘ç”Ÿåœ¨ `add()` æ–¹æ³•è°ƒç”¨çš„æ—¶å€™ï¼š

```java
	/**
     * å°†æŒ‡å®šçš„å…ƒç´ è¿½åŠ åˆ°æ­¤åˆ—è¡¨çš„æœ«å°¾ã€‚ 
     */
    public boolean add(E e) {
        // æ‰©å®¹
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //è¿™é‡Œçœ‹åˆ°ArrayListæ·»åŠ å…ƒç´ çš„å®è´¨å°±ç›¸å½“äºä¸ºæ•°ç»„èµ‹å€¼
        elementData[size++] = e;
        return true;
    }

    /**
     * åœ¨æ­¤åˆ—è¡¨ä¸­çš„æŒ‡å®šä½ç½®æ’å…¥æŒ‡å®šçš„å…ƒç´ ã€‚ 
     *å…ˆè°ƒç”¨ rangeCheckForAdd å¯¹indexè¿›è¡Œç•Œé™æ£€æŸ¥ï¼›ç„¶åè°ƒç”¨ ensureCapacityInternal æ–¹æ³•ä¿è¯capacityè¶³å¤Ÿå¤§ï¼›
     *å†å°†ä»indexå¼€å§‹ä¹‹åçš„æ‰€æœ‰æˆå‘˜åç§»ä¸€ä¸ªä½ç½®ï¼›å°†elementæ’å…¥indexä½ç½®ï¼›æœ€åsizeåŠ 1ã€‚
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //arraycopy()å®ç°æ•°ç»„ä¹‹é—´å¤åˆ¶çš„æ–¹æ³•ï¼Œä¸‹é¢å°±ç”¨åˆ°äº†arraycopy()æ–¹æ³•å®ç°æ•°ç»„è‡ªå·±å¤åˆ¶è‡ªå·±
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
```

`ensureCapacityInternal()` æ˜¯ç”¨æ¥**ä»¥æœ€å°å®¹é‡è¿›è¡Œæ‰©å®¹**çš„ï¼ˆå°†ç”¨æˆ·ä¼ å…¥çš„å‚æ•°å’Œé»˜è®¤çš„å®¹é‡è¿›è¡Œæ¯”è¾ƒï¼Œé€‰å–æœ€å¤§å€¼ï¼‰ï¼š

```java
	//ä»¥æœ€å°å®¹é‡è¿›è¡Œæ‰©å®¹
    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
```

`calculateCapacity` ç”¨æ¥è·å–æœ€å°å®¹é‡ `minCapacity`ï¼š

```java
	// è·å–æœ€å°å®¹é‡
	private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }
```

`ensureExplicitCapacity` åˆ¤æ–­è¯¥ `ArrayList `æ˜¯å¦éœ€è¦æ‰©å®¹ï¼ˆå¦‚æœæœ€å°æ‰©å®¹é‡å¤§äºç°å·²å­˜åœ¨çš„æ•°ç»„å®¹é‡ï¼Œåˆ™éœ€è¦è¿›è¡Œæ‰©å®¹ï¼‰ï¼š

```java
	//åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // å¦‚æœæœ€å°æ‰©å®¹é‡å¤§äºç°å·²å­˜åœ¨çš„æ•°ç»„å®¹é‡ï¼Œåˆ™éœ€è¦è¿›è¡Œæ‰©å®¹
        if (minCapacity - elementData.length > 0)
            //è°ƒç”¨growæ–¹æ³•è¿›è¡Œæ‰©å®¹ï¼Œè°ƒç”¨æ­¤æ–¹æ³•ä»£è¡¨å·²ç»å¼€å§‹æ‰©å®¹äº†
            grow(minCapacity);
    }
```

`ArrayList `æ‰©å®¹çš„æ ¸å¿ƒæ–¹æ³• `grow`ï¼š

```java
	/**
     * è¦åˆ†é…çš„æœ€å¤§æ•°ç»„å¤§å°
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * ArrayListæ‰©å®¹çš„æ ¸å¿ƒæ–¹æ³•ã€‚
     */
    private void grow(int minCapacity) {
        // oldCapacityä¸ºæ—§å®¹é‡ï¼ŒnewCapacityä¸ºæ–°å®¹é‡
        int oldCapacity = elementData.length;
        //å°†oldCapacity å³ç§»ä¸€ä½ï¼Œå…¶æ•ˆæœç›¸å½“äºoldCapacity /2ï¼Œ
        //æˆ‘ä»¬çŸ¥é“ä½è¿ç®—çš„é€Ÿåº¦è¿œè¿œå¿«äºæ•´é™¤è¿ç®—ï¼Œæ•´å¥è¿ç®—å¼çš„ç»“æœå°±æ˜¯å°†æ–°å®¹é‡æ›´æ–°ä¸ºæ—§å®¹é‡çš„1.5å€ï¼Œ
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        //å†åˆ¤æ–­ä¸€ä¸‹æ–°æ•°ç»„çš„å®¹é‡å¤Ÿä¸å¤Ÿï¼Œå¤Ÿäº†å°±ç›´æ¥ä½¿ç”¨è¿™ä¸ªé•¿åº¦åˆ›å»ºæ–°æ•°ç»„. è‹¥è¿˜æ˜¯å°äºæœ€å°éœ€è¦å®¹é‡ï¼Œé‚£ä¹ˆå°±æŠŠæœ€å°éœ€è¦å®¹é‡å½“ä½œæ•°ç»„çš„æ–°å®¹é‡ï¼Œ
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        //å†æ£€æŸ¥æ–°å®¹é‡æ˜¯å¦è¶…å‡ºäº†ArrayListæ‰€å®šä¹‰çš„æœ€å¤§å®¹é‡ï¼Œ
        //è‹¥è¶…å‡ºäº†ï¼Œåˆ™è°ƒç”¨hugeCapacity()æ¥æ¯”è¾ƒminCapacityå’Œ MAX_ARRAY_SIZEï¼Œ
        //å¦‚æœminCapacityå¤§äºMAX_ARRAY_SIZEï¼Œåˆ™æ–°å®¹é‡åˆ™ä¸ºInterger.MAX_VALUEï¼Œå¦åˆ™ï¼Œæ–°å®¹é‡å¤§å°åˆ™ä¸º MAX_ARRAY_SIZEã€‚
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        
        // è°ƒç”¨Arrays.copyOfæ–¹æ³•å°†elementDataæ•°ç»„æŒ‡å‘æ–°çš„å†…å­˜ç©ºé—´ï¼ˆnewCapacityçš„è¿ç»­ç©ºé—´ï¼‰
        // å¹¶å°†elementDataçš„æ•°æ®å¤åˆ¶åˆ°æ–°çš„å†…å­˜ç©ºé—´
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
    //æ¯”è¾ƒ minCapacity å’Œ MAX_ARRAY_SIZE
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
```

ä» `grow` æ–¹æ³•ä¸­æˆ‘ä»¬å¯ä»¥æ¸…æ™°çš„çœ‹å‡ºå…¶å® **`ArrayList `æ‰©å®¹çš„æœ¬è´¨å°±æ˜¯è®¡ç®—å‡ºæ–°çš„æ‰©å®¹æ•°ç»„çš„ `size` åå®ä¾‹åŒ–ï¼Œå¹¶å°†åŸæœ‰æ•°ç»„å†…å®¹å¤åˆ¶åˆ°æ–°æ•°ç»„ä¸­å»ã€‚**

#### â…¡ ä½¿ç”¨ ensureCapacity æé«˜æ·»åŠ é€Ÿåº¦

åœ¨æ·»åŠ  `add` å¤§é‡å…ƒç´ å‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `ensureCapacity `æ“ä½œæ¥å¢åŠ  `ArrayList `å®ä¾‹çš„å®¹é‡ã€‚è¿™æ ·å¯ä»¥å¤§å¤§æé«˜æ·»åŠ å…ƒç´ çš„é€Ÿåº¦ã€‚

```java
	/**
     * å¦‚æœ‰å¿…è¦ï¼Œå¢åŠ æ­¤ArrayListå®ä¾‹çš„å®¹é‡ï¼Œä»¥ç¡®ä¿å®ƒè‡³å°‘èƒ½å®¹çº³å…ƒç´ çš„æ•°é‡
     * @param   minCapacity   æ‰€éœ€çš„æœ€å°å®¹é‡
     */
    public void ensureCapacity(int minCapacity) {
        //å¦‚æœæ˜¯trueï¼ŒminExpandçš„å€¼ä¸º0ï¼Œå¦‚æœæ˜¯false,minExpandçš„å€¼ä¸º10
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It's already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;
        //å¦‚æœæœ€å°å®¹é‡å¤§äºå·²æœ‰çš„æœ€å¤§å®¹é‡
        if (minCapacity > minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }
```

ç¤ºä¾‹ï¼š

```java
public class EnsureCapacityTest {  
    public static void main(String[] args){  
        
        final int N = 1000000;  
        Object obj = new Object();  
          
        // æ²¡ç”¨è°ƒç”¨ensureCapacity()æ–¹æ³•åˆå§‹åŒ–ArrayListå¯¹è±¡  
        ArrayList list = new ArrayList();  
        long startTime = System.currentTimeMillis();  
        for(int i=0;i<=N;i++){  
            list.add(obj);  
        }  
        long endTime = System.currentTimeMillis();  
        System.out.println("æ²¡æœ‰è°ƒç”¨ensureCapacity()æ–¹æ³•æ‰€ç”¨æ—¶é—´ï¼š" + (endTime - startTime) + "ms");  
          
        // è°ƒç”¨ensureCapacity()æ–¹æ³•åˆå§‹åŒ–ArrayListå¯¹è±¡  
        list = new ArrayList();  
        startTime = System.currentTimeMillis();  
        list.ensureCapacity(N); // é¢„å…ˆè®¾ç½® list çš„å¤§å°  
        for(int i=0;i<=N;i++){  
            list.add(obj);  
        }  
        endTime = System.currentTimeMillis();  
        System.out.println("è°ƒç”¨ensureCapacity()æ–¹æ³•æ‰€ç”¨æ—¶é—´ï¼š" + (endTime - startTime) + "ms");  
    }  
}  
```

è¾“å‡ºç»“æœï¼š

- æ²¡æœ‰è°ƒç”¨ `ensureCapacity()` æ–¹æ³•æ‰€ç”¨æ—¶é—´ï¼š110ms
- è°ƒç”¨` ensureCapacity()` æ–¹æ³•æ‰€ç”¨æ—¶é—´ï¼š31ms

ç»“æœæ˜¾è€Œæ˜“è§ï¼Œåœ¨ N çš„å€¼å¾ˆå¤§çš„æ—¶å€™ï¼Œä½¿ç”¨ `ensureCapacity()` æ–¹æ³•å¯å¤§å¤§æé«˜æ•ˆç‡ï¼›å½“ N çš„å€¼è¾ƒå°æ—¶ï¼Œåˆ™æ‰€ç”¨æ—¶é—´å·®è·ä¸æ˜æ˜¾ã€‚

### â‘¢ å¢åˆ æ”¹æŸ¥

```java
 	/**
     * æ£€æŸ¥ç»™å®šçš„ç´¢å¼•æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚
     */
    private void rangeCheck(int index) {
        if (index >= size)
       java     throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * addå’ŒaddAllä½¿ç”¨çš„rangeCheckçš„ä¸€ä¸ªç‰ˆæœ¬
     */
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
```

#### å¢

```java
	// ------------------ å¢åŠ  -----------------------------

	/**
     * å°†æŒ‡å®šçš„å…ƒç´ è¿½åŠ åˆ°æ­¤åˆ—è¡¨çš„æœ«å°¾ã€‚ 
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //è¿™é‡Œçœ‹åˆ°ArrayListæ·»åŠ å…ƒç´ çš„å®è´¨å°±ç›¸å½“äºä¸ºæ•°ç»„èµ‹å€¼
        elementData[size++] = e;
        return true;
    }

    /**
     * åœ¨æ­¤åˆ—è¡¨ä¸­çš„æŒ‡å®šä½ç½®æ’å…¥æŒ‡å®šçš„å…ƒç´ ã€‚ 
     *å…ˆè°ƒç”¨ rangeCheckForAdd å¯¹indexè¿›è¡Œç•Œé™æ£€æŸ¥ï¼›ç„¶åè°ƒç”¨ ensureCapacityInternal æ–¹æ³•ä¿è¯capacityè¶³å¤Ÿå¤§ï¼›
     *å†å°†ä»indexå¼€å§‹ä¹‹åçš„æ‰€æœ‰æˆå‘˜åç§»ä¸€ä¸ªä½ç½®ï¼›å°†elementæ’å…¥indexä½ç½®ï¼›æœ€åsizeåŠ 1ã€‚
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //arraycopy()å®ç°æ•°ç»„ä¹‹é—´å¤åˆ¶çš„ï¼Œä¸‹é¢å°±ç”¨åˆ°äº†arraycopy()æ–¹æ³•å®ç°æ•°ç»„è‡ªå·±å¤åˆ¶è‡ªå·±
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }

	/**
     * æŒ‰æŒ‡å®šé›†åˆçš„Iteratorè¿”å›çš„é¡ºåºå°†æŒ‡å®šé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ è¿½åŠ åˆ°æ­¤åˆ—è¡¨çš„æœ«å°¾ã€‚
     */
    public boolean addAll(Collection<? extends E> c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * å°†æŒ‡å®šé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ æ’å…¥åˆ°æ­¤åˆ—è¡¨ä¸­ï¼Œä»æŒ‡å®šçš„ä½ç½®å¼€å§‹ã€‚
     */
    public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved > 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }
```

#### åˆ 

```java
	// ------------------ åˆ é™¤ -----------------------------

    /**
     * åˆ é™¤è¯¥åˆ—è¡¨ä¸­æŒ‡å®šä½ç½®çš„å…ƒç´ ã€‚ å°†ä»»ä½•åç»­å…ƒç´ ç§»åŠ¨åˆ°å·¦ä¾§ï¼ˆä»å…¶ç´¢å¼•ä¸­å‡å»ä¸€ä¸ªå…ƒç´ ï¼‰ã€‚ 
     */
    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
        //ä»åˆ—è¡¨ä¸­åˆ é™¤çš„å…ƒç´  
        return oldValue;
    }

    /**
     * ä»åˆ—è¡¨ä¸­åˆ é™¤æŒ‡å®šå…ƒç´ çš„ç¬¬ä¸€ä¸ªå‡ºç°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚ å¦‚æœåˆ—è¡¨ä¸åŒ…å«è¯¥å…ƒç´ ï¼Œåˆ™å®ƒä¸ä¼šæ›´æ”¹ã€‚
     *è¿”å›trueï¼Œå¦‚æœæ­¤åˆ—è¡¨åŒ…å«æŒ‡å®šçš„å…ƒç´ 
     */
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    /*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

    /**
     * ä»åˆ—è¡¨ä¸­åˆ é™¤æ‰€æœ‰å…ƒç´ ã€‚ 
     */
    public void clear() {
        modCount++;

        // æŠŠæ•°ç»„ä¸­æ‰€æœ‰çš„å…ƒç´ çš„å€¼è®¾ä¸ºnull
        for (int i = 0; i < size; i++)
            elementData[i] = null;

        size = 0;
    }

    /**
     * ä»æ­¤åˆ—è¡¨ä¸­åˆ é™¤æ‰€æœ‰ç´¢å¼•ä¸ºfromIndex ï¼ˆå«ï¼‰å’ŒtoIndexä¹‹é—´çš„å…ƒç´ ã€‚
     *å°†ä»»ä½•åç»­å…ƒç´ ç§»åŠ¨åˆ°å·¦ä¾§ï¼ˆå‡å°‘å…¶ç´¢å¼•ï¼‰ã€‚
     */
    protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i < size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }


    /**
     * ä»æ­¤åˆ—è¡¨ä¸­åˆ é™¤æŒ‡å®šé›†åˆä¸­åŒ…å«çš„æ‰€æœ‰å…ƒç´ ã€‚ 
     */
    public boolean removeAll(Collection<?> c) {
        Objects.requireNonNull(c);
        //å¦‚æœæ­¤åˆ—è¡¨è¢«ä¿®æ”¹åˆ™è¿”å›true
        return batchRemove(c, false);
    }

    /**
     * ä»…ä¿ç•™æ­¤åˆ—è¡¨ä¸­åŒ…å«åœ¨æŒ‡å®šé›†åˆä¸­çš„å…ƒç´ ã€‚
     *æ¢å¥è¯è¯´ï¼Œä»æ­¤åˆ—è¡¨ä¸­åˆ é™¤å…¶ä¸­ä¸åŒ…å«åœ¨æŒ‡å®šé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ 
     */
    public boolean retainAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }
```

#### æ”¹

```java
	// ------------------ ä¿®æ”¹ -----------------------------	

    /**
     * ç”¨æŒ‡å®šçš„å…ƒç´ æ›¿æ¢æ­¤åˆ—è¡¨ä¸­æŒ‡å®šä½ç½®çš„å…ƒç´ ã€‚ 
     */
    public E set(int index, E element) {
        //å¯¹indexè¿›è¡Œç•Œé™æ£€æŸ¥
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        //è¿”å›åŸæ¥åœ¨è¿™ä¸ªä½ç½®çš„å…ƒç´ 
        return oldValue;
    }
```

#### æŸ¥

```java
	// ------------------ æŸ¥æ‰¾ -----------------------------

  	@SuppressWarnings("unchecked")
    E elementData(int index) {
        return (E) elementData[index];
    }

	/**
     * è¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šä½ç½®çš„å…ƒç´ ã€‚
     */
    public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }

	/**
     *è¿”å›æ­¤åˆ—è¡¨ä¸­çš„å…ƒç´ æ•°ã€‚ 
     */
    public int size() {
        return size;
    }

    /**
     * å¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«å…ƒç´ ï¼Œåˆ™è¿”å› true ã€‚
     */
    public boolean isEmpty() {
        //æ³¨æ„=å’Œ==çš„åŒºåˆ«
        return size == 0;
    }

    /**
     * å¦‚æœæ­¤åˆ—è¡¨åŒ…å«æŒ‡å®šçš„å…ƒç´ ï¼Œåˆ™è¿”å›true ã€‚
     */
    public boolean contains(Object o) {
        //indexOf()æ–¹æ³•ï¼šè¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šå…ƒç´ çš„é¦–æ¬¡å‡ºç°çš„ç´¢å¼•ï¼Œå¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«æ­¤å…ƒç´ ï¼Œåˆ™ä¸º-1 
        return indexOf(o) >= 0;
    }

    /**
     *è¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šå…ƒç´ çš„é¦–æ¬¡å‡ºç°çš„ç´¢å¼•ï¼Œå¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«æ­¤å…ƒç´ ï¼Œåˆ™ä¸º-1 
     */
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                //equals()æ–¹æ³•æ¯”è¾ƒ
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * è¿”å›æ­¤åˆ—è¡¨ä¸­æŒ‡å®šå…ƒç´ çš„æœ€åä¸€æ¬¡å‡ºç°çš„ç´¢å¼•ï¼Œå¦‚æœæ­¤åˆ—è¡¨ä¸åŒ…å«å…ƒç´ ï¼Œåˆ™è¿”å›-1ã€‚
     * å’Œ indexOf æ¯”èµ·æ¥ï¼Œä¹Ÿå°±æ˜¯ä¿®æ”¹äº†å¾ªç¯çš„é¡ºåºï¼ˆä»å‰å¾€å â€”â€”> ä»åå¾€å‰ï¼‰ç½¢äº†
     */
    public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i >= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = size-1; i >= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
```

### â‘£ toArray

```java
	/**
     *ä»¥æ­£ç¡®çš„é¡ºåºï¼ˆä»ç¬¬ä¸€ä¸ªåˆ°æœ€åä¸€ä¸ªå…ƒç´ ï¼‰è¿”å›ä¸€ä¸ªåŒ…å«æ­¤åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„æ•°ç»„ã€‚ 
     *è¿”å›çš„æ•°ç»„å°†æ˜¯â€œå®‰å…¨çš„â€ï¼Œå› ä¸ºè¯¥åˆ—è¡¨ä¸ä¿ç•™å¯¹å®ƒçš„å¼•ç”¨ã€‚ ï¼ˆæ¢å¥è¯è¯´ï¼Œè¿™ä¸ªæ–¹æ³•å¿…é¡»åˆ†é…ä¸€ä¸ªæ–°çš„æ•°ç»„ï¼‰ã€‚
     *å› æ­¤ï¼Œè°ƒç”¨è€…å¯ä»¥è‡ªç”±åœ°ä¿®æ”¹è¿”å›çš„æ•°ç»„ã€‚ æ­¤æ–¹æ³•å……å½“åŸºäºé˜µåˆ—å’ŒåŸºäºé›†åˆçš„APIä¹‹é—´çš„æ¡¥æ¢ã€‚
     */
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

    /**
     *ä»¥æ­£ç¡®çš„é¡ºåºè¿”å›ä¸€ä¸ªåŒ…å«æ­¤åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„æ•°ç»„ï¼ˆä»ç¬¬ä¸€ä¸ªåˆ°æœ€åä¸€ä¸ªå…ƒç´ ï¼‰; 
     *è¿”å›çš„æ•°ç»„çš„è¿è¡Œæ—¶ç±»å‹æ˜¯æŒ‡å®šæ•°ç»„çš„è¿è¡Œæ—¶ç±»å‹ã€‚ å¦‚æœåˆ—è¡¨é€‚åˆæŒ‡å®šçš„æ•°ç»„ï¼Œåˆ™è¿”å›å…¶ä¸­ã€‚ 
     *å¦åˆ™ï¼Œå°†ä¸ºæŒ‡å®šæ•°ç»„çš„è¿è¡Œæ—¶ç±»å‹å’Œæ­¤åˆ—è¡¨çš„å¤§å°åˆ†é…ä¸€ä¸ªæ–°æ•°ç»„ã€‚ 
     *å¦‚æœåˆ—è¡¨é€‚ç”¨äºæŒ‡å®šçš„æ•°ç»„ï¼Œå…¶ä½™ç©ºé—´ï¼ˆå³æ•°ç»„çš„åˆ—è¡¨æ•°é‡å¤šäºæ­¤å…ƒç´ ï¼‰ï¼Œåˆ™ç´§è·Ÿåœ¨é›†åˆç»“æŸåçš„æ•°ç»„ä¸­çš„å…ƒç´ è®¾ç½®ä¸ºnull ã€‚
     *ï¼ˆè¿™ä»…åœ¨è°ƒç”¨è€…çŸ¥é“åˆ—è¡¨ä¸åŒ…å«ä»»ä½•ç©ºå…ƒç´ çš„æƒ…å†µä¸‹æ‰èƒ½ç¡®å®šåˆ—è¡¨çš„é•¿åº¦ã€‚ï¼‰ 
     */
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            // æ–°å»ºä¸€ä¸ªè¿è¡Œæ—¶ç±»å‹çš„æ•°ç»„ï¼Œä½†æ˜¯ArrayListæ•°ç»„çš„å†…å®¹
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
            //è°ƒç”¨Systemæä¾›çš„arraycopy()æ–¹æ³•å®ç°æ•°ç»„ä¹‹é—´çš„å¤åˆ¶
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }
```

### â‘¤ è¿­ä»£å™¨

```java
	/**
     * ä»åˆ—è¡¨ä¸­çš„æŒ‡å®šä½ç½®å¼€å§‹ï¼Œè¿”å›åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼ˆæŒ‰æ­£ç¡®é¡ºåºï¼‰çš„åˆ—è¡¨è¿­ä»£å™¨ã€‚
     *æŒ‡å®šçš„ç´¢å¼•è¡¨ç¤ºåˆå§‹è°ƒç”¨å°†è¿”å›çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºnext ã€‚ åˆå§‹è°ƒç”¨previouså°†è¿”å›æŒ‡å®šç´¢å¼•å‡1çš„å…ƒç´ ã€‚ 
     *è¿”å›çš„åˆ—è¡¨è¿­ä»£å™¨æ˜¯fail-fast ã€‚ 
     */
    public ListIterator<E> listIterator(int index) {
        if (index < 0 || index > size)
            throw new IndexOutOfBoundsException("Index: "+index);
        return new ListItr(index);
    }

    /**
     *è¿”å›åˆ—è¡¨ä¸­çš„åˆ—è¡¨è¿­ä»£å™¨ï¼ˆæŒ‰é€‚å½“çš„é¡ºåºï¼‰ã€‚ 
     *è¿”å›çš„åˆ—è¡¨è¿­ä»£å™¨æ˜¯fail-fast ã€‚
     */
    public ListIterator<E> listIterator() {
        return new ListItr(0);
    }

    /**
     *ä»¥æ­£ç¡®çš„é¡ºåºè¿”å›è¯¥åˆ—è¡¨ä¸­çš„å…ƒç´ çš„è¿­ä»£å™¨ã€‚ 
     *è¿”å›çš„è¿­ä»£å™¨æ˜¯fail-fast ã€‚ 
     */
    public Iterator<E> iterator() {
        return new Itr();
    }
```

### â‘¥ System.arraycopy() å’Œ Arrays.copyOf() æ–¹æ³•

é€šè¿‡ä¸Šé¢æºç æˆ‘ä»¬å‘ç°è¿™ä¸¤ä¸ªå®ç°æ•°ç»„å¤åˆ¶çš„æ–¹æ³•è¢«å¹¿æ³›ä½¿ç”¨è€Œä¸”å¾ˆå¤šåœ°æ–¹éƒ½ç‰¹åˆ«å·§å¦™ã€‚æ¯”å¦‚ä¸‹é¢ `add(int index, E element)` æ–¹æ³•å°±å¾ˆå·§å¦™çš„ç”¨åˆ°äº† `arraycopy()`æ–¹æ³•è®©æ•°ç»„è‡ªå·±å¤åˆ¶è‡ªå·±ï¼Œå®ç°è®© `index` å¼€å§‹ä¹‹åçš„æ‰€æœ‰æˆå‘˜åç§»ä¸€ä¸ªä½ç½®:

```java
public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //arraycopy()æ–¹æ³•å®ç°æ•°ç»„è‡ªå·±å¤åˆ¶è‡ªå·±
    //elementData:æºæ•°ç»„; index:æºæ•°ç»„ä¸­çš„èµ·å§‹ä½ç½®; elementDataï¼šç›®æ ‡æ•°ç»„ï¼›index + 1ï¼šç›®æ ‡æ•°ç»„ä¸­çš„èµ·å§‹ä½ç½®ï¼› size - indexï¼šè¦å¤åˆ¶çš„æ•°ç»„å…ƒç´ çš„æ•°é‡ï¼›
    System.arraycopy(elementData, index, elementData, index + 1, size - index);
    elementData[index] = element;
    size++;
}
```

âœ `arraycopy()` æºç ï¼š

```java
public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);
```

åˆå¦‚ `toArray()` æ–¹æ³•ä¸­ç”¨åˆ°äº†` copyOf()` æ–¹æ³•ï¼š

```java
public Object[] toArray() {
    //elementDataï¼šè¦å¤åˆ¶çš„æ•°ç»„ï¼›sizeï¼šè¦å¤åˆ¶çš„é•¿åº¦
    return Arrays.copyOf(elementData, size);
}
```

âœ ` copyOf()`  æºç ï¼š

```java
public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    @SuppressWarnings("unchecked")
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}
```

å¯ä»¥å‘ç°`copyOf()`å†…éƒ¨è°ƒç”¨äº†`System.arraycopy()`æ–¹æ³•

**ä¸¤ä¸ªæ–¹æ³•çš„åŒºåˆ«ï¼š**

- `arraycopy()` éœ€è¦ç›®æ ‡æ•°ç»„ï¼Œå°†åŸæ•°ç»„æ‹·è´åˆ°ä½ è‡ªå·±å®šä¹‰çš„æ•°ç»„é‡Œï¼Œè€Œä¸”å¯ä»¥é€‰æ‹©æ‹·è´çš„èµ·ç‚¹å’Œé•¿åº¦ä»¥åŠæ”¾å…¥æ–°æ•°ç»„ä¸­çš„ä½ç½®
- `copyOf()` æ˜¯ç³»ç»Ÿè‡ªåŠ¨åœ¨å†…éƒ¨æ–°å»ºä¸€ä¸ªæ•°ç»„ï¼Œå¹¶è¿”å›è¯¥æ•°ç»„ã€‚

## 2. LinkedList æºç åˆ†æ

`LinkedList` æ˜¯ä¸€ä¸ªå®ç°äº† `List` æ¥å£å’Œ `Deque` æ¥å£çš„**åŒå‘é“¾è¡¨**ã€‚ `LinkedList` åº•å±‚çš„é“¾è¡¨ç»“æ„ä½¿å®ƒæ”¯æŒé«˜æ•ˆçš„æ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œå¦å¤–å®ƒå®ç°äº† `Deque` æ¥å£ï¼Œä½¿å¾— `LinkedList` ç±»ä¹Ÿå…·æœ‰é˜Ÿåˆ—çš„ç‰¹æ€§ï¼š

```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable {
```

`LinkedList` ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¦‚æœæƒ³ä½¿ `LinkedList` å˜æˆçº¿ç¨‹å®‰å…¨çš„ï¼Œå¯ä»¥è°ƒç”¨é™æ€ç±» `Collections` ç±»ä¸­çš„`synchronizedList` æ–¹æ³•ï¼š

```java
List list=Collections.synchronizedList(new LinkedList(...));
```

### â‘   å†…éƒ¨ç»“æ„

<img src="https://gitee.com/veal98/images/raw/master/img/20200912200218.png" style="zoom: 50%;" />

`Node` ç±»å°±ä»£è¡¨åŒå‘é“¾è¡¨çš„èŠ‚ç‚¹ã€‚è¿™ä¸ªç±»æœ‰ä¸‰ä¸ªå±æ€§ï¼Œåˆ†åˆ«æ˜¯å‰é©±èŠ‚ç‚¹ï¼Œæœ¬èŠ‚ç‚¹çš„å€¼ï¼Œåç»§ç»“ç‚¹ã€‚

```java
	private static class Node<E> {
        E item;//èŠ‚ç‚¹å€¼
        Node<E> next;//åç»§èŠ‚ç‚¹
        Node<E> prev;//å‰é©±èŠ‚ç‚¹

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

### â‘¡ æ„é€ å‡½æ•°

**æ— å‚æ„é€ å‡½æ•°ï¼š**

```java
    public LinkedList() {
    }
```

**ç”¨å·²æœ‰çš„é›†åˆåˆ›å»ºé“¾è¡¨çš„æ„é€ å‡½æ•°ï¼š**

```java
    public LinkedList(Collection<? extends E> c) {
        this();
        addAll(c);
    }
```

### â‘¢ å¢åˆ æ”¹æŸ¥

#### â…  å¢ï¼ˆadd æ–¹æ³•ï¼‰

ğŸ‘‰ `add(E e)` ï¼šå°†å…ƒç´ æ·»åŠ åˆ°é“¾è¡¨å°¾éƒ¨

```java
	public boolean add(E e) {
        linkLast(e);
        return true;
    }

    /**
     * é“¾æ¥ä½¿eä½œä¸ºæœ€åä¸€ä¸ªå…ƒç´ ã€‚
     */
    void linkLast(E e) {
        final Node<E> l = last;
        // åˆ›å»ºä¸€ä¸ªä»¥ lï¼ˆå³å°¾èŠ‚ç‚¹ï¼‰ä¸ºå‰é©±èŠ‚ç‚¹çš„ç©ºèŠ‚ç‚¹
        final Node<E> newNode = new Node<>(l, e, null);
        // ä»¤æ–°èŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode; // æŒ‡å‘åç»§å…ƒç´ ä¹Ÿå°±æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ 
        size++;
        modCount++;
    }
```

å›¾ç¤ºï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20200912205712.png" style="zoom:67%;" />![](https://gitee.com/veal98/images/raw/master/img/20200912205849.png)

ğŸ‘‰ `add(int index,E e)`ï¼šåœ¨æŒ‡å®šä½ç½®æ·»åŠ å…ƒç´ 

```java
	public void add(int index, E element) {
        checkPositionIndex(index); //æ£€æŸ¥ç´¢å¼•æ˜¯å¦å¤„äº[0-size]ä¹‹é—´

        if (index == size)//æ·»åŠ åœ¨é“¾è¡¨å°¾éƒ¨
            linkLast(element);
        else//æ·»åŠ åœ¨é“¾è¡¨ä¸­é—´
            linkBefore(element, node(index));
    }

	/**
     * åœ¨èŠ‚ç‚¹ succ ä¹‹å‰æ’å…¥å…ƒç´  e
     */
    void linkBefore(E e, Node<E> succ) {
        // assert succ != null;
        final Node<E> pred = succ.prev;
        // åˆ›å»ºä»¥ pred ä¸ºå‰é©±ï¼Œsucc ä¸ºåç»§çš„ç©ºèŠ‚ç‚¹
        final Node<E> newNode = new Node<>(pred, e, succ);
        // ä»¤ succ çš„å‰é©±èŠ‚ç‚¹ä¸ºæ–°èŠ‚ç‚¹
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }

	/**
     * æ ¹æ®ä¸‹æ ‡æŸ¥æ‰¾èŠ‚ç‚¹
     */
    Node<E> node(int index) {
        // assert isElementIndex(index);

        if (index < (size >> 1)) {
            Node<E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
```

`linkBefore ` æ–¹æ³•éœ€è¦ç»™å®šä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªæ’å…¥èŠ‚ç‚¹çš„å€¼ï¼Œä¸€ä¸ªæŒ‡å®šçš„ `node`ï¼Œæ‰€ä»¥æˆ‘ä»¬åˆè°ƒç”¨äº† `node(index)` å»æ‰¾åˆ° `index` å¯¹åº”çš„ `node`

å›¾ç¤ºï¼šï¼ˆğŸ˜… å¿˜è®°ç”»åŒå‘ç®­å¤´äº†ï¼‰

<img src="https://gitee.com/veal98/images/raw/master/img/20200912202811.png" style="zoom: 67%;" />

ğŸ‘‰ `addAll(Collection c )`ï¼šå°†é›†åˆæ’å…¥åˆ°é“¾è¡¨å°¾éƒ¨

```java
	public boolean addAll(Collection<? extends E> c) {
        return addAll(size, c);
    }
```

ğŸ‘‰ `addAll(int index, Collection c)`ï¼šå°†é›†åˆä»æŒ‡å®šä½ç½®å¼€å§‹æ’å…¥

```java
	public boolean addAll(int index, Collection<? extends E> c) {
        //1:æ£€æŸ¥indexèŒƒå›´æ˜¯å¦åœ¨sizeä¹‹å†…
        checkPositionIndex(index);

        //2:toArray()æ–¹æ³•æŠŠé›†åˆçš„æ•°æ®å­˜åˆ°å¯¹è±¡æ•°ç»„ä¸­
        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;

        //3ï¼šå¾—åˆ°æ’å…¥ä½ç½®çš„å‰é©±èŠ‚ç‚¹å’Œåç»§èŠ‚ç‚¹
        Node<E> pred, succ;
        //å¦‚æœæ’å…¥ä½ç½®ä¸ºå°¾éƒ¨ï¼Œå‰é©±èŠ‚ç‚¹ä¸ºlastï¼Œåç»§èŠ‚ç‚¹ä¸ºnull
        if (index == size) {
            succ = null;
            pred = last;
        }
        //å¦åˆ™ï¼Œè°ƒç”¨node()æ–¹æ³•å¾—åˆ°åç»§èŠ‚ç‚¹ï¼Œå†å¾—åˆ°å‰é©±èŠ‚ç‚¹
        else {
            succ = node(index);
            pred = succ.prev;
        }

        // 4ï¼šéå†æ•°æ®å°†æ•°æ®æ’å…¥
        for (Object o : a) {
            @SuppressWarnings("unchecked") E e = (E) o;
            //åˆ›å»ºæ–°èŠ‚ç‚¹
            Node<E> newNode = new Node<>(pred, e, null);
            //å¦‚æœæ’å…¥ä½ç½®åœ¨é“¾è¡¨å¤´éƒ¨
            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;
            pred = newNode;
        }

        //å¦‚æœæ’å…¥ä½ç½®åœ¨å°¾éƒ¨ï¼Œé‡ç½®lastèŠ‚ç‚¹
        if (succ == null) {
            last = pred;
        }
        //å¦åˆ™ï¼Œå°†æ’å…¥çš„é“¾è¡¨ä¸å…ˆå‰é“¾è¡¨è¿æ¥èµ·æ¥
        else {
            pred.next = succ;
            succ.prev = pred;
        }

        size += numNew;
        modCount++;
        return true;
    }
```

ä¸Šé¢å¯ä»¥çœ‹å‡ºaddAllæ–¹æ³•é€šå¸¸åŒ…æ‹¬ä¸‹é¢å››ä¸ªæ­¥éª¤ï¼š

- æ£€æŸ¥`index`èŒƒå›´æ˜¯å¦åœ¨`size`ä¹‹å†…

- `toArray` æ–¹æ³•æŠŠé›†åˆçš„æ•°æ®å­˜åˆ°å¯¹è±¡æ•°ç»„ä¸­

- å¾—åˆ°æ’å…¥ä½ç½®çš„å‰é©±å’Œåç»§èŠ‚ç‚¹

- éå†æ•°æ®ï¼Œå°†æ•°æ®æ’å…¥åˆ°æŒ‡å®šä½ç½®

ğŸ‘‰ `addFirst(E e)`ï¼šå°†å…ƒç´ æ·»åŠ åˆ°é“¾è¡¨å¤´éƒ¨

```java
 	public void addFirst(E e) {
        linkFirst(e);
    }
	
	// å°†å…ƒç´ æ·»åŠ åˆ°é“¾è¡¨å¤´éƒ¨
	private void linkFirst(E e) {
        final Node<E> f = first;
        final Node<E> newNode = new Node<>(null, e, f);//æ–°å»ºèŠ‚ç‚¹ï¼Œä»¥å¤´èŠ‚ç‚¹ä¸ºåç»§èŠ‚ç‚¹
        first = newNode;
        //å¦‚æœé“¾è¡¨ä¸ºç©ºï¼ŒlastèŠ‚ç‚¹ä¹ŸæŒ‡å‘è¯¥èŠ‚ç‚¹
        if (f == null)
            last = newNode;
        //å¦åˆ™ï¼Œå°†å¤´èŠ‚ç‚¹çš„å‰é©±æŒ‡é’ˆæŒ‡å‘æ–°èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯æŒ‡å‘å‰ä¸€ä¸ªå…ƒç´ 
        else
            f.prev = newNode;
        size++;
        modCount++;
    }
```

å›¾ç¤ºï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20200912205712.png" style="zoom:67%;" />

ğŸ‘‰ `addLast(E e)`ï¼š å°†å…ƒç´ æ·»åŠ åˆ°é“¾è¡¨å°¾éƒ¨ï¼Œä¸ `add(E e)` æ–¹æ³•ä¸€æ ·

```java
	public void addLast(E e) {
        linkLast(e);
    }
```

#### â…¡ æŸ¥

- **æ ¹æ®ä½ç½®ç´¢å¼•è·å–æ•°æ®çš„æ–¹æ³•**ï¼š

  ğŸ‘‰ <u>`get(int index)`ï¼šæ ¹æ®æŒ‡å®šç´¢å¼•è¿”å›æ•°æ®</u>

  ```java
  public E get(int index) {
          //æ£€æŸ¥indexèŒƒå›´æ˜¯å¦åœ¨sizeä¹‹å†…
          checkElementIndex(index);
          //è°ƒç”¨Node(index)å»æ‰¾åˆ°indexå¯¹åº”çš„nodeç„¶åè¿”å›å®ƒçš„å€¼
          return node(index).item;
      }Copy to clipboardErrorCopied
  ```

  ğŸ‘‰ <u>è·å–å¤´èŠ‚ç‚¹ï¼ˆindex=0ï¼‰çš„å››ç§æ–¹æ³•ï¼š</u>

  ```java
  	public E getFirst() {
          final Node<E> f = first;
          if (f == null)
              throw new NoSuchElementException();
          return f.item;
      }
  
  	public E element() {
          return getFirst();
      }
  
  	public E peek() {
          final Node<E> f = first;
          return (f == null) ? null : f.item;
      }
  
  	public E peekFirst() {
          final Node<E> f = first;
          return (f == null) ? null : f.item;
       }
  ```

  **åŒºåˆ«ï¼š** `getFirst()`,`element()`,`peek()`,`peekFirst()` è¿™å››ä¸ªè·å–å¤´ç»“ç‚¹æ–¹æ³•çš„**åŒºåˆ«åœ¨äºå¯¹é“¾è¡¨ä¸ºç©ºæ—¶çš„å¤„ç†**ï¼Œæ˜¯æŠ›å‡ºå¼‚å¸¸è¿˜æ˜¯è¿”å› `null`ï¼Œå…¶ä¸­ `getFirst()` å’Œ `element()` æ–¹æ³•å°†ä¼šåœ¨é“¾è¡¨ä¸ºç©ºæ—¶ï¼ŒæŠ›å‡ºå¼‚å¸¸

  `element()`æ–¹æ³•çš„å†…éƒ¨å°±æ˜¯ä½¿ç”¨ `getFirst()` å®ç°çš„ã€‚å®ƒä»¬ä¼šåœ¨é“¾è¡¨ä¸ºç©ºæ—¶ï¼ŒæŠ›å‡º `NoSuchElementException`

  ğŸ‘‰ <u>è·å–å°¾èŠ‚ç‚¹ï¼ˆindex=-1ï¼‰çš„ä¸¤ç§æ–¹æ³•</u>:

  ```java
   	public E getLast() {
          final Node<E> l = last;
          if (l == null)
              throw new NoSuchElementException();
          return l.item;
      }
   	public E peekLast() {
          final Node<E> l = last;
          return (l == null) ? null : l.item;
      }
  ```

  **ä¸¤è€…åŒºåˆ«ï¼š** `getLast()` æ–¹æ³•åœ¨é“¾è¡¨ä¸ºç©ºæ—¶ï¼Œä¼šæŠ›å‡º `NoSuchElementException`ï¼Œè€Œ `peekLast()` åˆ™ä¸ä¼šï¼Œåªæ˜¯ä¼šè¿”å› `null`ã€‚

- **æ ¹æ®å¯¹è±¡å¾—åˆ°ç´¢å¼•çš„æ–¹æ³•**ï¼š

  `int indexOf(Object o)`ï¼šä»å¤´éå†

  ```java
  	public int indexOf(Object o) {
          int index = 0;
          if (o == null) {
              //ä»å¤´éå†
              for (Node<E> x = first; x != null; x = x.next) {
                  if (x.item == null)
                      return index;
                  index++;
              }
          } else {
              //ä»å¤´éå†
              for (Node<E> x = first; x != null; x = x.next) {
                  if (o.equals(x.item))
                      return index;
                  index++;
              }
          }
          return -1;
      }
  ```

  `int lastIndexOf(Object o)`ï¼šä»å°¾éå†

  ```java
  	public int lastIndexOf(Object o) {
          int index = size;
          if (o == null) {
              //ä»å°¾éå†
              for (Node<E> x = last; x != null; x = x.prev) {
                  index--;
                  if (x.item == null)
                      return index;
              }
          } else {
              //ä»å°¾éå†
              for (Node<E> x = last; x != null; x = x.prev) {
                  index--;
                  if (o.equals(x.item))
                      return index;
              }
          }
          return -1;
      }
  ```

- **æ£€æŸ¥é“¾è¡¨æ˜¯å¦åŒ…å«æŸå¯¹è±¡çš„æ–¹æ³•**ï¼š

  `contains(Object o)`ï¼šæ£€æŸ¥å¯¹è±¡ o æ˜¯å¦å­˜åœ¨äºé“¾è¡¨ä¸­

  ```java
   	public boolean contains(Object o) {
          return indexOf(o) != -1;
      }
  ```

#### â…¢ åˆ 

ğŸ‘‰ `remove()` ,`removeFirst()`,`pop()`: åˆ é™¤å¤´èŠ‚ç‚¹

```java
	public E pop() {
        return removeFirst();
    }

	public E remove() {
        return removeFirst();
    }

	public E removeFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }

	/**
     * åˆ é™¤ä¸ä¸ºç©ºçš„å¤´èŠ‚ç‚¹ f
     */
    private E unlinkFirst(Node<E> f) {
        // assert f == first && f != null;
        final E element = f.item;
        final Node<E> next = f.next;
        f.item = null;
        f.next = null; // help GC
        first = next;
        if (next == null)
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    }
```

ğŸ‘‰ `removeLast()`,`pollLast()`: åˆ é™¤å°¾èŠ‚ç‚¹

```java
	public E removeLast() {
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }
	public E pollLast() {
        final Node<E> l = last;
        return (l == null) ? null : unlinkLast(l);
    }

	/**
     * åˆ é™¤ä¸ä¸ºç©ºçš„å°¾èŠ‚ç‚¹ l
     */
    private E unlinkLast(Node<E> l) {
        // assert l == last && l != null;
        final E element = l.item;
        final Node<E> prev = l.prev;
        l.item = null;
        l.prev = null; // help GC
        last = prev;
        if (prev == null)
            first = null;
        else
            prev.next = null;
        size--;
        modCount++;
        return element;
    }
```

**åŒºåˆ«ï¼š** `removeLast()`åœ¨é“¾è¡¨ä¸ºç©ºæ—¶å°†æŠ›å‡º`NoSuchElementException`ï¼Œè€Œ`pollLast()`æ–¹æ³•è¿”å›`null`ã€‚

ğŸ‘‰ `remove(Object o)`: åˆ é™¤æŒ‡å®šå…ƒç´ 

```java
	public boolean remove(Object o) {
        //å¦‚æœåˆ é™¤å¯¹è±¡ä¸ºnull
        if (o == null) {
            //ä»å¤´å¼€å§‹éå†
            for (Node<E> x = first; x != null; x = x.next) {
                //æ‰¾åˆ°å…ƒç´ 
                if (x.item == null) {
                   //ä»é“¾è¡¨ä¸­ç§»é™¤æ‰¾åˆ°çš„å…ƒç´ 
                    unlink(x);
                    return true;
                }
            }
        } else {
            //ä»å¤´å¼€å§‹éå†
            for (Node<E> x = first; x != null; x = x.next) {
                //æ‰¾åˆ°å…ƒç´ 
                if (o.equals(x.item)) {
                    //ä»é“¾è¡¨ä¸­ç§»é™¤æ‰¾åˆ°çš„å…ƒç´ 
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

	E unlink(Node<E> x) {
        // assert x != null;
        final E element = x.item;
        final Node<E> next = x.next;//å¾—åˆ°åç»§èŠ‚ç‚¹
        final Node<E> prev = x.prev;//å¾—åˆ°å‰é©±èŠ‚ç‚¹

        //åˆ é™¤å‰é©±æŒ‡é’ˆ
        if (prev == null) {
            first = next;//å¦‚æœåˆ é™¤çš„èŠ‚ç‚¹æ˜¯å¤´èŠ‚ç‚¹,ä»¤å¤´èŠ‚ç‚¹æŒ‡å‘è¯¥èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹
        } else {
            prev.next = next;//å°†å‰é©±èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹æŒ‡å‘åç»§èŠ‚ç‚¹
            x.prev = null;
        }

        //åˆ é™¤åç»§æŒ‡é’ˆ
        if (next == null) {
            last = prev;//å¦‚æœåˆ é™¤çš„èŠ‚ç‚¹æ˜¯å°¾èŠ‚ç‚¹,ä»¤å°¾èŠ‚ç‚¹æŒ‡å‘è¯¥èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹
        } else {
            next.prev = prev;
            x.next = null;
        }

        x.item = null;
        size--;
        modCount++;
        return element;
    }
```

å›¾ç¤ºï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20200912205538.png" style="zoom:67%;" />

å½“åˆ é™¤æŒ‡å®šå¯¹è±¡æ—¶ï¼Œåªéœ€è°ƒç”¨ `remove(Object o)` å³å¯ï¼Œä¸è¿‡**è¯¥æ–¹æ³•ä¸€æ¬¡åªä¼šåˆ é™¤ä¸€ä¸ªåŒ¹é…çš„å¯¹è±¡**ï¼Œå¦‚æœåˆ é™¤äº†åŒ¹é…å¯¹è±¡ï¼Œè¿”å› `true`ï¼Œå¦åˆ™ `false`ã€‚

ğŸ‘‰ `remove(int index)`ï¼šåˆ é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ 

```java
	public E remove(int index) {
        //æ£€æŸ¥indexèŒƒå›´
        checkElementIndex(index);
        //å°†èŠ‚ç‚¹åˆ é™¤
        return unlink(node(index));
    }
```

#### â…£ æ”¹

```java
	public E set(int index, E element) {
        checkElementIndex(index);
        Node<E> x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }
```

## 3. HashMap æºç åˆ†æï¼ˆJDK1.8ï¼‰

`HashMap` ä¸»è¦ç”¨æ¥å­˜æ”¾é”®å€¼å¯¹ï¼Œå®ƒåŸºäºå“ˆå¸Œè¡¨çš„ `Map` æ¥å£å®ç°ï¼Œæ˜¯å¸¸ç”¨çš„ Java é›†åˆä¹‹ä¸€ã€‚`key` å”¯ä¸€ï¼Œ`value` å¯ä»¥é‡å¤ï¼Œå…è®¸å­˜å‚¨ `null `é”® `null `å€¼ï¼Œå…ƒç´ æ— åºã€‚

- æ•£åˆ—å‡½æ•°çš„æ„é€ æ–¹æ³•é‡‡ç”¨**é™¤ç•™å–ä½™æ³•**ï¼š`H(key) = key % p` 

- å†²çªå¤„ç†é‡‡ç”¨**æ‹‰é“¾æ³•**ï¼ˆJDK 1.8 é‡‡ç”¨é“¾è¡¨å’Œçº¢é»‘æ ‘ç»“åˆçš„æ–¹æ³•ï¼‰

  âšª æ‹‰é“¾æ³•ï¼šå°†é“¾è¡¨å’Œæ•°ç»„ç›¸ç»“åˆã€‚ä¹Ÿå°±æ˜¯è¯´åˆ›å»ºä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ•°ç»„ä¸­æ¯ä¸€æ ¼å°±æ˜¯ä¸€ä¸ªé“¾è¡¨ã€‚è‹¥é‡åˆ°å“ˆå¸Œå†²çªï¼Œåˆ™å°†å†²çªçš„å€¼åŠ åˆ°é“¾è¡¨ä¸­å³å¯ï¼ˆæ‰€æœ‰çš„åŒä¹‰è¯éƒ½å­˜å‚¨åœ¨ä¸€ä¸ªçº¿æ€§é“¾è¡¨ä¸­ï¼‰ã€‚

  <img src="https://gitee.com/veal98/images/raw/master/img/20200913101133.png" style="zoom:67%;" />

### â‘  åº•å±‚æ•°æ®ç»“æ„åˆ†æ

#### â…  JDK 1.8 ä¹‹å‰

JDK1.8 ä¹‹å‰ `HashMap` ç”± æ•°ç»„+é“¾è¡¨ ç»„æˆçš„ï¼Œæ•°ç»„æ˜¯ `HashMap` çš„ä¸»ä½“ï¼Œé“¾è¡¨åˆ™æ˜¯ä¸»è¦ä¸ºäº†è§£å†³å“ˆå¸Œå†²çªè€Œå­˜åœ¨çš„ï¼ˆâ€œæ‹‰é“¾æ³•â€è§£å†³å†²çªï¼‰

ğŸ¨ å›¾ç¤º `HashMap`ï¼ˆJDK 1.7ï¼‰å­˜å‚¨ç»“æ„ï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20200913102127.png" style="zoom: 50%;" />

`HashMap ` å°† key çš„ hashCode ç»è¿‡ **æ‰°åŠ¨å‡½æ•°** å¤„ç†è¿‡åå¾—åˆ° hash å€¼

âšª **æ‰°åŠ¨å‡½æ•°**æŒ‡çš„å°±æ˜¯ `HashMap` çš„ `hash` æ–¹æ³•ã€‚æºç å¹¶ä¸æ˜¯ç®€å•çš„å°† `hashcode()` çš„ç»“æœä½œä¸º hash å€¼ï¼Œè€Œæ˜¯ç»§ç»­ä½¿ç”¨äº† `hash()` æ–¹æ³•é˜²æ­¢ä¸€äº›æ•ˆæœæ¯”è¾ƒå·®çš„ `hashCode()` ï¼Œæ¢å¥è¯è¯´**ä½¿ç”¨æ‰°åŠ¨å‡½æ•°ä¹‹åå¯ä»¥å‡å°‘å†²çª**ã€‚

```java
// JDK 1.7
static int hash(int h) {
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

å¯¹æ¯”ä¸€ä¸‹ JDK1.8 çš„ `HashMap `çš„ hash æ–¹æ³•æºç ï¼š

```java
// JDK 1.8
static final int hash(Object key) {
    int h;
    // key.hashCode()ï¼šè¿”å›æ•£åˆ—å€¼ä¹Ÿå°±æ˜¯hashcode
    // ^ ï¼šæŒ‰ä½å¼‚æˆ–
    // >>>:æ— ç¬¦å·å³ç§»ï¼Œå¿½ç•¥ç¬¦å·ä½ï¼Œç©ºä½éƒ½ä»¥0è¡¥é½
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

ç›¸æ¯”äº JDK1.8 çš„ hash æ–¹æ³• ï¼ŒJDK 1.7 çš„ hash æ–¹æ³•çš„æ€§èƒ½ä¼šç¨å·®ä¸€ç‚¹ç‚¹ï¼Œå› ä¸ºæ¯•ç«Ÿæ‰°åŠ¨äº† 4 æ¬¡ã€‚

#### â…¡ JDK 1.8 ä¹‹å

JDK1.8 ä»¥ååœ¨è§£å†³å“ˆå¸Œå†²çªæ—¶æœ‰äº†è¾ƒå¤§çš„å˜åŒ–ï¼Œ**å½“é“¾è¡¨é•¿åº¦å¤§äºé˜ˆå€¼ï¼ˆé»˜è®¤ä¸º 8ï¼‰æ—¶ï¼Œå°†é“¾è¡¨è½¬åŒ–ä¸ºçº¢é»‘æ ‘**ï¼ˆå°†é“¾è¡¨è½¬æ¢æˆçº¢é»‘æ ‘å‰ä¼šåˆ¤æ–­ï¼Œå¦‚æœå½“å‰æ•°ç»„çš„é•¿åº¦å°äº 64ï¼Œé‚£ä¹ˆä¼šé€‰æ‹©å…ˆè¿›è¡Œæ•°ç»„æ‰©å®¹ï¼Œè€Œä¸æ˜¯è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼‰ï¼Œä»¥å‡å°‘æœç´¢æ—¶é—´ï¼Œå…·ä½“å¯ä»¥å‚è€ƒæºç ä¸­çš„ `treeifyBin`æ–¹æ³•

ğŸ¨ å›¾ç¤º `HashMap`ï¼ˆJDK 1.8ï¼‰å­˜å‚¨ç»“æ„ï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20200913101953.png" style="zoom: 67%;" />

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ç±»çš„ç»“æ„ï¼š

```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
```

<img src="https://gitee.com/veal98/images/raw/master/img/20200913102424.png" style="zoom:80%;" />

> â“ åœ¨é˜…è¯»æºç çš„æ—¶å€™ä¸€ç›´æœ‰ä¸ªé—®é¢˜å¾ˆå›°æƒ‘ï¼š`HashMap` å·²ç»ç»§æ‰¿äº† `AbstractMap` ï¼Œè€Œ `AbstractMap` ç±»å®ç°äº† `Map` æ¥å£ï¼Œé‚£ä¸ºä»€ä¹ˆ `HashMap` è¿˜è¦åœ¨å®ç° `Map` æ¥å£å‘¢ï¼ŸåŒæ ·åœ¨ `ArrayList` ä¸­ `LinkedList` ä¸­éƒ½æ˜¯è¿™ç§ç»“æ„ã€‚
>
> âœ… æ® Java é›†åˆæ¡†æ¶çš„åˆ›å§‹äºº Josh Bloch æè¿°ï¼Œ**è¿™æ ·çš„å†™æ³•æ˜¯ä¸€ä¸ªå¤±è¯¯**ã€‚åœ¨ Java é›†åˆæ¡†æ¶ä¸­ï¼Œç±»ä¼¼è¿™æ ·çš„å†™æ³•å¾ˆå¤šï¼Œæœ€å¼€å§‹å†™ Java é›†åˆæ¡†æ¶çš„æ—¶å€™ï¼Œä»–è®¤ä¸ºè¿™æ ·å†™ï¼Œåœ¨æŸäº›åœ°æ–¹å¯èƒ½æ˜¯æœ‰ä»·å€¼çš„ï¼Œç›´åˆ°ä»–æ„è¯†åˆ°é”™äº†ã€‚æ˜¾ç„¶çš„ï¼ŒJDK çš„ç»´æŠ¤è€…ï¼Œåæ¥ä¸è®¤ä¸ºè¿™ä¸ªå°å°çš„å¤±è¯¯å€¼å¾—å»ä¿®æ”¹ï¼Œæ‰€ä»¥å°±è¿™æ ·å­˜åœ¨ä¸‹æ¥äº†ã€‚

ç±»çš„å±æ€§ï¼š

```java
	// åºåˆ—å·
    private static final long serialVersionUID = 362498820763181265L;    
    // é»˜è®¤çš„åˆå§‹å®¹é‡æ˜¯16
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   
    // æœ€å¤§å®¹é‡
    static final int MAXIMUM_CAPACITY = 1 << 30; 
    // é»˜è®¤çš„å¡«å……å› å­
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // å½“æ¡¶(bucket)ä¸Šçš„ç»“ç‚¹æ•°å¤§äºè¿™ä¸ªå€¼æ—¶ä¼šè½¬æˆçº¢é»‘æ ‘
    static final int TREEIFY_THRESHOLD = 8; 
    // å½“æ¡¶(bucket)ä¸Šçš„ç»“ç‚¹æ•°å°äºè¿™ä¸ªå€¼æ—¶æ ‘è½¬é“¾è¡¨
    static final int UNTREEIFY_THRESHOLD = 6;
    // æ¡¶ä¸­ç»“æ„è½¬åŒ–ä¸ºçº¢é»‘æ ‘å¯¹åº”çš„tableçš„æœ€å°å¤§å°
    static final int MIN_TREEIFY_CAPACITY = 64;
    // å­˜å‚¨å…ƒç´ çš„æ•°ç»„ï¼Œæ€»æ˜¯2çš„å¹‚æ¬¡å€, ç”¨æ¥åˆå§‹åŒ–
    transient Node<k,v>[] table; 
    // å­˜æ”¾å…·ä½“å…ƒç´ çš„é›†ï¼Œç”¨æ¥å­˜æ”¾ç¼“å­˜
    transient Set<map.entry<k,v>> entrySet;
    // å­˜æ”¾å…ƒç´ çš„ä¸ªæ•°ï¼Œæ³¨æ„è¿™ä¸ªä¸ç­‰äºæ•°ç»„çš„é•¿åº¦ã€‚ 
    transient int size;
    // æ¯æ¬¡æ‰©å®¹å’Œæ›´æ”¹mapç»“æ„çš„è®¡æ•°å™¨ï¼ˆè®°å½•HashMapçš„ä¿®æ”¹æ¬¡æ•°ï¼‰
    transient int modCount;   
    // ä¸´ç•Œå€¼ å½“å­˜æ”¾å…ƒç´ çš„ä¸ªæ•°è¶…è¿‡ä¸´ç•Œå€¼æ—¶ï¼Œä¼šè¿›è¡Œæ‰©å®¹
    int threshold;
    // åŠ è½½å› å­
    final float loadFactor;
```

ğŸ‘‰ `HashMap ` çš„**åˆå§‹å®¹é‡** `DEFAULT_INITIAL_CAPACITY` ä¸º16ï¼Œå¦‚æœéœ€è¦æ‰©å±•æ•°ç»„ï¼Œé‚£ä¹ˆè§„å®šæ˜¯ 2 çš„æ¬¡æ–¹ï¼ˆ`<<1`ï¼‰ã€‚ä¾‹å¦‚ 16 ä¼šæ‰©å……åˆ° 32â€“>64â€“>128â€“>256â€“>512 â€¦

è¿™æ ·æ‰©å……æœ‰ä¸¤ä¸ªåŸå› ï¼š

- é€‰æ‹©è¶³å¤Ÿå¤§çš„æ•°ç»„ï¼Œè®©é”®å€¼å¯¹æ›´å¹³å‡çš„åˆ†å¸ƒåœ¨å„ä¸ªç´¢å¼•ä½ï¼Œå°½é‡å‡å°‘é“¾è¡¨é•¿åº¦ã€‚
- å½“ä½¿ç”¨é™¤ç•™ä½™æ•°æ³•æ—¶ï¼Œèƒ½ä½¿ç”¨ä½è¿ç®—ä»£æ›¿å–æ¨¡è¿ç®—ï¼Œå¾ˆå¤§ç¨‹åº¦ä¸Šæé«˜æ•ˆç‡ï¼ˆæ®è¯´æ˜¯5~8å€ï¼‰ã€‚
  $k \% p$ ç­‰ä»·äº $k \& (p - 1)$ã€‚

ğŸ‘‰ **`loadFactor `åŠ è½½å› å­**ï¼šæ§åˆ¶æ•°ç»„å­˜æ”¾æ•°æ®çš„ç–å¯†ç¨‹åº¦ï¼Œ`loadFactor `è¶Šè¶‹è¿‘äº1ï¼Œé‚£ä¹ˆæ•°ç»„ä¸­å­˜æ”¾çš„æ•°æ®(`entry`)ä¹Ÿå°±è¶Šå¤šï¼Œä¹Ÿå°±è¶Šå¯†ï¼Œä¹Ÿå°±æ˜¯ä¼šè®©é“¾è¡¨çš„é•¿åº¦å¢åŠ ï¼Œ`loadFactor `è¶Šå°ï¼Œä¹Ÿå°±æ˜¯è¶‹è¿‘äº0ï¼Œæ•°ç»„ä¸­å­˜æ”¾çš„æ•°æ®(`entry`)ä¹Ÿå°±è¶Šå°‘ï¼Œä¹Ÿå°±è¶Šç¨€ç–ã€‚

`loadFactor `å¤ªå¤§å¯¼è‡´æŸ¥æ‰¾å…ƒç´ æ•ˆç‡ä½ï¼Œå¤ªå°å¯¼è‡´æ•°ç»„çš„åˆ©ç”¨ç‡ä½ï¼Œå­˜æ”¾çš„æ•°æ®ä¼šå¾ˆåˆ†æ•£ã€‚`loadFactor` çš„é»˜è®¤å€¼ä¸º 0.75f æ˜¯å®˜æ–¹ç»™å‡ºçš„ä¸€ä¸ªæ¯”è¾ƒå¥½çš„ä¸´ç•Œå€¼ã€‚

ç»™å®šçš„é»˜è®¤å®¹é‡ä¸º 16ï¼Œè´Ÿè½½å› å­ä¸º 0.75ã€‚Map åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¸æ–­çš„å¾€é‡Œé¢å­˜æ”¾æ•°æ®ï¼Œ**å½“æ•°é‡è¾¾åˆ°äº† 16 * 0.75 = 12 å°±éœ€è¦å°†å½“å‰ 16 çš„å®¹é‡è¿›è¡Œæ‰©å®¹**ï¼Œè€Œæ‰©å®¹è¿™ä¸ªè¿‡ç¨‹æ¶‰åŠåˆ° rehashã€å¤åˆ¶æ•°æ®ç­‰æ“ä½œï¼Œæ‰€ä»¥éå¸¸æ¶ˆè€—æ€§èƒ½ã€‚

ğŸ‘‰ **`threshold `ä¸´ç•Œå€¼**ï¼š``threshold = capacity * loadFactor`ï¼Œå½“ `å®é™…å­˜æ”¾å…ƒç´ çš„ä¸ªæ•° size >= threshold` çš„æ—¶å€™ï¼Œé‚£ä¹ˆå°±è¦è€ƒè™‘å¯¹æ•°ç»„çš„æ‰©å¢äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªçš„æ„æ€å°±æ˜¯è¡¡é‡æ•°ç»„æ˜¯å¦éœ€è¦æ‰©å¢çš„ä¸€ä¸ªæ ‡å‡†ã€‚

ğŸ‘‰ ä¸Šé¢è¯´è¿‡æ‹‰é“¾æ³•çš„æ•£åˆ—è¡¨æ˜¯é€šè¿‡é“¾è¡¨è§£å†³ç¢°æ’é—®é¢˜çš„ï¼Œæ‰€ä»¥ `HashMap` çš„å†…éƒ¨æ•°ç»„æ˜¯èŠ‚ç‚¹ç±»å‹ï¼š

```java
	// ç»§æ‰¿è‡ª Map.Entry<K,V>
	static class Node<K,V> implements Map.Entry<K,V> {
       final int hash;// å“ˆå¸Œå€¼ï¼Œå­˜æ”¾å…ƒç´ åˆ°hashmapä¸­æ—¶ç”¨æ¥ä¸å…¶ä»–å…ƒç´ hashå€¼æ¯”è¾ƒ
       final K key;//é”®
       V value;//å€¼
       // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
       Node<K,V> next;
       Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }
        // é‡å†™hashCode()æ–¹æ³•
        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }
        // é‡å†™ equals() æ–¹æ³•
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
	}
```

ğŸ‘‰ `TreeNode `æ˜¯ `Node` çš„å­ç±»ï¼Œç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š`Node `æ˜¯å•å‘é“¾è¡¨èŠ‚ç‚¹ï¼Œ`Entry `æ˜¯åŒå‘é“¾è¡¨èŠ‚ç‚¹ï¼Œ`TreeNode`æ˜¯çº¢é»‘æ ‘èŠ‚ç‚¹ã€‚

```java
java.util.HashMap<K, V>.Node<K, V>
    java.util.LinkedMap<K, V>.Entry<K, V>
        java.util.HashMap<K, V>.TreeNode<K, V>
```

`TreeNode `çš„ä»£ç  400 å¤šè¡Œï¼Œæ˜¯å®ç°çº¢é»‘æ ‘çš„èŠ‚ç‚¹ï¼Œå…³äºçº¢é»‘æ ‘ï¼Œè¿™é‡Œæš‚æ—¶ä¸åšè§£é‡Š

```java
	static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // çˆ¶
        TreeNode<K,V> left;    // å·¦
        TreeNode<K,V> right;   // å³
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;           // åˆ¤æ–­é¢œè‰²
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
        // è¿”å›æ ¹èŠ‚ç‚¹
        final TreeNode<K,V> root() {
            for (TreeNode<K,V> r = this, p;;) {
                if ((p = r.parent) == null)
                    return r;
                r = p;
       }
       
       // .......
```

### â‘¡ æ„é€ å‡½æ•°

`HashMap `ä¸­æœ‰å››ä¸ªæ„é€ æ–¹æ³•ï¼Œå®ƒä»¬åˆ†åˆ«å¦‚ä¸‹ï¼š

```java
    // é»˜è®¤æ„é€ å‡½æ•°ã€‚
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted
     }

     // åŒ…å«å¦ä¸€ä¸ªâ€œMapâ€çš„æ„é€ å‡½æ•°
     public HashMap(Map<? extends K, ? extends V> m) {
         this.loadFactor = DEFAULT_LOAD_FACTOR;
         putMapEntries(m, false);//ä¸‹é¢ä¼šåˆ†æåˆ°è¿™ä¸ªæ–¹æ³•
     }

     // æŒ‡å®šâ€œå®¹é‡å¤§å°â€çš„æ„é€ å‡½æ•°
     public HashMap(int initialCapacity) {
         this(initialCapacity, DEFAULT_LOAD_FACTOR);
     }

     // æŒ‡å®šâ€œå®¹é‡å¤§å°â€å’Œâ€œåŠ è½½å› å­â€çš„æ„é€ å‡½æ•°
     public HashMap(int initialCapacity, float loadFactor) {
         if (initialCapacity < 0)
             throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
         if (initialCapacity > MAXIMUM_CAPACITY)
             initialCapacity = MAXIMUM_CAPACITY;
         if (loadFactor <= 0 || Float.isNaN(loadFactor))
             throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
         this.loadFactor = loadFactor;
         this.threshold = tableSizeFor(initialCapacity);
     }
```

`putMapEntries` æ–¹æ³•ï¼š

```java
final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
    int s = m.size();
    if (s > 0) {
        // åˆ¤æ–­tableæ˜¯å¦å·²ç»åˆå§‹åŒ–
        if (table == null) { // pre-size
            // æœªåˆå§‹åŒ–ï¼Œsä¸ºmçš„å®é™…å…ƒç´ ä¸ªæ•°
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft < (float)MAXIMUM_CAPACITY) ?
                    (int)ft : MAXIMUM_CAPACITY);
            // è®¡ç®—å¾—åˆ°çš„tå¤§äºé˜ˆå€¼ï¼Œåˆ™åˆå§‹åŒ–é˜ˆå€¼
            if (t > threshold)
                threshold = tableSizeFor(t);
        }
        // å·²åˆå§‹åŒ–ï¼Œå¹¶ä¸” m å…ƒç´ ä¸ªæ•°å¤§äºé˜ˆå€¼ï¼Œè¿›è¡Œæ‰©å®¹å¤„ç†
        else if (s > threshold)
            resize();
        // å°† m ä¸­çš„æ‰€æœ‰å…ƒç´ æ·»åŠ è‡³ HashMap ä¸­
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}
```

### â‘¢ put æ–¹æ³•

`HashMap `åªæä¾›äº† `put `ç”¨äºæ·»åŠ å…ƒç´ ï¼Œ`putVal `æ–¹æ³•åªæ˜¯ç»™ put æ–¹æ³•è°ƒç”¨çš„ä¸€ä¸ªæ–¹æ³•ï¼Œå¹¶æ²¡æœ‰æä¾›ç»™ç”¨æˆ·ä½¿ç”¨ã€‚

**å¯¹`putVal`æ–¹æ³•æ·»åŠ å…ƒç´ çš„åˆ†æå¦‚ä¸‹ï¼š**

- â‘  å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æ²¡æœ‰å…ƒç´  å°±ç›´æ¥æ’å…¥ã€‚
- â‘¡ å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æœ‰å…ƒç´ å°±å’Œè¦æ’å…¥çš„ key æ¯”è¾ƒï¼Œå¦‚æœ key ç›¸åŒå°±ç›´æ¥è¦†ç›–ï¼Œå¦‚æœ key ä¸ç›¸åŒï¼Œå°±åˆ¤æ–­ p æ˜¯å¦æ˜¯ä¸€ä¸ªæ ‘èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯å°±è°ƒç”¨`e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value)`å°†å…ƒç´ æ·»åŠ è¿›å…¥ã€‚å¦‚æœä¸æ˜¯å°±éå†é“¾è¡¨æ’å…¥(æ’å…¥çš„æ˜¯é“¾è¡¨å°¾éƒ¨)ã€‚

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // tableæœªåˆå§‹åŒ–æˆ–è€…é•¿åº¦ä¸º0ï¼Œè¿›è¡Œæ‰©å®¹
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) & hash ç¡®å®šå…ƒç´ å­˜æ”¾åœ¨å“ªä¸ªæ¡¶ä¸­ï¼Œæ¡¶ä¸ºç©ºï¼Œæ–°ç”Ÿæˆç»“ç‚¹æ”¾å…¥æ¡¶ä¸­(æ­¤æ—¶ï¼Œè¿™ä¸ªç»“ç‚¹æ˜¯æ”¾åœ¨æ•°ç»„ä¸­)
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // æ¡¶ä¸­å·²ç»å­˜åœ¨å…ƒç´ 
    else {
        Node<K,V> e; K k;
        // æ¯”è¾ƒæ¡¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ (æ•°ç»„ä¸­çš„ç»“ç‚¹)çš„hashå€¼ç›¸ç­‰ï¼Œkeyç›¸ç­‰
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
                // å°†ç¬¬ä¸€ä¸ªå…ƒç´ èµ‹å€¼ç»™eï¼Œç”¨eæ¥è®°å½•
                e = p;
        // hashå€¼ä¸ç›¸ç­‰ï¼Œå³keyä¸ç›¸ç­‰ï¼›ä¸ºçº¢é»‘æ ‘ç»“ç‚¹
        else if (p instanceof TreeNode)
            // æ”¾å…¥æ ‘ä¸­
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // ä¸ºé“¾è¡¨ç»“ç‚¹
        else {
            // åœ¨é“¾è¡¨æœ€æœ«æ’å…¥ç»“ç‚¹
            for (int binCount = 0; ; ++binCount) {
                // åˆ°è¾¾é“¾è¡¨çš„å°¾éƒ¨
                if ((e = p.next) == null) {
                    // åœ¨å°¾éƒ¨æ’å…¥æ–°ç»“ç‚¹
                    p.next = newNode(hash, key, value, null);
                    // ç»“ç‚¹æ•°é‡è¾¾åˆ°é˜ˆå€¼ï¼Œè½¬åŒ–ä¸ºçº¢é»‘æ ‘
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    // è·³å‡ºå¾ªç¯
                    break;
                }
                // åˆ¤æ–­é“¾è¡¨ä¸­ç»“ç‚¹çš„keyå€¼ä¸æ’å…¥çš„å…ƒç´ çš„keyå€¼æ˜¯å¦ç›¸ç­‰
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // ç›¸ç­‰ï¼Œè·³å‡ºå¾ªç¯
                    break;
                // ç”¨äºéå†æ¡¶ä¸­çš„é“¾è¡¨ï¼Œä¸å‰é¢çš„e = p.nextç»„åˆï¼Œå¯ä»¥éå†é“¾è¡¨
                p = e;
            }
        }
        // è¡¨ç¤ºåœ¨æ¡¶ä¸­æ‰¾åˆ°keyå€¼ã€hashå€¼ä¸æ’å…¥å…ƒç´ ç›¸ç­‰çš„ç»“ç‚¹
        if (e != null) { 
            // è®°å½•eçš„value
            V oldValue = e.value;
            // onlyIfAbsentä¸ºfalseæˆ–è€…æ—§å€¼ä¸ºnull
            if (!onlyIfAbsent || oldValue == null)
                //ç”¨æ–°å€¼æ›¿æ¢æ—§å€¼
                e.value = value;
            // è®¿é—®åå›è°ƒ
            afterNodeAccess(e);
            // è¿”å›æ—§å€¼
            return oldValue;
        }
    }
    // ç»“æ„æ€§ä¿®æ”¹
    ++modCount;
    // å®é™…å¤§å°å¤§äºé˜ˆå€¼åˆ™æ‰©å®¹
    if (++size > threshold)
        resize();
    // æ’å…¥åå›è°ƒ
    afterNodeInsertion(evict);
    return null;
} 
```

### â‘£ get æ–¹æ³•

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // æ•°ç»„å…ƒç´ ç›¸ç­‰
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // æ¡¶ä¸­ä¸æ­¢ä¸€ä¸ªèŠ‚ç‚¹
        if ((e = first.next) != null) {
            // åœ¨æ ‘ä¸­get
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // åœ¨é“¾è¡¨ä¸­get
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

### â‘¤ resize æ–¹æ³•

è¿›è¡Œæ‰©å®¹ï¼Œä¼šä¼´éšç€ä¸€æ¬¡é‡æ–°`hash`åˆ†é…ï¼Œå¹¶ä¸”ä¼šéå†`hash`è¡¨ä¸­æ‰€æœ‰çš„å…ƒç´ ï¼Œæ˜¯éå¸¸è€—æ—¶çš„ã€‚åœ¨ç¼–å†™ç¨‹åºä¸­ï¼Œè¦å°½é‡é¿å…`resize`ã€‚

```java
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        // è¶…è¿‡æœ€å¤§å€¼å°±ä¸å†æ‰©å……äº†ï¼Œå°±åªå¥½éšä½ ç¢°æ’å»å§
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // æ²¡è¶…è¿‡æœ€å¤§å€¼ï¼Œå°±æ‰©å……ä¸ºåŸæ¥çš„2å€
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else { 
        // signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // è®¡ç®—æ–°çš„resizeä¸Šé™
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // æŠŠæ¯ä¸ªbucketéƒ½ç§»åŠ¨åˆ°æ–°çš„bucketsä¸­
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { 
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        // åŸç´¢å¼•
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // åŸç´¢å¼•+oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // åŸç´¢å¼•æ”¾åˆ°bucketé‡Œ
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // åŸç´¢å¼•+oldCapæ”¾åˆ°bucketé‡Œ
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

## ğŸ“š References

- ã€ŠJava æ ¸å¿ƒæŠ€æœ¯ - å· 1 åŸºç¡€çŸ¥è¯† - ç¬¬ 10 ç‰ˆã€‹

- [ArrayList çš„æ‰©å®¹æœºåˆ¶](https://www.cnblogs.com/dengrongzhang/p/9371551.html)

- [ensureCapacity() æ–¹æ³•æé«˜ ArrayList çš„åˆå§‹åŒ–é€Ÿåº¦](https://www.iteye.com/blog/guojianpeng9806-577602)

- [HashMap å®ç°åŸç†å’Œæºç åˆ†æ](https://blog.csdn.net/u010386612/article/details/80302777)

- [CS-Notes â€” Github](http://cyc2018.gitee.io/cs-notes/#/notes/Java%20%E5%AE%B9%E5%99%A8?id=_1-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84)

- [JavaGuide â€” Github](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap)

  