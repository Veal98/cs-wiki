# ğŸ€ HashMap æºç åˆ†æï¼ˆJDK1.8ï¼‰

---

`HashMap` ä¸»è¦ç”¨æ¥å­˜æ”¾é”®å€¼å¯¹ï¼Œå®ƒåŸºäºå“ˆå¸Œè¡¨çš„ `Map` æ¥å£å®ç°ï¼Œæ˜¯å¸¸ç”¨çš„ Java é›†åˆä¹‹ä¸€ã€‚`key` å”¯ä¸€ï¼Œ`value` å¯ä»¥é‡å¤ï¼Œå…è®¸å­˜å‚¨ `null `é”® `null `å€¼ï¼Œå…ƒç´ æ— åºã€‚

- æ•£åˆ—å‡½æ•°çš„æ„é€ æ–¹æ³•é‡‡ç”¨**é™¤ç•™å–ä½™æ³•**ï¼š`H(key) = key % p` 

- å†²çªå¤„ç†é‡‡ç”¨**æ‹‰é“¾æ³•**ï¼ˆJDK 1.8 é‡‡ç”¨é“¾è¡¨å’Œçº¢é»‘æ ‘ç»“åˆçš„æ–¹æ³•ï¼‰

  âšª æ‹‰é“¾æ³•ï¼šå°†é“¾è¡¨å’Œæ•°ç»„ç›¸ç»“åˆã€‚ä¹Ÿå°±æ˜¯è¯´åˆ›å»ºä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ•°ç»„ä¸­æ¯ä¸€æ ¼å°±æ˜¯ä¸€ä¸ªé“¾è¡¨ã€‚è‹¥é‡åˆ°å“ˆå¸Œå†²çªï¼Œåˆ™å°†å†²çªçš„å€¼åŠ åˆ°é“¾è¡¨ä¸­å³å¯ï¼ˆæ‰€æœ‰çš„åŒä¹‰è¯éƒ½å­˜å‚¨åœ¨ä¸€ä¸ªçº¿æ€§é“¾è¡¨ä¸­ï¼‰ã€‚

  <img src="https://gitee.com/veal98/images/raw/master/img/20200913101133.png" style="zoom:67%;" />

## 1. åº•å±‚æ•°æ®ç»“æ„åˆ†æ

### â…  JDK 1.8 ä¹‹å‰

JDK1.8 ä¹‹å‰ `HashMap` ç”± æ•°ç»„+é“¾è¡¨ ç»„æˆçš„ï¼Œæ•°ç»„æ˜¯ `HashMap` çš„ä¸»ä½“ï¼Œé“¾è¡¨åˆ™æ˜¯ä¸»è¦ä¸ºäº†è§£å†³å“ˆå¸Œå†²çªè€Œå­˜åœ¨çš„ï¼ˆâ€œæ‹‰é“¾æ³•â€è§£å†³å†²çªï¼‰

ğŸ¨ å›¾ç¤º `HashMap`ï¼ˆJDK 1.7ï¼‰å­˜å‚¨ç»“æ„ï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20200913102127.png" style="zoom: 50%;" />

`HashMap ` å°† key çš„ hashCode ç»è¿‡ **æ‰°åŠ¨å‡½æ•°** å¤„ç†è¿‡åå¾—åˆ° hash å€¼

âšª **æ‰°åŠ¨å‡½æ•°**æŒ‡çš„å°±æ˜¯ `HashMap` çš„ `hash` æ–¹æ³•ã€‚æºç å¹¶ä¸æ˜¯ç®€å•çš„å°† `hashcode()` çš„ç»“æœä½œä¸º hash å€¼ï¼Œè€Œæ˜¯ç»§ç»­ä½¿ç”¨äº† `hash()` æ–¹æ³•é˜²æ­¢ä¸€äº›æ•ˆæœæ¯”è¾ƒå·®çš„ `hashCode()` ï¼Œæ¢å¥è¯è¯´**ä½¿ç”¨æ‰°åŠ¨å‡½æ•°ä¹‹åå¯ä»¥å‡å°‘å†²çª**ã€‚

```java
// JDK 1.7
static int hash(int h) {
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

å¯¹æ¯”ä¸€ä¸‹ JDK1.8 çš„ `HashMap `çš„ hash æ–¹æ³•æºç ï¼š

```java
// JDK 1.8
static final int hash(Object key) {
    int h;
    // key.hashCode()ï¼šè¿”å›æ•£åˆ—å€¼ä¹Ÿå°±æ˜¯hashcode
    // ^ ï¼šæŒ‰ä½å¼‚æˆ–
    // >>>:æ— ç¬¦å·å³ç§»ï¼Œå¿½ç•¥ç¬¦å·ä½ï¼Œç©ºä½éƒ½ä»¥0è¡¥é½
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

ç›¸æ¯”äº JDK1.8 çš„ hash æ–¹æ³• ï¼ŒJDK 1.7 çš„ hash æ–¹æ³•çš„æ€§èƒ½ä¼šç¨å·®ä¸€ç‚¹ç‚¹ï¼Œå› ä¸ºæ¯•ç«Ÿæ‰°åŠ¨äº† 4 æ¬¡ã€‚

### â…¡ JDK 1.8 ä¹‹å

JDK1.8 ä»¥ååœ¨è§£å†³å“ˆå¸Œå†²çªæ—¶æœ‰äº†è¾ƒå¤§çš„å˜åŒ–ï¼Œ**å½“é“¾è¡¨é•¿åº¦å¤§äºé˜ˆå€¼ï¼ˆé»˜è®¤ä¸º 8ï¼‰æ—¶ï¼Œå°†é“¾è¡¨è½¬åŒ–ä¸ºçº¢é»‘æ ‘**ï¼ˆå°†é“¾è¡¨è½¬æ¢æˆçº¢é»‘æ ‘å‰ä¼šåˆ¤æ–­ï¼Œå¦‚æœå½“å‰æ•°ç»„çš„é•¿åº¦å°äº 64ï¼Œé‚£ä¹ˆä¼šé€‰æ‹©å…ˆè¿›è¡Œæ•°ç»„æ‰©å®¹ï¼Œè€Œä¸æ˜¯è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼‰ï¼Œä»¥å‡å°‘æœç´¢æ—¶é—´ï¼Œå…·ä½“å¯ä»¥å‚è€ƒæºç ä¸­çš„ `treeifyBin`æ–¹æ³•

ğŸ¨ å›¾ç¤º `HashMap`ï¼ˆJDK 1.8ï¼‰å­˜å‚¨ç»“æ„ï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20200913101953.png" style="zoom: 67%;" />

æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ç±»çš„ç»“æ„ï¼š

```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
```

<img src="https://gitee.com/veal98/images/raw/master/img/20200913102424.png" style="zoom:80%;" />

> â“ åœ¨é˜…è¯»æºç çš„æ—¶å€™ä¸€ç›´æœ‰ä¸ªé—®é¢˜å¾ˆå›°æƒ‘ï¼š`HashMap` å·²ç»ç»§æ‰¿äº† `AbstractMap` ï¼Œè€Œ `AbstractMap` ç±»å®ç°äº† `Map` æ¥å£ï¼Œé‚£ä¸ºä»€ä¹ˆ `HashMap` è¿˜è¦åœ¨å®ç° `Map` æ¥å£å‘¢ï¼ŸåŒæ ·åœ¨ `ArrayList` ä¸­ `LinkedList` ä¸­éƒ½æ˜¯è¿™ç§ç»“æ„ã€‚
>
> âœ… æ® Java é›†åˆæ¡†æ¶çš„åˆ›å§‹äºº Josh Bloch æè¿°ï¼Œ**è¿™æ ·çš„å†™æ³•æ˜¯ä¸€ä¸ªå¤±è¯¯**ã€‚åœ¨ Java é›†åˆæ¡†æ¶ä¸­ï¼Œç±»ä¼¼è¿™æ ·çš„å†™æ³•å¾ˆå¤šï¼Œæœ€å¼€å§‹å†™ Java é›†åˆæ¡†æ¶çš„æ—¶å€™ï¼Œä»–è®¤ä¸ºè¿™æ ·å†™ï¼Œåœ¨æŸäº›åœ°æ–¹å¯èƒ½æ˜¯æœ‰ä»·å€¼çš„ï¼Œç›´åˆ°ä»–æ„è¯†åˆ°é”™äº†ã€‚æ˜¾ç„¶çš„ï¼ŒJDK çš„ç»´æŠ¤è€…ï¼Œåæ¥ä¸è®¤ä¸ºè¿™ä¸ªå°å°çš„å¤±è¯¯å€¼å¾—å»ä¿®æ”¹ï¼Œæ‰€ä»¥å°±è¿™æ ·å­˜åœ¨ä¸‹æ¥äº†ã€‚

ç±»çš„å±æ€§ï¼š

```java
	// åºåˆ—å·
    private static final long serialVersionUID = 362498820763181265L;    
    // é»˜è®¤çš„åˆå§‹å®¹é‡æ˜¯16
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   
    // æœ€å¤§å®¹é‡
    static final int MAXIMUM_CAPACITY = 1 << 30; 
    // é»˜è®¤çš„å¡«å……å› å­
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // å½“æ¡¶(bucket)ä¸Šçš„ç»“ç‚¹æ•°å¤§äºè¿™ä¸ªå€¼æ—¶ä¼šè½¬æˆçº¢é»‘æ ‘
    static final int TREEIFY_THRESHOLD = 8; 
    // å½“æ¡¶(bucket)ä¸Šçš„ç»“ç‚¹æ•°å°äºè¿™ä¸ªå€¼æ—¶æ ‘è½¬é“¾è¡¨
    static final int UNTREEIFY_THRESHOLD = 6;
    // æ¡¶ä¸­ç»“æ„è½¬åŒ–ä¸ºçº¢é»‘æ ‘å¯¹åº”çš„tableçš„æœ€å°å¤§å°
    static final int MIN_TREEIFY_CAPACITY = 64;
    // å­˜å‚¨å…ƒç´ çš„æ•°ç»„ï¼Œæ€»æ˜¯2çš„å¹‚æ¬¡å€, ç”¨æ¥åˆå§‹åŒ–
    transient Node<k,v>[] table; 
    // å­˜æ”¾å…·ä½“å…ƒç´ çš„é›†ï¼Œç”¨æ¥å­˜æ”¾ç¼“å­˜
    transient Set<map.entry<k,v>> entrySet;
    // å­˜æ”¾å…ƒç´ çš„ä¸ªæ•°ï¼Œæ³¨æ„è¿™ä¸ªä¸ç­‰äºæ•°ç»„çš„é•¿åº¦ã€‚ 
    transient int size;
    // æ¯æ¬¡æ‰©å®¹å’Œæ›´æ”¹mapç»“æ„çš„è®¡æ•°å™¨ï¼ˆè®°å½•HashMapçš„ä¿®æ”¹æ¬¡æ•°ï¼‰
    transient int modCount;   	
    // ä¸´ç•Œå€¼ å½“å­˜æ”¾å…ƒç´ çš„ä¸ªæ•°è¶…è¿‡ä¸´ç•Œå€¼æ—¶ï¼Œä¼šè¿›è¡Œæ‰©å®¹
    int threshold;
    // åŠ è½½å› å­
    final float loadFactor;
```

ğŸ‘‰ `HashMap ` çš„**åˆå§‹å®¹é‡** `DEFAULT_INITIAL_CAPACITY` ä¸º16ï¼Œå¦‚æœéœ€è¦æ‰©å±•æ•°ç»„ï¼Œé‚£ä¹ˆè§„å®šæ˜¯ 2 çš„æ¬¡æ–¹ï¼ˆ`<<1`ï¼‰ã€‚ä¾‹å¦‚ 16 ä¼šæ‰©å……åˆ° 32â€“>64â€“>128â€“>256â€“>512 â€¦

è¿™æ ·æ‰©å……æœ‰ä¸¤ä¸ªåŸå› ï¼š

- é€‰æ‹©è¶³å¤Ÿå¤§çš„æ•°ç»„ï¼Œè®©é”®å€¼å¯¹æ›´å¹³å‡çš„åˆ†å¸ƒåœ¨å„ä¸ªç´¢å¼•ä½ï¼Œå°½é‡å‡å°‘é“¾è¡¨é•¿åº¦ã€‚
- å½“ä½¿ç”¨é™¤ç•™ä½™æ•°æ³•æ—¶ï¼Œèƒ½ä½¿ç”¨ä½è¿ç®—ä»£æ›¿å–æ¨¡è¿ç®—ï¼Œå¾ˆå¤§ç¨‹åº¦ä¸Šæé«˜æ•ˆç‡ï¼ˆæ®è¯´æ˜¯5~8å€ï¼‰ã€‚
  $k \% p$ ç­‰ä»·äº $k \& (p - 1)$ã€‚

ğŸ‘‰ **`loadFactor `åŠ è½½å› å­**ï¼šæ§åˆ¶æ•°ç»„å­˜æ”¾æ•°æ®çš„ç–å¯†ç¨‹åº¦ï¼Œ`loadFactor `è¶Šè¶‹è¿‘äº1ï¼Œé‚£ä¹ˆæ•°ç»„ä¸­å­˜æ”¾çš„æ•°æ®(`entry`)ä¹Ÿå°±è¶Šå¤šï¼Œä¹Ÿå°±è¶Šå¯†ï¼Œä¹Ÿå°±æ˜¯ä¼šè®©é“¾è¡¨çš„é•¿åº¦å¢åŠ ï¼Œ`loadFactor `è¶Šå°ï¼Œä¹Ÿå°±æ˜¯è¶‹è¿‘äº0ï¼Œæ•°ç»„ä¸­å­˜æ”¾çš„æ•°æ®(`entry`)ä¹Ÿå°±è¶Šå°‘ï¼Œä¹Ÿå°±è¶Šç¨€ç–ã€‚

`loadFactor `å¤ªå¤§å¯¼è‡´æŸ¥æ‰¾å…ƒç´ æ•ˆç‡ä½ï¼Œå¤ªå°å¯¼è‡´æ•°ç»„çš„åˆ©ç”¨ç‡ä½ï¼Œå­˜æ”¾çš„æ•°æ®ä¼šå¾ˆåˆ†æ•£ã€‚`loadFactor` çš„é»˜è®¤å€¼ä¸º 0.75f æ˜¯å®˜æ–¹ç»™å‡ºçš„ä¸€ä¸ªæ¯”è¾ƒå¥½çš„ä¸´ç•Œå€¼ã€‚

ç»™å®šçš„é»˜è®¤å®¹é‡ä¸º 16ï¼Œè´Ÿè½½å› å­ä¸º 0.75ã€‚Map åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ä¸æ–­çš„å¾€é‡Œé¢å­˜æ”¾æ•°æ®ï¼Œ**å½“æ•°é‡è¾¾åˆ°äº† 16 * 0.75 = 12 å°±éœ€è¦å°†å½“å‰ 16 çš„å®¹é‡è¿›è¡Œæ‰©å®¹**ï¼Œè€Œæ‰©å®¹è¿™ä¸ªè¿‡ç¨‹æ¶‰åŠåˆ° rehashã€å¤åˆ¶æ•°æ®ç­‰æ“ä½œï¼Œæ‰€ä»¥éå¸¸æ¶ˆè€—æ€§èƒ½ã€‚

ğŸ‘‰ **`threshold `ä¸´ç•Œå€¼**ï¼š`threshold = capacity * loadFactor`ï¼Œå½“ `å®é™…å­˜æ”¾å…ƒç´ çš„ä¸ªæ•° size >= threshold` çš„æ—¶å€™ï¼Œé‚£ä¹ˆå°±è¦è€ƒè™‘å¯¹æ•°ç»„çš„æ‰©å¢äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªçš„æ„æ€å°±æ˜¯è¡¡é‡æ•°ç»„æ˜¯å¦éœ€è¦æ‰©å¢çš„ä¸€ä¸ªæ ‡å‡†ã€‚

ğŸ‘‰ ä¸Šé¢è¯´è¿‡æ‹‰é“¾æ³•çš„æ•£åˆ—è¡¨æ˜¯é€šè¿‡é“¾è¡¨è§£å†³ç¢°æ’é—®é¢˜çš„ï¼Œæ‰€ä»¥ `HashMap` çš„å†…éƒ¨æ•°ç»„æ˜¯èŠ‚ç‚¹ç±»å‹ï¼š

```java
	// ç»§æ‰¿è‡ª Map.Entry<K,V>
	static class Node<K,V> implements Map.Entry<K,V> {
       final int hash;// å“ˆå¸Œå€¼ï¼Œå­˜æ”¾å…ƒç´ åˆ°hashmapä¸­æ—¶ç”¨æ¥ä¸å…¶ä»–å…ƒç´ hashå€¼æ¯”è¾ƒ
       final K key;//é”®
       V value;//å€¼
       // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
       Node<K,V> next;
       Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }
        // é‡å†™hashCode()æ–¹æ³•
        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }
        // é‡å†™ equals() æ–¹æ³•
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
	}
```

ğŸ‘‰ `TreeNode `æ˜¯ `Node` çš„å­ç±»ï¼Œç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š`Node `æ˜¯å•å‘é“¾è¡¨èŠ‚ç‚¹ï¼Œ`Entry `æ˜¯åŒå‘é“¾è¡¨èŠ‚ç‚¹ï¼Œ`TreeNode`æ˜¯çº¢é»‘æ ‘èŠ‚ç‚¹ã€‚

```java
java.util.HashMap<K, V>.Node<K, V>
    java.util.LinkedMap<K, V>.Entry<K, V>
        java.util.HashMap<K, V>.TreeNode<K, V>
```

`TreeNode `çš„ä»£ç  400 å¤šè¡Œï¼Œæ˜¯å®ç°çº¢é»‘æ ‘çš„èŠ‚ç‚¹ï¼Œå…³äºçº¢é»‘æ ‘ï¼Œè¿™é‡Œæš‚æ—¶ä¸åšè§£é‡Š

```java
	static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // çˆ¶
        TreeNode<K,V> left;    // å·¦
        TreeNode<K,V> right;   // å³
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;           // åˆ¤æ–­é¢œè‰²
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
        // è¿”å›æ ¹èŠ‚ç‚¹
        final TreeNode<K,V> root() {
            for (TreeNode<K,V> r = this, p;;) {
                if ((p = r.parent) == null)
                    return r;
                r = p;
       }
       
       // .......
```

## 2. æ„é€ å‡½æ•°

`HashMap `ä¸­æœ‰å››ä¸ªæ„é€ æ–¹æ³•ï¼Œå®ƒä»¬åˆ†åˆ«å¦‚ä¸‹ï¼š

```java
    // é»˜è®¤æ„é€ å‡½æ•°ã€‚
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted
     }

     // åŒ…å«å¦ä¸€ä¸ªâ€œMapâ€çš„æ„é€ å‡½æ•°
     public HashMap(Map<? extends K, ? extends V> m) {
         this.loadFactor = DEFAULT_LOAD_FACTOR;
         putMapEntries(m, false);//ä¸‹é¢ä¼šåˆ†æåˆ°è¿™ä¸ªæ–¹æ³•
     }

     // æŒ‡å®šâ€œå®¹é‡å¤§å°â€çš„æ„é€ å‡½æ•°
     public HashMap(int initialCapacity) {
         this(initialCapacity, DEFAULT_LOAD_FACTOR);
     }

     // æŒ‡å®šâ€œå®¹é‡å¤§å°â€å’Œâ€œåŠ è½½å› å­â€çš„æ„é€ å‡½æ•°
     public HashMap(int initialCapacity, float loadFactor) {
         if (initialCapacity < 0)
             throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
         if (initialCapacity > MAXIMUM_CAPACITY)
             initialCapacity = MAXIMUM_CAPACITY;
         if (loadFactor <= 0 || Float.isNaN(loadFactor))
             throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
         this.loadFactor = loadFactor;
         this.threshold = tableSizeFor(initialCapacity);
     }
```

`putMapEntries` æ–¹æ³•ï¼š

```java
final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
    int s = m.size();
    if (s > 0) {
        // åˆ¤æ–­tableæ˜¯å¦å·²ç»åˆå§‹åŒ–
        if (table == null) { // pre-size
            // æœªåˆå§‹åŒ–ï¼Œsä¸ºmçš„å®é™…å…ƒç´ ä¸ªæ•°
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft < (float)MAXIMUM_CAPACITY) ?
                    (int)ft : MAXIMUM_CAPACITY);
            // è®¡ç®—å¾—åˆ°çš„tå¤§äºé˜ˆå€¼ï¼Œåˆ™åˆå§‹åŒ–é˜ˆå€¼
            if (t > threshold)
                threshold = tableSizeFor(t);
        }
        // å·²åˆå§‹åŒ–ï¼Œå¹¶ä¸” m å…ƒç´ ä¸ªæ•°å¤§äºé˜ˆå€¼ï¼Œè¿›è¡Œæ‰©å®¹å¤„ç†
        else if (s > threshold)
            resize();
        // å°† m ä¸­çš„æ‰€æœ‰å…ƒç´ æ·»åŠ è‡³ HashMap ä¸­
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}
```

## 3. put æ–¹æ³•

`HashMap `åªæä¾›äº† `put `ç”¨äºæ·»åŠ å…ƒç´ ï¼Œ`putVal `æ–¹æ³•åªæ˜¯ç»™ put æ–¹æ³•è°ƒç”¨çš„ä¸€ä¸ªæ–¹æ³•ï¼Œå¹¶æ²¡æœ‰æä¾›ç»™ç”¨æˆ·ä½¿ç”¨ã€‚

**å¯¹`putVal`æ–¹æ³•æ·»åŠ å…ƒç´ çš„åˆ†æå¦‚ä¸‹ï¼š**

- â‘  å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æ²¡æœ‰å…ƒç´  å°±ç›´æ¥æ’å…¥ã€‚
- â‘¡ å¦‚æœå®šä½åˆ°çš„æ•°ç»„ä½ç½®æœ‰å…ƒç´ å°±å’Œè¦æ’å…¥çš„ key æ¯”è¾ƒï¼Œå¦‚æœ key ç›¸åŒå°±ç›´æ¥è¦†ç›–ï¼Œå¦‚æœ key ä¸ç›¸åŒï¼Œå°±åˆ¤æ–­ p æ˜¯å¦æ˜¯ä¸€ä¸ªæ ‘èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯å°±è°ƒç”¨`e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value)`å°†å…ƒç´ æ·»åŠ è¿›å…¥ã€‚å¦‚æœä¸æ˜¯å°±éå†é“¾è¡¨æ’å…¥(æ’å…¥çš„æ˜¯é“¾è¡¨å°¾éƒ¨)ã€‚

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // tableæœªåˆå§‹åŒ–æˆ–è€…é•¿åº¦ä¸º0ï¼Œè¿›è¡Œæ‰©å®¹
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) & hash ç¡®å®šå…ƒç´ å­˜æ”¾åœ¨å“ªä¸ªæ¡¶ä¸­ï¼Œæ¡¶ä¸ºç©ºï¼Œæ–°ç”Ÿæˆç»“ç‚¹æ”¾å…¥æ¡¶ä¸­(æ­¤æ—¶ï¼Œè¿™ä¸ªç»“ç‚¹æ˜¯æ”¾åœ¨æ•°ç»„ä¸­)
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // æ¡¶ä¸­å·²ç»å­˜åœ¨å…ƒç´ 
    else {
        Node<K,V> e; K k;
        // æ¯”è¾ƒæ¡¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ (æ•°ç»„ä¸­çš„ç»“ç‚¹)çš„hashå€¼ç›¸ç­‰ï¼Œkeyç›¸ç­‰
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
                // å°†ç¬¬ä¸€ä¸ªå…ƒç´ èµ‹å€¼ç»™eï¼Œç”¨eæ¥è®°å½•
                e = p;
        // hashå€¼ä¸ç›¸ç­‰ï¼Œå³keyä¸ç›¸ç­‰ï¼›ä¸ºçº¢é»‘æ ‘ç»“ç‚¹
        else if (p instanceof TreeNode)
            // æ”¾å…¥æ ‘ä¸­
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // ä¸ºé“¾è¡¨ç»“ç‚¹
        else {
            // åœ¨é“¾è¡¨æœ€æœ«æ’å…¥ç»“ç‚¹
            for (int binCount = 0; ; ++binCount) {
                // åˆ°è¾¾é“¾è¡¨çš„å°¾éƒ¨
                if ((e = p.next) == null) {
                    // åœ¨å°¾éƒ¨æ’å…¥æ–°ç»“ç‚¹
                    p.next = newNode(hash, key, value, null);
                    // ç»“ç‚¹æ•°é‡è¾¾åˆ°é˜ˆå€¼ï¼Œè½¬åŒ–ä¸ºçº¢é»‘æ ‘
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    // è·³å‡ºå¾ªç¯
                    break;
                }
                // åˆ¤æ–­é“¾è¡¨ä¸­ç»“ç‚¹çš„keyå€¼ä¸æ’å…¥çš„å…ƒç´ çš„keyå€¼æ˜¯å¦ç›¸ç­‰
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // ç›¸ç­‰ï¼Œè·³å‡ºå¾ªç¯
                    break;
                // ç”¨äºéå†æ¡¶ä¸­çš„é“¾è¡¨ï¼Œä¸å‰é¢çš„e = p.nextç»„åˆï¼Œå¯ä»¥éå†é“¾è¡¨
                p = e;
            }
        }
        // è¡¨ç¤ºåœ¨æ¡¶ä¸­æ‰¾åˆ°keyå€¼ã€hashå€¼ä¸æ’å…¥å…ƒç´ ç›¸ç­‰çš„ç»“ç‚¹
        if (e != null) { 
            // è®°å½•eçš„value
            V oldValue = e.value;
            // onlyIfAbsentä¸ºfalseæˆ–è€…æ—§å€¼ä¸ºnull
            if (!onlyIfAbsent || oldValue == null)
                //ç”¨æ–°å€¼æ›¿æ¢æ—§å€¼
                e.value = value;
            // è®¿é—®åå›è°ƒ
            afterNodeAccess(e);
            // è¿”å›æ—§å€¼
            return oldValue;
        }
    }
    // ç»“æ„æ€§ä¿®æ”¹
    ++modCount;
    // å®é™…å¤§å°å¤§äºé˜ˆå€¼åˆ™æ‰©å®¹
    if (++size > threshold)
        resize();
    // æ’å…¥åå›è°ƒ
    afterNodeInsertion(evict);
    return null;
} 
```

## 4. get æ–¹æ³•

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // æ•°ç»„å…ƒç´ ç›¸ç­‰
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // æ¡¶ä¸­ä¸æ­¢ä¸€ä¸ªèŠ‚ç‚¹
        if ((e = first.next) != null) {
            // åœ¨æ ‘ä¸­get
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // åœ¨é“¾è¡¨ä¸­get
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

## 5. resize æ–¹æ³•

è¿›è¡Œæ‰©å®¹ï¼Œä¼šä¼´éšç€ä¸€æ¬¡é‡æ–°`hash`åˆ†é…ï¼Œå¹¶ä¸”ä¼šéå†`hash`è¡¨ä¸­æ‰€æœ‰çš„å…ƒç´ ï¼Œæ˜¯éå¸¸è€—æ—¶çš„ã€‚åœ¨ç¼–å†™ç¨‹åºä¸­ï¼Œè¦å°½é‡é¿å…`resize`ã€‚

```java
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        // è¶…è¿‡æœ€å¤§å€¼å°±ä¸å†æ‰©å……äº†ï¼Œå°±åªå¥½éšä½ ç¢°æ’å»å§
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // æ²¡è¶…è¿‡æœ€å¤§å€¼ï¼Œå°±æ‰©å……ä¸ºåŸæ¥çš„2å€
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else { 
        // signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // è®¡ç®—æ–°çš„resizeä¸Šé™
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // æŠŠæ¯ä¸ªbucketéƒ½ç§»åŠ¨åˆ°æ–°çš„bucketsä¸­
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { 
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        // åŸç´¢å¼•
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // åŸç´¢å¼•+oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // åŸç´¢å¼•æ”¾åˆ°bucketé‡Œ
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // åŸç´¢å¼•+oldCapæ”¾åˆ°bucketé‡Œ
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

## ğŸ“š References

- ã€ŠJava æ ¸å¿ƒæŠ€æœ¯ - å· 1 åŸºç¡€çŸ¥è¯† - ç¬¬ 10 ç‰ˆã€‹

- [HashMap å®ç°åŸç†å’Œæºç åˆ†æ](https://blog.csdn.net/u010386612/article/details/80302777)

- [CS-Notes â€” Github](http://cyc2018.gitee.io/cs-notes/#/notes/Java%20%E5%AE%B9%E5%99%A8?id=_1-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84)

- [JavaGuide â€” Github](https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap)