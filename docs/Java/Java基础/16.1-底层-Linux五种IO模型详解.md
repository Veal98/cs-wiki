# ğŸ’« Linux äº”ç§ I/O æ¨¡å‹è¯¦è§£

---

## 1. æ¦‚è¿°

ä¸€ä¸ªè¾“å…¥æ“ä½œé€šå¸¸åŒ…æ‹¬ä¸¤ä¸ªé˜¶æ®µï¼š

- ç¬¬ä¸€é˜¶æ®µï¼šå†…æ ¸ç­‰å¾…æ•°æ®å‡†å¤‡å¥½ï¼ˆæ•°æ®è¢«æ‹·è´åˆ°æ“ä½œç³»ç»Ÿå†…æ ¸çš„ç¼“å†²åŒºï¼‰
- ç¬¬äºŒé˜¶æ®µï¼šå†…æ ¸å‘è¿›ç¨‹å¤åˆ¶æ•°æ®

å¯¹äºä¸€ä¸ªå¥—æ¥å­—ä¸Šçš„è¾“å…¥æ“ä½œï¼Œç¬¬ä¸€æ­¥é€šå¸¸æ¶‰åŠç­‰å¾…æ•°æ®ä»ç½‘ç»œä¸­åˆ°è¾¾ã€‚å½“æ‰€ç­‰å¾…æ•°æ®åˆ°è¾¾æ—¶ï¼Œå®ƒè¢«å¤åˆ¶åˆ°å†…æ ¸ä¸­çš„æŸä¸ªç¼“å†²åŒºã€‚ç¬¬äºŒæ­¥å°±æ˜¯æŠŠæ•°æ®ä»å†…æ ¸ç¼“å†²åŒºå¤åˆ¶åˆ°åº”ç”¨è¿›ç¨‹ç¼“å†²åŒºã€‚

> ğŸ’¡ å…³äº**å¥—æ¥å­— Socket** å¯å‚è€ƒè¿™ç¯‡æ–‡ç«  [ Java ç½‘ç»œç¼–ç¨‹ â€” Socket ç¼–ç¨‹](https://veal98.gitee.io/cs-wiki/#/Java/Java%E5%9F%BA%E7%A1%80/17-Socket%E7%BC%96%E7%A8%8B)

Unix æœ‰äº”ç§ I/O æ¨¡å‹ï¼š

- **é˜»å¡å¼ I/O**
- **éé˜»å¡å¼ I/O**
- **I/O å¤ç”¨ï¼ˆselect å’Œ pollï¼‰**
- **ä¿¡å·é©±åŠ¨å¼ I/Oï¼ˆSIGIOï¼‰**
- **å¼‚æ­¥ I/Oï¼ˆAIOï¼‰**

## 2. é˜»å¡å¼ I/Oï¼ˆBlocking I/Oï¼‰

åœ¨ Linux ä¸­ï¼Œé»˜è®¤æƒ…å†µä¸‹æ‰€æœ‰çš„ Socket éƒ½æ˜¯é˜»å¡å¼ Blocking çš„ã€‚**åº”ç”¨è¿›ç¨‹è¢«é˜»å¡ï¼Œç›´åˆ°æ•°æ®ä»å†…æ ¸ç¼“å†²åŒºå¤åˆ¶åˆ°åº”ç”¨è¿›ç¨‹ç¼“å†²åŒºä¸­æ‰è¿”å›**ã€‚

åº”è¯¥æ³¨æ„åˆ°ï¼Œåœ¨é˜»å¡çš„è¿‡ç¨‹ä¸­ï¼Œ**å…¶å®ƒåº”ç”¨è¿›ç¨‹è¿˜å¯ä»¥æ‰§è¡Œï¼Œå› æ­¤é˜»å¡ä¸æ„å‘³ç€æ•´ä¸ªæ“ä½œç³»ç»Ÿéƒ½è¢«é˜»å¡**ã€‚å› ä¸ºå…¶å®ƒåº”ç”¨è¿›ç¨‹è¿˜å¯ä»¥æ‰§è¡Œï¼Œæ‰€ä»¥ä¸æ¶ˆè€— CPU æ—¶é—´ï¼Œè¿™ç§æ¨¡å‹çš„ CPU åˆ©ç”¨ç‡ä¼šæ¯”è¾ƒé«˜ã€‚

ä¸‹å›¾ä¸­ï¼Œ`recvfrom()` ç”¨äºæ¥æ”¶ Socket ä¼ æ¥çš„æ•°æ®ï¼Œå¹¶å¤åˆ¶åˆ°åº”ç”¨è¿›ç¨‹çš„ç¼“å†²åŒº buf ä¸­ã€‚è¿™é‡ŒæŠŠ `recvfrom()` å½“æˆç³»ç»Ÿè°ƒç”¨ã€‚

```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

![](https://gitee.com/veal98/images/raw/master/img/20201210201426.png)

å½“ç”¨æˆ·è¿›ç¨‹è°ƒç”¨äº† `recvfrom` è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œå†…æ ¸ kernel å°±å¼€å§‹äº† IO çš„ç¬¬ä¸€ä¸ªé˜¶æ®µï¼šå‡†å¤‡æ•°æ®ï¼ˆå¯¹äºç½‘ç»œ IO æ¥è¯´ï¼Œå¾ˆå¤šæ—¶å€™æ•°æ®åœ¨ä¸€å¼€å§‹è¿˜æ²¡æœ‰åˆ°è¾¾ã€‚æ¯”å¦‚ï¼Œè¿˜æ²¡æœ‰æ”¶åˆ°ä¸€ä¸ªå®Œæ•´çš„ UDP åŒ…ã€‚è¿™ä¸ªæ—¶å€™å†…æ ¸å°±è¦ç­‰å¾…è¶³å¤Ÿçš„æ•°æ®åˆ°æ¥ï¼‰ã€‚è¿™ä¸ªè¿‡ç¨‹éœ€è¦ç­‰å¾…ï¼Œä¹Ÿå°±æ˜¯è¯´**æ•°æ®è¢«æ‹·è´åˆ°æ“ä½œç³»ç»Ÿå†…æ ¸çš„ç¼“å†²åŒºä¸­æ˜¯éœ€è¦ä¸€ä¸ªè¿‡ç¨‹çš„**ã€‚è€Œ<u>åœ¨ç”¨æˆ·è¿›ç¨‹è¿™è¾¹ï¼Œæ•´ä¸ªè¿›ç¨‹ä¼šè¢«é˜»å¡ï¼ˆå½“ç„¶ï¼Œæ˜¯è¿›ç¨‹è‡ªå·±é€‰æ‹©çš„é˜»å¡ï¼‰ã€‚å½“ kernel ä¸€ç›´ç­‰åˆ°æ•°æ®å‡†å¤‡å¥½äº†ï¼Œå®ƒå°±ä¼šå°†æ•°æ®ä» kernel ä¸­æ‹·è´åˆ°ç”¨æˆ·å†…å­˜ï¼Œç„¶å kernel è¿”å›ç»“æœï¼Œç”¨æˆ·è¿›ç¨‹æ‰è§£é™¤é˜»å¡çš„çŠ¶æ€ï¼Œé‡æ–°è¿è¡Œèµ·æ¥</u>ã€‚

ğŸ’¡ æ‰€ä»¥ï¼Œ**Blocking IO çš„ç‰¹ç‚¹å°±æ˜¯åœ¨ IO æ‰§è¡Œçš„ä¸¤ä¸ªé˜¶æ®µéƒ½è¢«é˜»å¡äº†**ã€‚

## 3. éé˜»å¡å¼ I/Oï¼ˆNon-Blocking I/Oï¼‰

**åº”ç”¨è¿›ç¨‹æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ä¹‹åï¼Œå†…æ ¸è¿”å›ä¸€ä¸ªé”™è¯¯ç ã€‚åº”ç”¨è¿›ç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œï¼Œä½†æ˜¯éœ€è¦ä¸æ–­çš„æ‰§è¡Œç³»ç»Ÿè°ƒç”¨æ¥è·çŸ¥ I/O æ˜¯å¦å®Œæˆï¼Œè¿™ç§æ–¹å¼ç§°ä¸ºè½®è¯¢ï¼ˆpollingï¼‰**ã€‚

ç”±äº CPU è¦å¤„ç†æ›´å¤šçš„ç³»ç»Ÿè°ƒç”¨ï¼Œå› æ­¤è¿™ç§æ¨¡å‹çš„ CPU åˆ©ç”¨ç‡æ¯”è¾ƒä½ã€‚

![](https://gitee.com/veal98/images/raw/master/img/20201210201519.png)

å½“ç”¨æˆ·è¿›ç¨‹å‘å‡º `read` æ“ä½œæ—¶ï¼Œå¦‚æœ kernel ä¸­çš„æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼Œé‚£ä¹ˆå®ƒå¹¶ä¸ä¼š block ç”¨æˆ·è¿›ç¨‹ï¼Œè€Œæ˜¯ç«‹åˆ»è¿”å›ä¸€ä¸ªé”™è¯¯ç ã€‚ä»ç”¨æˆ·è¿›ç¨‹è§’åº¦è®² ï¼Œå®ƒå‘èµ·ä¸€ä¸ª `read` æ“ä½œåï¼Œå¹¶ä¸éœ€è¦ç­‰å¾…ï¼Œè€Œæ˜¯é©¬ä¸Šå°±å¾—åˆ°äº†ä¸€ä¸ªç»“æœã€‚ç”¨æˆ·è¿›ç¨‹åˆ¤æ–­ç»“æœæ˜¯ä¸€ä¸ªé”™è¯¯ç æ—¶ï¼Œå®ƒå°±çŸ¥é“æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼Œäºæ˜¯å®ƒå¯ä»¥å†æ¬¡å‘é€ `read` æ“ä½œã€‚ä¸€æ—¦ kernel ä¸­çš„æ•°æ®å‡†å¤‡å¥½äº†ï¼Œå¹¶ä¸”åˆå†æ¬¡æ”¶åˆ°äº†ç”¨æˆ·è¿›ç¨‹çš„ `system call`ï¼Œé‚£ä¹ˆå®ƒé©¬ä¸Šå°±å°†æ•°æ®æ‹·è´åˆ°äº†ç”¨æˆ·å†…å­˜ï¼Œç„¶åè¿”å›ã€‚

ğŸ’¡ æ‰€ä»¥ï¼Œ**Non-Blocking IO çš„ç‰¹ç‚¹æ˜¯ç”¨æˆ·è¿›ç¨‹éœ€è¦ä¸æ–­çš„ä¸»åŠ¨è¯¢é—® kernel æ•°æ®å‡†å¤‡å¥½äº†æ²¡æœ‰**ã€‚

## 4. I/O å¤ç”¨ï¼ˆ IO Multiplexingï¼‰

### â‘  æ¦‚è¿°

IO å¤šè·¯å¤ç”¨ / IO å¤ç”¨å°±æ˜¯æˆ‘ä»¬è¯´çš„ `select`ï¼Œ`poll`ï¼Œ`epoll`ï¼Œ`select / poll / epoll`  çš„å¥½å¤„å°±åœ¨äºå®ƒå¯ä»¥**è®©å•ä¸ªè¿›ç¨‹å…·æœ‰å¤„ç†å¤šä¸ª I/O äº‹ä»¶çš„èƒ½åŠ›**ã€‚åˆè¢«ç§°ä¸º**äº‹ä»¶é©±åŠ¨ I/Oï¼ˆEvent Driven I/Oï¼‰**ã€‚åŸºæœ¬åŸç†å°±æ˜¯ `select / poll / epoll` è¿™ä¸ªå‡½æ•°/å‘½ä»¤ä¼šä¸æ–­çš„è½®è¯¢æ‰€è´Ÿè´£çš„æ‰€æœ‰ Socketï¼Œå½“æŸä¸ª Socket æœ‰æ•°æ®åˆ°è¾¾äº†ï¼Œå°±é€šçŸ¥ç”¨æˆ·è¿›ç¨‹ã€‚

![](https://gitee.com/veal98/images/raw/master/img/20201210201723.png)

å½“ç”¨æˆ·è¿›ç¨‹è°ƒç”¨äº† `select`ï¼Œé‚£ä¹ˆæ•´ä¸ªè¿›ç¨‹ä¼šè¢« blockï¼Œè€ŒåŒæ—¶ï¼Œkernel ä¼šâ€œç›‘è§†â€æ‰€æœ‰ `select` è´Ÿè´£çš„ Socketï¼Œå½“ä»»ä½•ä¸€ä¸ª Socket ä¸­çš„æ•°æ®å‡†å¤‡å¥½äº†ï¼Œ`select ` å°±ä¼šè¿”å›ã€‚è¿™ä¸ªæ—¶å€™ç”¨æˆ·è¿›ç¨‹å†è°ƒç”¨ `read` æ“ä½œï¼Œå°†æ•°æ®ä» kernelæ‹·è´åˆ°ç”¨æˆ·è¿›ç¨‹ã€‚

ğŸ’¡ æ‰€ä»¥ï¼Œ**I/O å¤šè·¯å¤ç”¨çš„ç‰¹ç‚¹æ˜¯é€šè¿‡ä¸€ç§æœºåˆ¶ä¸€ä¸ªè¿›ç¨‹èƒ½åŒæ—¶ç­‰å¾…å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œè€Œè¿™äº›æ–‡ä»¶æè¿°ç¬¦ï¼ˆå¥—æ¥å­—æè¿°ç¬¦ï¼‰å…¶ä¸­çš„ä»»æ„ä¸€ä¸ªè¿›å…¥è¯»å°±ç»ªçŠ¶æ€ï¼Œ`select()` å‡½æ•°å°±å¯ä»¥è¿”å›ã€‚**

å¦‚æœä¸€ä¸ª Web æœåŠ¡å™¨æ²¡æœ‰ I/O å¤ç”¨ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ª Socket è¿æ¥éƒ½éœ€è¦åˆ›å»ºä¸€ä¸ªçº¿ç¨‹å»å¤„ç†ã€‚å¦‚æœåŒæ—¶æœ‰å‡ ä¸‡ä¸ªè¿æ¥ï¼Œé‚£ä¹ˆå°±éœ€è¦åˆ›å»ºç›¸åŒæ•°é‡çš„çº¿ç¨‹ã€‚ç›¸æ¯”äºå¤šè¿›ç¨‹å’Œå¤šçº¿ç¨‹æŠ€æœ¯ï¼ŒI/O å¤ç”¨ä¸éœ€è¦è¿›ç¨‹çº¿ç¨‹åˆ›å»ºå’Œåˆ‡æ¢çš„å¼€é”€ï¼Œç³»ç»Ÿå¼€é”€æ›´å°ã€‚

`select/poll/epoll` éƒ½æ˜¯ I/O å¤šè·¯å¤ç”¨çš„å…·ä½“å®ç°ï¼Œ`select `å‡ºç°çš„æœ€æ—©ï¼Œä¹‹åæ˜¯ `poll`ï¼Œå†æ˜¯ `epoll`ã€‚ä¸‹é¢æˆ‘ä»¬è¯¦ç»†è®²è§£è¿™äº›å‘½ä»¤/å‡½æ•° ğŸ‘‡

### â‘¡ select

```c
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

**`select` å…è®¸åº”ç”¨ç¨‹åºç›‘è§†ä¸€ç»„æ–‡ä»¶æè¿°ç¬¦ï¼Œç­‰å¾…ä¸€ä¸ªæˆ–è€…å¤šä¸ªæè¿°ç¬¦æˆä¸ºå°±ç»ªçŠ¶æ€ï¼Œä»è€Œå®Œæˆ I/O æ“ä½œ**ã€‚

- `fd_set` ä½¿ç”¨æ•°ç»„å®ç°ï¼Œæ•°ç»„å¤§å°ä½¿ç”¨ `FD_SETSIZE `å®šä¹‰ï¼Œæ‰€ä»¥åªèƒ½ç›‘å¬å°‘äº `FD_SETSIZE` æ•°é‡çš„æè¿°ç¬¦ã€‚æœ‰ä¸‰ç§ç±»å‹çš„æè¿°ç¬¦ç±»å‹ï¼š`readset`ã€`writeset`ã€`exceptset`ï¼Œåˆ†åˆ«å¯¹åº”è¯»ã€å†™ã€å¼‚å¸¸æ¡ä»¶çš„æè¿°ç¬¦é›†åˆã€‚
- `timeout `ä¸ºè¶…æ—¶å‚æ•°ï¼Œè°ƒç”¨ `select `ä¼šä¸€ç›´é˜»å¡ç›´åˆ°æœ‰æè¿°ç¬¦çš„äº‹ä»¶åˆ°è¾¾æˆ–è€…ç­‰å¾…çš„æ—¶é—´è¶…è¿‡ `timeout`ã€‚
- æˆåŠŸè°ƒç”¨è¿”å›ç»“æœå¤§äº 0ï¼Œå‡ºé”™è¿”å›ç»“æœä¸º -1ï¼Œè¶…æ—¶è¿”å›ç»“æœä¸º 0ã€‚

```c
fd_set fd_in, fd_out;
struct timeval tv;

// Reset the sets
FD_ZERO( &fd_in );
FD_ZERO( &fd_out );

// Monitor sock1 for input events
FD_SET( sock1, &fd_in );

// Monitor sock2 for output events
FD_SET( sock2, &fd_out );

// Find out which socket has the largest numeric value as select requires it
int largest_sock = sock1 > sock2 ? sock1 : sock2;

// Wait up to 10 seconds
tv.tv_sec = 10;
tv.tv_usec = 0;

// Call the select
int ret = select( largest_sock + 1, &fd_in, &fd_out, NULL, &tv );

// Check if select actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    if ( FD_ISSET( sock1, &fd_in ) )
        // input event on sock1

    if ( FD_ISSET( sock2, &fd_out ) )
        // output event on sock2
}
```

### â‘¢ poll

```c
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```

`poll `çš„åŠŸèƒ½ä¸ `select `ç±»ä¼¼ï¼Œä¹Ÿæ˜¯ç­‰å¾…ä¸€ç»„æè¿°ç¬¦ä¸­çš„ä¸€ä¸ªæˆä¸ºå°±ç»ªçŠ¶æ€ã€‚

`poll `ä¸­çš„æè¿°ç¬¦æ˜¯ `pollfd `ç±»å‹çš„æ•°ç»„ï¼Œ`pollfd `çš„å®šä¹‰å¦‚ä¸‹ï¼š

```c
struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };
// The structure for two events
struct pollfd fds[2];

// Monitor sock1 for input
fds[0].fd = sock1;
fds[0].events = POLLIN;

// Monitor sock2 for output
fds[1].fd = sock2;
fds[1].events = POLLOUT;

// Wait 10 seconds
int ret = poll( &fds, 2, 10000 );
// Check if poll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // If we detect the event, zero it out so we can reuse the structure
    if ( fds[0].revents & POLLIN )
        fds[0].revents = 0;
        // input event on sock1

    if ( fds[1].revents & POLLOUT )
        fds[1].revents = 0;
        // output event on sock2
}
```

### â‘£ select å’Œ poll çš„æ¯”è¾ƒ

- **åŠŸèƒ½**

  `select` å’Œ `poll `çš„åŠŸèƒ½åŸºæœ¬ç›¸åŒï¼Œä¸è¿‡åœ¨ä¸€äº›å®ç°ç»†èŠ‚ä¸Šæœ‰æ‰€ä¸åŒã€‚

  - `select `ä¼šä¿®æ”¹æè¿°ç¬¦ï¼Œè€Œ `poll `ä¸ä¼šï¼›
  - `select `çš„æè¿°ç¬¦ç±»å‹ä½¿ç”¨æ•°ç»„å®ç°ï¼Œ`FD_SETSIZE` å¤§å°é»˜è®¤ä¸º 1024ï¼Œå› æ­¤é»˜è®¤åªèƒ½ç›‘å¬å°‘äº 1024 ä¸ªæè¿°ç¬¦ã€‚å¦‚æœè¦ç›‘å¬æ›´å¤šæè¿°ç¬¦çš„è¯ï¼Œéœ€è¦ä¿®æ”¹ `FD_SETSIZE` ä¹‹åé‡æ–°ç¼–è¯‘ï¼›è€Œ `poll `æ²¡æœ‰æè¿°ç¬¦æ•°é‡çš„é™åˆ¶ï¼›
  - `poll `æä¾›äº†æ›´å¤šçš„äº‹ä»¶ç±»å‹ï¼Œå¹¶ä¸”å¯¹æè¿°ç¬¦çš„é‡å¤åˆ©ç”¨ä¸Šæ¯” `select `é«˜ã€‚
  - å¦‚æœä¸€ä¸ªçº¿ç¨‹å¯¹æŸä¸ªæè¿°ç¬¦è°ƒç”¨äº† `select` æˆ–è€… `poll`ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹å…³é—­äº†è¯¥æè¿°ç¬¦ï¼Œä¼šå¯¼è‡´è°ƒç”¨ç»“æœä¸ç¡®å®šã€‚

- **é€Ÿåº¦**

  `select `å’Œ `poll `é€Ÿåº¦éƒ½æ¯”è¾ƒæ…¢ï¼Œ<u>æ¯æ¬¡è°ƒç”¨éƒ½éœ€è¦å°†å…¨éƒ¨æè¿°ç¬¦ä»åº”ç”¨è¿›ç¨‹ç¼“å†²åŒºå¤åˆ¶åˆ°å†…æ ¸ç¼“å†²åŒº</u>ã€‚

- **å¯ç§»æ¤æ€§**

  å‡ ä¹æ‰€æœ‰çš„ç³»ç»Ÿéƒ½æ”¯æŒ `select`ï¼Œä½†æ˜¯åªæœ‰æ¯”è¾ƒæ–°çš„ç³»ç»Ÿæ”¯æŒ `poll`ã€‚

### â‘¤ epoll

```c
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)ï¼›
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

`epoll_ctl()` ç”¨äºå‘å†…æ ¸æ³¨å†Œæ–°çš„æè¿°ç¬¦æˆ–è€…æ˜¯æ”¹å˜æŸä¸ªæ–‡ä»¶æè¿°ç¬¦çš„çŠ¶æ€ã€‚å·²æ³¨å†Œçš„æè¿°ç¬¦åœ¨å†…æ ¸ä¸­ä¼šè¢«ç»´æŠ¤åœ¨ä¸€æ£µ**çº¢é»‘æ ‘**ä¸Šï¼Œé€šè¿‡å›è°ƒå‡½æ•°å†…æ ¸ä¼šå°† I/O å‡†å¤‡å¥½çš„æè¿°ç¬¦åŠ å…¥åˆ°ä¸€ä¸ª**é“¾è¡¨**ä¸­ç®¡ç†ï¼Œè¿›ç¨‹è°ƒç”¨ `epoll_wait()` ä¾¿å¯ä»¥å¾—åˆ°äº‹ä»¶å®Œæˆçš„æè¿°ç¬¦ã€‚

ä»ä¸Šé¢çš„æè¿°å¯ä»¥çœ‹å‡ºï¼Œ**`epoll `åªéœ€è¦å°†æè¿°ç¬¦ä»è¿›ç¨‹ç¼“å†²åŒºå‘å†…æ ¸ç¼“å†²åŒºæ‹·è´ä¸€æ¬¡ï¼Œå¹¶ä¸”è¿›ç¨‹ä¸éœ€è¦é€šè¿‡è½®è¯¢æ¥è·å¾—äº‹ä»¶å®Œæˆçš„æè¿°ç¬¦**ã€‚

`epoll `ä»…é€‚ç”¨äº Linux OSã€‚

`epoll `æ¯” `select `å’Œ `poll `æ›´åŠ çµæ´»è€Œä¸”æ²¡æœ‰æè¿°ç¬¦æ•°é‡é™åˆ¶ã€‚

`epoll `å¯¹å¤šçº¿ç¨‹ç¼–ç¨‹æ›´æœ‰å‹å¥½ï¼Œä¸€ä¸ªçº¿ç¨‹è°ƒç”¨äº†` epoll_wait()` å¦ä¸€ä¸ªçº¿ç¨‹å…³é—­äº†åŒä¸€ä¸ªæè¿°ç¬¦ä¹Ÿä¸ä¼šäº§ç”Ÿåƒ `select `å’Œ `poll `çš„ä¸ç¡®å®šæƒ…å†µã€‚

```c
// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.
// The function argument is ignored (it was not before, but now it is), so put your favorite number here
int pollingfd = epoll_create( 0xCAFE );

if ( pollingfd < 0 )
 // report error

// Initialize the epoll structure in case more members are added in future
struct epoll_event ev = { 0 };

// Associate the connection class instance with the event. You can associate anything
// you want, epoll does not use this information. We store a connection class pointer, pConnection1
ev.data.ptr = pConnection1;

// Monitor for input, and do not automatically rearm the descriptor after the event
ev.events = EPOLLIN | EPOLLONESHOT;
// Add the descriptor into the monitoring list. We can do it even if another thread is
// waiting in epoll_wait - the descriptor will be properly added
if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1->getSocket(), &ev ) != 0 )
    // report error

// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)
struct epoll_event pevents[ 20 ];

// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array
int ready = epoll_wait( pollingfd, pevents, 20, 10000 );
// Check if epoll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // Check if any events detected
    for ( int i = 0; i < ready; i++ )
    {
        if ( pevents[i].events & EPOLLIN )
        {
            // Get back our connection pointer
            Connection * c = (Connection*) pevents[i].data.ptr;
            c->handleReadEvent();
         }
    }
}
```

#### å·¥ä½œæ¨¡å¼

`epoll` çš„æè¿°ç¬¦äº‹ä»¶æœ‰ä¸¤ç§è§¦å‘æ¨¡å¼ï¼šLTï¼ˆlevel triggerï¼‰å’Œ ETï¼ˆedge triggerï¼‰ã€‚

- **LT æ¨¡å¼**

  <u>å½“ `epoll_wait()` æ£€æµ‹åˆ°æè¿°ç¬¦äº‹ä»¶åˆ°è¾¾æ—¶ï¼Œå°†æ­¤äº‹ä»¶é€šçŸ¥è¿›ç¨‹ï¼Œè¿›ç¨‹å¯ä»¥ä¸ç«‹å³å¤„ç†è¯¥äº‹ä»¶ï¼Œä¸‹æ¬¡è°ƒç”¨ `epoll_wait()` ä¼šå†æ¬¡é€šçŸ¥è¿›ç¨‹</u>ã€‚æ˜¯**é»˜è®¤**çš„ä¸€ç§æ¨¡å¼ï¼Œå¹¶ä¸”åŒæ—¶æ”¯æŒ Blocking å’Œ No-Blockingã€‚

- **ET æ¨¡å¼**

  å’Œ LT æ¨¡å¼ä¸åŒçš„æ˜¯ï¼Œ<u>é€šçŸ¥ä¹‹åè¿›ç¨‹å¿…é¡»ç«‹å³å¤„ç†äº‹ä»¶</u>ï¼Œä¸‹æ¬¡å†è°ƒç”¨ `epoll_wait()` æ—¶ä¸ä¼šå†å¾—åˆ°äº‹ä»¶åˆ°è¾¾çš„é€šçŸ¥ã€‚

  å¾ˆå¤§ç¨‹åº¦ä¸Šå‡å°‘äº† `epoll `äº‹ä»¶è¢«é‡å¤è§¦å‘çš„æ¬¡æ•°ï¼Œå› æ­¤æ•ˆç‡è¦æ¯” LT æ¨¡å¼é«˜ã€‚åªæ”¯æŒ No-Blockingï¼Œä»¥é¿å…ç”±äºä¸€ä¸ªæ–‡ä»¶å¥æŸ„çš„é˜»å¡è¯»/é˜»å¡å†™æ“ä½œæŠŠå¤„ç†å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦çš„ä»»åŠ¡é¥¿æ­»ã€‚

### â‘¥ select/poll/epoll çš„åº”ç”¨åœºæ™¯

å¾ˆå®¹æ˜“äº§ç”Ÿä¸€ç§é”™è§‰è®¤ä¸ºåªè¦ç”¨ `epoll `å°±å¯ä»¥äº†ï¼Œ`select `å’Œ `poll `éƒ½å·²ç»è¿‡æ—¶äº†ï¼Œå…¶å®å®ƒä»¬éƒ½æœ‰å„è‡ªçš„ä½¿ç”¨åœºæ™¯ã€‚

**`select `åº”ç”¨åœºæ™¯**

- `select` çš„ timeout å‚æ•°ç²¾åº¦ä¸ºå¾®ç§’ï¼Œè€Œ `poll `å’Œ `epoll `ä¸ºæ¯«ç§’ï¼Œå› æ­¤ <u>`select `æ›´åŠ é€‚ç”¨äºå®æ—¶æ€§è¦æ±‚æ¯”è¾ƒé«˜çš„åœºæ™¯ï¼Œæ¯”å¦‚æ ¸ååº”å †çš„æ§åˆ¶</u>ã€‚

  `select `<u>å¯ç§»æ¤æ€§æ›´å¥½</u>ï¼Œå‡ ä¹è¢«æ‰€æœ‰ä¸»æµå¹³å°æ‰€æ”¯æŒã€‚

**`poll `åº”ç”¨åœºæ™¯**

- `poll` æ²¡æœ‰æœ€å¤§æè¿°ç¬¦æ•°é‡çš„é™åˆ¶ï¼Œå¦‚æœå¹³å°æ”¯æŒå¹¶ä¸”å¯¹å®æ—¶æ€§è¦æ±‚ä¸é«˜ï¼Œåº”è¯¥ä½¿ç”¨ `poll `è€Œä¸æ˜¯ `select`ã€‚

**`epoll `åº”ç”¨åœºæ™¯**

- åªéœ€è¦è¿è¡Œåœ¨ Linux å¹³å°ä¸Šï¼Œæœ‰å¤§é‡çš„æè¿°ç¬¦éœ€è¦åŒæ—¶è½®è¯¢ï¼Œå¹¶ä¸”è¿™äº›è¿æ¥æœ€å¥½æ˜¯é•¿è¿æ¥ã€‚

  å¦‚æœéœ€è¦åŒæ—¶ç›‘æ§å°äº 1000 ä¸ªæè¿°ç¬¦ï¼Œå°±æ²¡æœ‰å¿…è¦ä½¿ç”¨ `epoll`ï¼Œå› ä¸ºè¿™ä¸ªåº”ç”¨åœºæ™¯ä¸‹å¹¶ä¸èƒ½ä½“ç° `epoll `çš„ä¼˜åŠ¿ã€‚

  éœ€è¦ç›‘æ§çš„æè¿°ç¬¦çŠ¶æ€å˜åŒ–å¤šï¼Œè€Œä¸”éƒ½æ˜¯éå¸¸çŸ­æš‚çš„ï¼Œä¹Ÿæ²¡æœ‰å¿…è¦ä½¿ç”¨ `epoll`ã€‚å› ä¸º <u>`epoll `ä¸­çš„æ‰€æœ‰æè¿°ç¬¦éƒ½å­˜å‚¨åœ¨å†…æ ¸ä¸­ï¼Œé€ æˆæ¯æ¬¡éœ€è¦å¯¹æè¿°ç¬¦çš„çŠ¶æ€æ”¹å˜éƒ½éœ€è¦é€šè¿‡ `epoll_ctl()` è¿›è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œé¢‘ç¹ç³»ç»Ÿè°ƒç”¨é™ä½æ•ˆç‡</u>ã€‚å¹¶ä¸” `epoll `çš„æè¿°ç¬¦å­˜å‚¨åœ¨å†…æ ¸ï¼Œä¸å®¹æ˜“è°ƒè¯•ã€‚

## 5. ä¿¡å·é©±åŠ¨å¼ I/Oï¼ˆSIGIOï¼‰

åº”ç”¨è¿›ç¨‹ä½¿ç”¨ `sigaction` ç³»ç»Ÿè°ƒç”¨ï¼Œå†…æ ¸ç«‹å³è¿”å›ï¼Œåº”ç”¨è¿›ç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯è¯´ç­‰å¾…æ•°æ®é˜¶æ®µåº”ç”¨è¿›ç¨‹æ˜¯éé˜»å¡çš„ã€‚**å†…æ ¸åœ¨æ•°æ®åˆ°è¾¾æ—¶å‘åº”ç”¨è¿›ç¨‹å‘é€ `SIGIO` ä¿¡å·**ï¼Œåº”ç”¨è¿›ç¨‹æ”¶åˆ°ä¹‹ååœ¨ä¿¡å·å¤„ç†ç¨‹åºä¸­è°ƒç”¨ `recvfrom` å°†æ•°æ®ä»å†…æ ¸å¤åˆ¶åˆ°åº”ç”¨è¿›ç¨‹ä¸­ã€‚

![](https://gitee.com/veal98/images/raw/master/img/20201210205411.png)

ç›¸æ¯”äºéé˜»å¡å¼ I/O çš„è½®è¯¢æ–¹å¼ï¼Œä¿¡å·é©±åŠ¨ I/O çš„ CPU åˆ©ç”¨ç‡æ›´é«˜ã€‚

## 6. å¼‚æ­¥ I/Oï¼ˆAsynchronous I/O, AIOï¼‰

åº”ç”¨è¿›ç¨‹æ‰§è¡Œ `aio_read` ç³»ç»Ÿè°ƒç”¨ä¼šç«‹å³è¿”å›ï¼Œåº”ç”¨è¿›ç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œï¼Œä¸ä¼šè¢«é˜»å¡ï¼Œ**å†…æ ¸ä¼šåœ¨æ‰€æœ‰æ“ä½œå®Œæˆä¹‹åå‘åº”ç”¨è¿›ç¨‹å‘é€ä¿¡å·**ã€‚

å¼‚æ­¥ I/O ä¸ä¿¡å·é©±åŠ¨ I/O çš„åŒºåˆ«åœ¨äºï¼Œ**å¼‚æ­¥ I/O çš„ä¿¡å·æ˜¯é€šçŸ¥åº”ç”¨è¿›ç¨‹ I/O å®Œæˆï¼Œè€Œä¿¡å·é©±åŠ¨ I/O çš„ä¿¡å·æ˜¯é€šçŸ¥åº”ç”¨è¿›ç¨‹å¯ä»¥å¼€å§‹ I/O**ã€‚

![](https://gitee.com/veal98/images/raw/master/img/20201210205459.png)

ç”¨æˆ·è¿›ç¨‹å‘èµ· `read` æ“ä½œä¹‹åï¼Œç«‹åˆ»å°±å¯ä»¥å¼€å§‹å»åšå…¶å®ƒçš„äº‹ã€‚å¦ä¸€æ–¹é¢ï¼Œä» kernel çš„è§’åº¦ï¼Œå½“å®ƒå—åˆ°ä¸€ä¸ª`Asynchronous read` ä¹‹åï¼Œé¦–å…ˆå®ƒä¼šç«‹åˆ»è¿”å›ï¼Œæ‰€ä»¥ä¸ä¼šå¯¹ç”¨æˆ·è¿›ç¨‹äº§ç”Ÿä»»ä½• blockã€‚ç„¶åï¼Œkernel ä¼šç­‰å¾…æ•°æ®å‡†å¤‡å®Œæˆï¼Œç„¶åå°†æ•°æ®æ‹·è´åˆ°ç”¨æˆ·å†…å­˜ï¼Œå½“è¿™ä¸€åˆ‡éƒ½å®Œæˆä¹‹åï¼Œkernel ä¼šç»™ç”¨æˆ·è¿›ç¨‹å‘é€ä¸€ä¸ª signalï¼Œå‘Šè¯‰å®ƒ `read ` æ“ä½œå®Œæˆäº†ã€‚

Linuxä¸‹çš„ Asynchronous IO å…¶å®ç”¨å¾—å¾ˆå°‘

## 7. äº”å¤§ I/O æ¨¡å‹æ¯”è¾ƒ

### â‘  é˜»å¡å¼ I/O å’Œéé˜»å¡ I/O çš„åŒºåˆ«

è°ƒç”¨ Blocking IO ä¼šä¸€ç›´é˜»å¡å¯¹åº”çš„è¿›ç¨‹ç›´åˆ°æ“ä½œå®Œæˆï¼Œè€Œ non-blocking IO åœ¨ kernel è¿˜åœ¨å‡†å¤‡æ•°æ®çš„æƒ…å†µä¸‹å°±ä¼šç«‹åˆ»è¿”å›ã€‚

### â‘¡ åŒæ­¥ I/O å’Œå¼‚æ­¥ I/O çš„åŒºåˆ«

- **åŒæ­¥ I/O**ï¼šå°†æ•°æ®ä»å†…æ ¸ç¼“å†²åŒºå¤åˆ¶åˆ°åº”ç”¨è¿›ç¨‹ç¼“å†²åŒºçš„é˜¶æ®µï¼ˆç¬¬äºŒé˜¶æ®µï¼‰ï¼Œåº”ç”¨è¿›ç¨‹ä¼šé˜»å¡ã€‚

  åŒæ­¥ I/O åŒ…æ‹¬é˜»å¡å¼ I/Oã€éé˜»å¡å¼ I/Oã€I/O å¤ç”¨å’Œä¿¡å·é©±åŠ¨ I/O ï¼Œå®ƒä»¬çš„ä¸»è¦åŒºåˆ«åœ¨ç¬¬ä¸€ä¸ªé˜¶æ®µã€‚

- **å¼‚æ­¥ I/O**ï¼šç¬¬äºŒé˜¶æ®µåº”ç”¨è¿›ç¨‹ä¸ä¼šé˜»å¡ã€‚

éé˜»å¡å¼ I/O ã€ä¿¡å·é©±åŠ¨ I/O å’Œå¼‚æ­¥ I/O åœ¨ç¬¬ä¸€é˜¶æ®µä¸ä¼šé˜»å¡ã€‚

**å„ä¸ª IO Model çš„æ¯”è¾ƒå¦‚å›¾æ‰€ç¤ºï¼š**

![](https://gitee.com/veal98/images/raw/master/img/20201210210141.png)

é€šè¿‡ä¸Šé¢çš„å›¾ç‰‡ï¼Œå¯ä»¥å‘ç° non-blocking IO å’Œ asynchronous IO çš„åŒºåˆ«è¿˜æ˜¯å¾ˆæ˜æ˜¾çš„ã€‚åœ¨ non-blocking IO ä¸­ï¼Œè™½ç„¶è¿›ç¨‹å¤§éƒ¨åˆ†æ—¶é—´éƒ½ä¸ä¼šè¢« blockï¼Œä½†æ˜¯å®ƒä»ç„¶è¦æ±‚è¿›ç¨‹å»ä¸»åŠ¨çš„ checkï¼Œå¹¶ä¸”å½“æ•°æ®å‡†å¤‡å®Œæˆä»¥åï¼Œä¹Ÿéœ€è¦è¿›ç¨‹ä¸»åŠ¨çš„å†æ¬¡è°ƒç”¨ `recvfrom` æ¥å°†æ•°æ®æ‹·è´åˆ°ç”¨æˆ·å†…å­˜ã€‚è€Œ asynchronous IO åˆ™å®Œå…¨ä¸åŒã€‚å®ƒå°±åƒæ˜¯ç”¨æˆ·è¿›ç¨‹å°†æ•´ä¸ª IO æ“ä½œäº¤ç»™äº†ä»–äººï¼ˆkernelï¼‰å®Œæˆï¼Œç„¶åä»–äººåšå®Œåå‘ä¿¡å·é€šçŸ¥ã€‚åœ¨æ­¤æœŸé—´ï¼Œç”¨æˆ·è¿›ç¨‹ä¸éœ€è¦å»æ£€æŸ¥ IO æ“ä½œçš„çŠ¶æ€ï¼Œä¹Ÿä¸éœ€è¦ä¸»åŠ¨çš„å»æ‹·è´æ•°æ®ã€‚

## ğŸ“š References

- [Linux IOæ¨¡å¼åŠ selectã€pollã€epollè¯¦è§£](https://segmentfault.com/a/1190000003063859)
- [CS-Notes](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Socket/Socket.html#%E4%B8%80%E3%80%81i-o-%E6%A8%A1%E5%9E%8B)