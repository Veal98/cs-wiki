# 🔋 模型评估与选择

> 🔊 本节内容对应吴恩达老师课程的 Week 6，参照西瓜书中的第二章内容进行了添加和修改。

## 1. 训练误差与过拟合

🍉 通常我们把分类错误的样本数占样本总数的比例称为 "**错误率**" (error rate) ，即如果在 m 个样本中有 α 个样本分类错误，则 **错误率 E= α / m**；相应的， **1 - α / m 称为 “精度”** accuracy，即 **精度 = 1 - 错误率**。

![](https://gitee.com/veal98/images/raw/master/img/20200629133723.png)

我们把 模型 / 学习器 的预测输出与样本的真实输出之间的差异称为 “**误差**” error。模型 / 学习器 在训练集上的误差称为 **训练误差** training error 或 **经验误差** empirical error，在新样本上的误差称为 **泛化误差** generalization error。<u>显然，我们希望得到泛化误差小的学习器。</u>

如果我们有非常多的特征，我们通过学习得到的假设可能能够非常好地适应训练集（代价函数可能几乎为 0），但是无法推广到新的数据，即泛化能力下降。这种现象在机器学习中称为 **过拟合 overfitting**。与过拟合相对应的是 **欠拟合 underfitting**。

💬 下图是一个回归问题的例子：

![](https://gitee.com/veal98/images/raw/master/img/20200629144506.png)

第一个模型是一个线性模型，**欠拟合**，**不能很好地适应我们的训练集**；

第三个模型是一个四次方的模型，**过于强调拟合原始数据**，而丢失了算法的本质：预测新数据。我们可以看出，若给出一个新的值使之预测，它将表现的很差，是**过拟合**，**虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好**；

🍉 下图是一个直观类比：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629134245.png" style="zoom:80%;" />

在现实任务中，❓ <u>我们往往有多种学习算法供选择，甚至对同一个学习算法，当使用不同的参数配置时也会产生不同的模型。那么，我们该选哪一个学习算法、使用哪种参数配置呢?</u> 这就器学习中的"**模型选择**" （model selection）问题。

理想的解决方案当然是对候选模型的泛化误差进评估然后选择泛化误差最小的那个模型。然而我们**无法直接获得泛化误差，而训练误差又由于过拟合现象的存在而不适合作为标准**，那么，在现实中如何进行模型评估与选择呢？

## 2. 评估方法

我们已经知道，<u>很小的训练误差也可能是过拟合的，所以这推广到新的训练集上是不适用的。</u>我们的目的是根据模型 / 学习器的泛化误差进行评估从而做出选择。

❓ 那么，该**如何判断训练出来的模型是否过拟合呢**？

⭐ 我们将数据分成训练集和测试集，**以测试集上的测试误差 testing error 作为泛化误差的近似**。

很重要的一点是训练集和测试集均要含有各种类型的数据，且测试集应该尽可能与训练集互斥，即测试样本尽量不在训练集中出现、未在训练过程中使用过（🍉 好比老师出了10道习题供同学们练习，考试时老师又用同样的这10道题，显然这样并不能反映泛化能力）。

👇 <u>下面介绍几种处理数据集 D 从中产生训练集 S 和 测试集 T 的方法</u>：

### ① 留出法 hold-out

留出法直接将数据集 D 划分为两个互斥的集合，**用 70% 的数据作为训练集 S，用剩下 30% 的数据作为测试集 T**。即 <img src="https://gitee.com/veal98/images/raw/master/img/20200629141319.png" style="zoom: 67%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20200608220453.png" style="zoom:50%;" />

⭐ **通过训练集 S 让我们的模型学习得出其参数后，对测试集 T 运用该模型/学习器来评估其测试误差，作为对泛化误差的估计。**

<img src="https://gitee.com/veal98/images/raw/master/img/20200629141540.png" style="zoom: 67%;" />



对于线性回归和逻辑回归问题，计算测试误差的方法分别如下（**将测试集的数据应用到训练集训练出来的模型（代价函数 J）上**）：

- 对于**线性回归**模型，利用测试集数据计算代价函数 J

  $$J_{test}(θ) = \frac{1}{2m_{test}}\sum_{i=1}^{m_{test}}(h_θ(x_{test}^{(i)}) - y_{test}^{(i)})^2$$

- 对于**逻辑回归**模型，利用测试集数据计算代价函数 J：

  ![](https://gitee.com/veal98/images/raw/master/img/20200608221219.png)

  对于每一个测试集样本，计算误分类的比率：

  ![](https://gitee.com/veal98/images/raw/master/img/20200608221337.png)

  然后对计算结果求平均。

<br>

🍉 <u>单次使用留出法得到的估计结果往往不够稳定可靠</u>，在**使用留出法时，一般要采用若干次所及划分、重复进行实验评估后<u>取平均值</u>作为留出法的评估结果**。例如进行 100 次随机划分，每次产生一个训练/测试集用于实验评估，100 次后就得到 100 个结果，而留出法返回的则是这 100 个结果的平均。

此外，还需注意一个问题：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629144829.png" style="zoom: 67%;" />

### ② 交叉验证法 cross validation

🍉 **交叉验证法先将数据集 D 划分成 k 个大小相似的互斥子集**，即 D = D1 ∪ D2 ∪ D3 ...... ∪ Dk，且 Di ∩ Dj = ø （i ≠ j）。每个子集都尽可能保持数据分布的一致性，即从 D 中通过分层采样得到。然后，**每次用 k - 1 个子集的并集作为训练集，余下的那个子集作为测试集**。这样就获得了  k 组训练/测试集，从而可进行 k 次训练和测试，**最终返回的是这 k 个结果的均值**。

显然，交叉验证法的评估结果的稳定性和保真性很大程度上取决于 k 的取值，为强调这一点，通常把交叉验证法称为 **k 折交叉验证 k - fold cross validation**。k 最常用的取值是 10，此时称为 10 这交叉验证。其他常用的 k 有 5、20 等。

<img src="https://gitee.com/veal98/images/raw/master/img/20200629145743.png" style="zoom:80%;" />

与留出法相似，k 折交叉验证通常要随机使用不同的划分重复 p 次，最终的评估结果是这 p 次 k 折交叉验证结果的均值，例如常见的有 10 次 10 折交叉验证（100 次 训练）

**假定数据集中包含 m 个样本，令 k = m**，则得到了交叉验证法中的一个特例：**留一法（Leave-One-Out，LOO）**，显然，留一法不受随机样本划分方式的影响。留一法使用的训练集与初始数据集相比只少了一个样本，这就使得在绝大部分情况下，留一法的评估结果往往被认为比较准确。然而，在数据集比较大的时候，训练 m 个模型的计算开销可能是难以忍受的。而且，留一法的估计结果也未必永远都比其他评估方法更准确。

### ③ 自助法 bootstrapping

🍉 我们希望评估的是用 D 训练出的模型.但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比 D 小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。❓ <u>有没有什么办法可以减少训练样本规模不同造成的影响，同时还能比较高效地进行实验估计呢 ?</u>

**自助法**是一个比较好的解决方案，它直接以**自助采样法 bootstrap sampling** 为基础，给定包含 m 个样本的数据集 D，我们对他进行采样产生数据集 $D'$ ：🔵 <u>每次随机从 D 中挑选一个样本，将其拷贝放入 $D'$ ，然后再将该样本返回初始数据集 D 中，使得该样本在下次采样时仍有可能被采到；这个过程重复执行 m 次后，我们就得到了包含 m 个样本的数据集 $D'$，这就是自助采样的结果</u>。

显然，D 中有一部分样本会在 $D'$ 中多次出现，而另一部分样本不出现。可以做一个简单的估计，样本在 m 次采样中不被采到的概率是 $(1  - \frac1m)^m$，取极限得到 <img src="https://gitee.com/veal98/images/raw/master/img/20200629193245.png" style="zoom: 67%;" />

即通过自助采样，初始数据集 D 中约有  36.8% 的样本未出现在采样数据集  $D'$ 中。

🚩 于是我们可以**将 $D'$ 用作训练集，D \ $D'$ 用作测试集（`\` 表示集合集合减法）**；

这样，实际评估的模型与期望评估的模型都使用 m 个训练样本，而我们仍有数据总量的 1/3、没在训练集中出现的样本用于测试。这样的测试结果，亦称 **包外估计 out-of-bag estimate**。

自助法在数据集较小、难以有效划分训练/测试集时很有用；然而，自助法产生的数据集改变了初始数据的分布，这会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。

### ④ 调参与最终模型

🍉 大多数学习算法都有些参数(parameter)需要设定，参数配置不同，学得模型的性能往往有显著差别。因此，<u>在进行模型评估与选择时，除了要对适用学习算法进行选择，还需对算法参数进行设定，这就是通常所说的"参数调节"或简称"**调参**"(parameter tuning).</u> 

读者可能马上想到，调参和算法选择没什么本质区别：**对每种参数配置都训练出模型，然后把对应最好模型的参数作为结果**。这样的考虑基本是正确的，但有一点需注意：学习算法的很多参数是在实数范围内取值，因此，对每种参数配置都训练出模型来是不可行的。现实中常用的做法?是对每个参数选定一个范围和变化步长，例如在 [0，0.2] 范围内以0.05为步长，则实际要评估的候选参数值有 5 个，最终是从这 5 个候选值中产生选定值。显然，这样选定的参数值往往不是"最佳"值，但这是在计算开销和性能估计之间进行折中的结果，通过这个折中，学习过程才变得可行。

<img src="https://gitee.com/veal98/images/raw/master/img/20200629201508.png" style="zoom:67%;" />

给定包含 m 个样本的数据集 D，在模型评估与选择过程中由于需要留出一部分数据进行评估测试，事实上我们只使用了一部分数据训练模型。因此，**在模型选择完成后，学习算法和参数配置己选定，此时应该用数据集 D 重新训练模型。这个模型在训练过程中使用了所有 m 个样本，这才是我们最终提交给用户的模型。**

<br>

⭐ 另外，需注意的是，我们通常把学得模型在实际使用中遇到的数据称为测试数据，为了加以区分，模型评估与选择中用于评估测试的数据集常称为"**验证集**"(validation set)。例如，在研究对比不同算法的泛化性能时，我们用测试集上的判别效果来估计模型在实际使用时的泛化能力，而**<u>把训练数据另外划分为训练集和验证集，基于验证集上的性能来进行模型选择和调参</u>**。

💬 例如我们要在 10 个不同次数的二项式模型之间进行选择：

![](https://gitee.com/veal98/images/raw/master/img/20200608222445.png)

显然越高次数的多项式模型越能够适应我们的训练数据集，但是适应训练数据集并不代表着能推广至一般情况，我们应该选择一个更能适应一般情况的模型。<u>我们需要使用验证集来帮助选择模型</u>。 ⭐ 即：**使用 60% 的数据作为训练集 Train，使用 20% 的数据作为交叉验证集 Cross Validaton，使用 20% 的数据作为测试集 Test**

<img src="https://gitee.com/veal98/images/raw/master/img/20200608222601.png" style="zoom:50%;" />

👇 模型选择的方法为（以线性回归为例）：

- 使用训练集训练出10个模型

  <img src="https://gitee.com/veal98/images/raw/master/img/20200608223059.png" style="zoom:50%;" />

- 用 10 个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）

  <img src="https://gitee.com/veal98/images/raw/master/img/20200608223114.png" style="zoom:50%;" />

- **选取验证集上代价函数值最小的模型**

- 用步骤 3 中选出的模型对测试集计算得出测试误差/泛化误差（代价函数的值）

  <img src="https://gitee.com/veal98/images/raw/master/img/20200608223127.png" style="zoom: 50%;" />



⭐总结：**训练集求出模型的参数，验证集带入模型选出代价函数最小的模型，最后用测试集评估该模型泛化能力**

## 3. 性能度量 performance measure

🍉 对学习器/模型 的泛化性能进行评估，不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是**性能度量** (performance measure)。

性能度量反映了任务需求，**在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果**；这意味着模型的"好坏"是相对的，什么样的模型是好的? 不仅取决于算法和数据，还决定于任务需求。

在预测任务中给定样例集 $D = {(x_1,y_1),(x_2,y_2),(x_3,y_3)......,(x_m,y_m)}$，其中 $y_i$是示例 $x_i$ 的真实标签。要评估学习器/模型 f 的性能，就要把学习器预测结果 f(x) 与真实标签 y 进行比较。

⭐ **回归**任务最常用的性能度量是 **均方误差 mean squared error**：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629203253.png" style="zoom:80%;" />

更一般的，对于数据分布 D 和概率密度函数 p(.) ，均方误差可描述为：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629203402.png" style="zoom:80%;" />

接下来主要介绍**分类**任务中常用的性能度量：

### ① 错误率与精度

本章开头提到了错误率和精度。这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例.

> 🍉 通常我们把分类错误的样本数占样本总数的比例称为 "**错误率**" (error rate) ，即如果在 m 个样本中有 α 个样本分类错误，则 **错误率 E= α / m**；相应的， **1 - α / m 称为 “精度”** accuracy，即 **精度 = 1 - 错误率**。
>
> ![](https://gitee.com/veal98/images/raw/master/img/20200629133723.png)

对于样例集 D，分类错误率定义为：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629203823.png" style="zoom:80%;" />

精度则定义为：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629203905.png" style="zoom:80%;" />

更一般的，对于数据分布 D 和概率密度函数 p(.) ，错误率与精度可分别描述为：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629203953.png" style="zoom:80%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20200629204014.png" style="zoom:80%;" />

### ② 查准率、查全率与 F1

🍉 错误率和精度虽常用，但并不能满足所有任务需求.以西瓜问题为例，假定瓜农拉来一车西瓜，我们用训练好的模型对这些西瓜进行判别，显然，<u>错误率衡量了有多少比例的瓜被判别错误。但是若我们关心的是"挑出的西瓜中有多少比例是好瓜"，或者"所有好瓜中有多少比例被挑了出来"，那么错误率显然就不够用了，</u>这时需要使用其他的性能度量。

> 🚩 错误率和精度也无法应用于**偏斜类（skewed classes）**问题：
>
> **类偏斜情况表现为我们的训练集中有非常多的同一种类的样本，只有很少或没有其他类的样本**。 
>
> 例如我们希望用算法来预测癌症是否是恶性的，在我们的训练集中，只有 0.5% 的实例是恶性肿瘤。<u>假设我们编写一个非学习而来的算法，即在所有情况下都预测肿瘤是良性的，那么错误率只有 0.5%。然而我们通过训练而得到的神经网络算法却有 1% 的错误率。这时，我们并不能说非学习来的算法要比训练来的算法准确。</u>

🚩 <u>我们可以使用 **查准率**（**Precision**）和**查全率 / 召回率**（**Recall**） 作为评估度量值</u>，将算法预测的结果分成四种情况：

- **正确肯定**（**True Positive, TP**）：预测为真，实际为真
- **正确否定**（**True Negative, TN**）：预测为假，实际为假 
- **错误肯定**（**False Positive, FP**）：预测为真，实际为假 
- **错误否定**（**False Negative, FN**）：预测为假，实际为真

<img src="https://gitee.com/veal98/images/raw/master/img/20200609155848.png"  />

**查准率 P = TP/(TP+FP)**：即我们预测这些病人的肿瘤是恶性的，对于这些病人来说，有多大概率是真正患有癌症的？这就是查准率。高查准率表示我们预测这些病人的肿瘤是恶性的，这个预测具有很高的准确性。

**查全率 R = TP/(TP+FN)**：即如果数据集中的所有人的肿瘤都是恶性的，有多少人我们能够正确告诉他们，你需要治疗。显然，查全率越高越好

🍉 **查准率和查全率是一对矛盾的度量**。一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。例如，若希望将好瓜尽可能多地选出来，则可通过增加选瓜的数量来实现，但这样查准率就会较低;若希望选的瓜中好瓜比例尽可能高，则可只挑选最有把握的瓜，但这样就难免会漏掉不少好瓜，使得查全率较低。通常只有在一些简单任务中才可能使查全率和查准率都很高。

下图是逻辑回归中阈值与查准率和查全率的关系：

![](https://gitee.com/veal98/images/raw/master/img/20200609160232.png)

很多情形下，我们可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为"最可能"是正例的样本，排在最后的则是学习器认为"最不可能"是正例的样本。<u>按此顺序逐个把样本作为正例进行预测</u>，则每次可以计算出当前的查全率、查准率。以查准率为纵轴、查全率为横轴作图，就得到了**查准率 - 查全率曲线**，简称 **P-R 曲线**，显示该曲线的图称为 P-R 图。

<img src="https://gitee.com/veal98/images/raw/master/img/20200629210259.png" style="zoom: 67%;" />

**若一个模型/学习器的 P-R 曲线被另一个学习器的曲线完全 “包住”，则可断言后者的性能优于前者**。例如上图中 A 的性能优于 C；

如果两个学习器的 P-R 曲线**发生了交叉**，则难以一般性的断言两者孰优孰劣（上图中的**平衡点 BEP** 即**查全率 = 查准率**时的取值，可作为该情况下的度量标准，但是过于简化了些。上图中从 BEP 来看，A 的性能优于 B），<u>一般采用 **F1** 度量</u>：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629210611.png" style="zoom: 80%;" />

**通常我们选择使得 F1 值最高的阀值**。

在一些应用中，**对查准率和查全率的重视程度有所不同**。例如在商品推荐系统中，为了尽可能少打扰用户，更希望推荐内容确是用户感兴趣的，此时查准率更重要；而在逃犯信息检索系统中，更希望尽可能少漏掉逃犯，此时查全率更重要。F1 度量的一般形式 $F_β$ 能让我们表达出对查准率/查全率的不同偏好：

<img src="https://gitee.com/veal98/images/raw/master/img/20200629210911.png" style="zoom: 80%;" />

其中 

- **β > 0** 度量了查全率对查准率的相对重要性；
- **β  = 1** 时退化为标准的 F1；
- **β > 1** 时查全率有更大的影响；
- **β < 1** 时查准率有更大的影响。

### ③ ROC 与 AOC

🍉 很多学习器是为测试样本产生一个实值或概率预测，然后将这个预测值与一个分类**阈值(threshold)**进行比较，若大于阈值则分为正类，否则为反类。

例如，神经网络在一般情形下是对每个测试样本预测出一个 [0.0，1.0] 之间的实值，然后将这个值与 0.5 进行比较，大于 0.5 则判为正例，否则为反例。这个实值或概率预测结果的好坏，直接决定了学习器的泛化能力。

实际上，根据这个实值或概率预测结果，我们可将测试样本进行排序，"最可能"是正例的排在最前面，"最不可能"是正例的排在最后面。这样，分类过程就相当于在这个排序中以某个**"截断点"(cut point)**将样本分为两部分，前一部分判作正例，后一部分则判作反例。

在不同的应用任务中，我们可根据任务需求来采用不同的截断点。例如**若我们更重视"查准率"，则可选择排序中靠前的位置进行截断；若更重视"查全率"，则可选择靠后的位置进行截断**。因此，排序本身的质量好坏，体现了综合考虑学习器在不同任务下的"期望泛化性能"的好坏，或者说"一般情况下"泛化性能的好坏。**ROC （Receiver Operating Characteristic  — 受试者工作特征） 曲线**则是从这个角度出发来研究学习器泛化性能的有力工具。

与 P-R 曲线类似，只不过 ROC 曲线的横纵轴分别是 **TPR 真正例率（True Positive Rate）** 和  **FPR 假正例率 （False  Positive Rate）**

<img src="https://gitee.com/veal98/images/raw/master/img/20200629212745.png" style="zoom:80%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20200629212921.png" style="zoom:80%;" />

现实任务中通常是利用有限个测试样例来绘制 ROC，此时仅能获得有限个坐标对，无法产生左图的光滑 ROC 曲线，只能绘制出右图的近似  ROC 曲线。

🚩 **绘图步骤**：

- 给定 m+  个正例 和 m- 个反例，根据学习器预测结果对样例进行排序，然后把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为 0，在坐标（0，0）处标记一个点。

- 然后，将分类阈值依次设置为每个样例的预测值，即依次将每个样例划分为正例：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200629213357.png" style="zoom:80%;" />



进行学习器的比较时，与 P-R 图类似：

- 若一个学习器的 ROC 曲线被另一个学习器的 ROC 曲线完全包住，则后一个学习器性能优于前者；

- 若两个学习的 ROC 曲线发生了交叉，则比较 ROC 曲线下的面积，即 **AUC （Area Under ROC Curve）**，AUC 较大者性能较高。

  假设 ROC 曲线中各个坐标点为 $(x_i, y_i)$，则 AUC 可估算为：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200629213905.png" style="zoom:80%;" />

  <img src="https://gitee.com/veal98/images/raw/master/img/20200629214008.png" style="zoom: 70%;" />

### ④ 代价敏感错误率与代价曲线

🍉 上面的方法中，将学习器的犯错同等对待，但在现实生活中，**将正例预测成假例与将假例预测成正例的代价常常是不一样的**，例如：将无疾病-->有疾病只是增多了检查，但有疾病-->无疾病却是增加了生命危险。为权衡不同类型错误所造成的不同损失，可为错误赋予**"非均等代价"(unequal cost)**。以二分类为例，由此引入了“代价矩阵”（cost matrix）。其中 $cost_{ij}$ 表示将 第 i 类样本预测为 j 类的代价。

![16.png](https://i.loli.net/2018/10/17/5bc71ed6ed582.png)

回顾前面介绍的一些性能度量可看出，它们大都隐式地假设了均等代价，例如错误率时直接计算错误次数，并没有考虑不同的错误会造成不同的后果。

**在非均等错误代价下，我们希望的不再是简单地最小化错误次数，而是最小化“总体代价”**，这样“代价敏感”的错误率为：

![17.png](https://i.loli.net/2018/10/17/5bc71ed70bebe.png)

在非均等错误代价下，ROC 曲线不能直接反映出学习器的期望总体代价，而**代价曲线 cost curve** 可达到该母的。代价曲线横轴是取值在 [0,1] 之间的正例概率代价，式中 p 表示正例的概率，纵轴是取值为 [0,1] 的归一化代价。 

![](https://gitee.com/veal98/images/raw/master/img/20200629220208.png)

其中 FPR 是 ROC 中定义的假正例率，`FNR = 1 -TPR` 是假反例率

代价曲线的绘制很简单：

- 设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出 FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，**线段下的面积即表示了该条件下的期望总体代价**；

- 如此将 ROC 曲线土的每个点转化为代价平面上的一条线段，然后**取所有线段的下界**，**围成的面积即为在所有条件下学习器的期望总体代价**，如图所示：

  ![](https://gitee.com/veal98/images/raw/master/img/20200629220422.png)

## 4. 比较校验

🍉 在上面几节中，我们介绍了多种常见的评估方法和性能度量标准，这样我们就可以根据数据集以及模型任务的特征，选择出最合适的评估和性能度量方法来计算出学习器的“测试误差“。但由于“测试误差”受到很多因素的影响，例如：算法随机性(例如常见的K-Means)或测试集本身的选择，使得同一模型每次得到的结果不尽相同，同时测试误差是作为泛化误差的近似，并不能代表学习器真实的泛化性能，那**如何对单个或多个学习器在不同或相同测试集上的性能度量结果做比较呢**？

在比较学习器泛化性能的过程中，**统计假设检验（hypothesis test）**为学习器性能比较提供了重要依据。<u>基于假设校验结果我们可推断出，若在测试集上观察到学习器 A 比 B 好，则 A 的泛化性能是否在统计意义上优于 B，以及这个结论的把握有多大。</u>

下面我们介绍几种常用的机器学习性能比较方法。（为便于讨论，本节默认以错误率为性能度量）

### ① 假设校验

🍉 **假设校验中的 假设 是对学习器泛化错误率分布的某种判断或猜想**。现实任务中我们不知道学习器的泛化错误率，只能获知其测试错误率。泛化错误率与测试错误率未必相同，但两者接近的可能性比较大，因此，**可根据测试错误率推出泛化错误率的分布**。

![](https://gitee.com/veal98/images/raw/master/img/20200630091132.png)

![](https://gitee.com/veal98/images/raw/master/img/20200630091033.png)

![](https://gitee.com/veal98/images/raw/master/img/20200630091211.png)

![](https://gitee.com/veal98/images/raw/master/img/20200630090635.png)

上面介绍的两种方法都是对关于**单个学习器**泛化性能的假设进行检验，而在现实任务中，更多时候我们需对**不同学习器**的性能进行比较，下面将介绍适用于此类情况的假设检验方法。👇

### ② 交叉验证 t 校验

<img src="https://gitee.com/veal98/images/raw/master/img/20200630091445.png" style="zoom:80%;" />

欲进行有效的假设检验，一个重要前提是**测试错误率均为泛化错误率的独立采样**。然而，通常情况下<u>由于样本有限，在使用交叉验证等实验估计方法时，不同轮次的训练集会有一定程度的重叠，这就使得测试错误率实际上并不独立，会导致过高估计假设成立的概率</u>。为缓解这一问题，可采用 **5 x 2 交叉验证法**：

5x2 交叉验证是做 5次 2 折交叉验证，**在每次 2 折交叉验证之前随机将数据打乱**，使得 5 次交叉验证中的数据划分不重复。

<img src="https://gitee.com/veal98/images/raw/master/img/20200630091728.png" style="zoom:80%;" />

### ③ McNemar 校验

对二分类问题，使用留出法不仅可估计出学习器的测试错误率，还可获得两学习器分类结果的差别，即两者都正确、都错误、一个正确另一个错误的样本数，如下表（列联表 contingency table）：

![](https://gitee.com/veal98/images/raw/master/img/20200630092209.png)

若我们做的假设是两学习器性能相同，则应有 $e_{01} = e_{10}$ ，那么变量 $|e_{01} - e_{10}|$ 应当服从正态分布，且 均值为 1，方差为 $e_{01} + e_{10}$，因此，如下所示的变量服从自由度为 1 的卡方分布 $χ^2$，即服从标准正态分布 N（0,1）变量的平方和：

![](https://gitee.com/veal98/images/raw/master/img/20200630092548.png)

给定显著度 α ，当以上变量恒小于临界值 $χ_α^2$ 时，不能拒绝假设，即认为两学习器的性能没有显著差别；否则拒绝假设，即认为两者性能有显著差别，且平均错误率较小的那个学习器性能较优。

自由度为 1 的  $χ^2$ 检验的临界值当 $α = 0.05$​ 时为 3.8415，$α = 0.1 $ 时为 2.7055。

### ④ Friedman 校验与 Nemenyi 后续校验



## 5. 偏差与方差 bias - variance

### ① 偏差与方差

🍉 对学习算法除了通过实验估计其泛化性能，人们往往还希望了解它"为什么"具有这样的性能，**"偏差方差分解"(bias-variance decomposition)** 是解释学习算法泛化性能的一种重要工具。

我们知道，算法在不同训练集上学得的结果很可能不同，即便这些训练集是来自同一个分布。

对测试样本 x，令 $y_D$ 为 x 在 数据集上的标签，y 为 x 的真实标签，f(x, D) 为训练集 D 上训练出来的模型 f 在 x 上的预测输出。以回归任务为例 ：

学习算法的期望预测为：

![](https://gitee.com/veal98/images/raw/master/img/20200630093658.png)

使用样本数相同的不同训练集产生的**方差 variance**为：

![](https://gitee.com/veal98/images/raw/master/img/20200630093759.png)

**噪声**为：

![](https://gitee.com/veal98/images/raw/master/img/20200630093837.png)

期望输出与真实标签的差别称为**偏差  bias** ：

![](https://gitee.com/veal98/images/raw/master/img/20200630093849.png)

为便于讨论，假定噪声期望为 0，对算法的期望泛化误差进行分解：

<img src="https://gitee.com/veal98/images/raw/master/img/20200630094042.png" style="zoom:80%;" />

⭐ 也就是说：**泛化误差可分解为偏差、方差与噪声之和**。

- 偏差 bias：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力
- 方差 variance：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响
- 噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。

偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，使得数据扰动产生的影响小。

一般来说，偏差与方差是有冲突的，这称为**偏差一方差窘境**(bias-variance dilemma)。下图给出了一个示意图，给定学习任务，假定我们能控制学习算法的训练程度：

<img src="https://gitee.com/veal98/images/raw/master/img/20200630094804.png" style="zoom:80%;" />

在**训练不足**时，学习器的拟合能力不够强，训练数据的扰动不足以使学习器产生显著变化，此时**偏差**主导了泛化错误率；

**随着训练程度的加深**，学习器的拟合能力逐渐增强，训练数据发生的扰动渐渐能被学习器学到，**方差**逐渐主导了泛化错误率；

**在训练程度充足后**，学习器的拟合能力已非常强，训练数据发生的轻微扰动都会导致学习器发生显著变化，若训练数据自身的、非全局的特性被学习器学到了，则将发生**过拟合**。

<br>



当你运行一个学习算法时，如果这个算法的表现不理想，那么多半是出现两种情况：要么是偏差比较大，要么是方差比较大。换句话说，出现的情况要么是欠拟合，要么是过拟合问题。

那么这两种情况，哪个和偏差有关，哪个和方差有关，或者是不是和两个都有关？搞清楚这一点非常重要，因为能判断出现的情况是这两种情况中的哪一种，是一个很有效的指示器，指引着可以改进算法的最有效的方法和途径。

我们通常会通过将训练集和交叉验证集的代价函数误差与多项式的次数绘制在同一张图表上来帮助分析：

<img src="https://gitee.com/veal98/images/raw/master/img/20200608224131.png" style="zoom:50%;" />

对于训练集，当多项式的次数 d 较小时，模型拟合程度更低，误差较大；随着 d 的增长，拟合程度提高，误差减小。 

对于交叉验证集，当 d 较小时，模型拟合程度低，误差较大；但是随着 d  的增长，误差呈现先减小后增大的趋势，**转折点是我们的模型开始过拟合训练数据集的时候**。 如果我们的交叉验证集误差较大，我们如何判断是方差还是偏差呢？

🚩 **离原点较近的便是高偏差问题 Bias，离原点较远的就是高方差问题 Variance**。从图中可以看出：

- **高偏差**：

  $J_{train}(θ)$ 训练误差很大 （表示假设函数不能很好的拟合训练集）

  $J_{cv}(θ)$ 交叉验证误差 ≈ $J_{train}(θ)$

- **高方差**：

  $J_{train}(θ)$ 训练误差 很小 （表示假设函数很好的拟合了训练集）

  $J_{cv}(θ)$ 交叉验证误差 远远大于 $J_{train}(θ)$

### ② 正则化和偏差/方差

在我们在训练模型的过程中，**一般会使用正则化来防止过拟合**。但是我们可能会正则化的程度太高或太小了，即我们在选择 λ (正则化参数) 的值时也需要思考与刚才选择多项式模型次数类似的问题。

![](https://gitee.com/veal98/images/raw/master/img/20200609143947.png)

我们选择一系列的想要测试的 λ 值，通常是 0-10 之间的呈现 2 倍关系的值：

<img src="https://gitee.com/veal98/images/raw/master/img/20200609144047.png" style="zoom:50%;" />

选择  λ  的方法为：

- 使用训练集训练出 12 个不同程度正则化的模型

- 用 12 个模型分别对交叉验证集计算得出交叉验证误差

- ⭐ **选择得出交叉验证误差最小的模型**

- 运用步骤 3 中选出模型对测试集计算得出泛化误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与 λ 的值绘制在一张图表上：

  <img src="https://gitee.com/veal98/images/raw/master/img/20200609144628.png" style="zoom:50%;" />

🚩 当  λ   较小时，训练集误差较小（过拟合）而交叉验证集误差较大（高方差）；随着   λ  的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加（高偏差）

### ③ 学习曲线 Learning Curve

学习曲线是一种很好的工具，我们经常**使用学习曲线来判断某一个学习算法是否处于偏差、方差问题**。学习曲线是学习算法的一个很好的合理检验（sanity check）。

🔴 **学习曲线是将训练集误差和交叉验证集误差作为训练集样本数量（m）的函数绘制的图表**。 即，如果我们有 100 行数据，我们从 1 行数据开始，逐渐学习更多行的数据。

当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据。

<img src="https://gitee.com/veal98/images/raw/master/img/20200609145520.png" style="zoom:50%;" />

❓ **如何利用学习曲线识别高偏差/欠拟合呢？**作为例子，我们尝试用一条直线来适应下面的数据，可以看出，无论训练集有多么大误差都不会有太大改观：

<img src="https://gitee.com/veal98/images/raw/master/img/20200609150455.png" style="zoom:50%;" />

⭐ 也就是说**在高偏差/欠拟合的情况下，增加数据到训练集不一定能有帮助**

❓ **如何利用学习曲线识别高方差/过拟合？**假设我们使用一个非常高次的多项式模型，并且正则化非常小，可以看出，<u>当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果：</u>

<img src="https://gitee.com/veal98/images/raw/master/img/20200609150759.png" style="zoom:50%;" />

⭐ 也就是说**在高方差/过拟合的情况下，增加更多数据到训练集可能可以提高算法效果**。

###  ④ 如何解决高方差 / 高偏差问题

我们已经介绍了怎样评价一个学习算法，我们讨论了模型选择问题，偏差和方差的问题。那么这些诊断法则怎样帮助我们判断，哪些方法可能有助于改进学习算法的性能，而哪些可能是徒劳的呢？让我们来看一看我们在以下这些情况下应该怎样选择：⭐ 

- 获得更多的训练样本 —— 解决高方差
- 尝试减少特征的数量 —— 解决高方差
- 尝试增加正则化程度 λ —— 解决高方差
- 尝试获得更多的特征 —— 解决高偏差
- 尝试增加多项式特征 —— 解决高偏差
- 尝试减少正则化程度 λ —— 解决高偏差

### ⑤ 神经网络的方差和偏差

![](https://gitee.com/veal98/images/raw/master/img/20200609151613.png)

使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小。

使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。 

🚩 **通常选择较大的神经网络并采用正则化处理会比采用较小的神经网络效果要好。** 

🚩 **对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数**，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，**针对不同隐藏层层数的神经网络训练神经网络， 然后选择交叉验证集代价最小的神经网络。**



## ✍ Quiz — Week 6 | 1 机器学习的评价参数

### ① 第 1 题

你训练一个学习算法，发现它<u>在测试集上的误差很高</u>。绘制学习曲线，并获得下图。算法是否存在高偏差、高方差或两者都不存在？

![](https://gitee.com/veal98/images/raw/master/img/20200611170212.png)

- ✅ 高偏差 
- 高方差
- 两者都不

> 💡 （训练集误差 ≈ 测试集误差 且 训练集/测试集 误差较高）

### ② 第 2 题

假设您已经实现了正则化逻辑回归来分类图像中的对象（即，还没有实现图像识别）。然而，当你在一组新的图像上检验你的模型时，你会发现它<u>对新图像的预测有误差非常大</u>。然而，你的假设<u>在训练集上拟合的很好</u>。以下哪个做法可以改善？选出所有正确项

- 尝试添加多项式特征 
- ✅ 获取更多训练示例 
- ✅ 尝试使用较少的特征 
- 少用训练的例子

> 💡 此题是高方差问题
>
> - 获得更多的训练样本 —— 解决高方差
>
> - 尝试减少特征的数量 —— 解决高方差
>
> - 尝试获得更多的特征 —— 解决高偏差
>
> - 尝试增加多项式特征 —— 解决高偏差
>
> - 尝试减少正则化程度 λ —— 解决高偏差
>
> - 尝试增加正则化程度 λ —— 解决高方差

### ③ 第 3 题

假设您已经实现了正则化的逻辑来预测客户将在购物网站上购买哪些商品。然而，当你在一组新的客户身上测试你的模型时，你发现它在预测中的误差很大。此外，该模型<u>在训练集上表现不佳</u>。以下哪个做法可以改善？选出所有正确项

- ✅ 尝试获取并使用其他特征 
- ✅ 尝试添加多项式特征 
- 尝试使用较少的特征 
- 尝试增加正则化参数 λ

> 💡 此题是高偏差问题

### ④ 第 4 题

以下哪项陈述是正确的？选出所有正确项

- ✅ 假设您正在训练一个正则化的线性回归模型。选择正则化参数 λ 值的推荐方法是选择交叉验证误差最小的 λ 值。

- 假设您正在训练一个正则化的线性回归模型。选择正则化参数 λ 值的推荐方法是选择给出最小测试集误差的 λ 值。

- 假设你正在训练一个正则化线性回归模型，推荐的选择正则化参数 λ 值的方法是选择给出最小训练集误差的 λ 值。

- ✅ 学习算法在训练集上的性能通常比在测试集上的性能要好。

### ⑤ 第 5 题

以下哪项陈述是正确的？选出所有正确项

- ✅ 在调试学习算法时，绘制学习曲线有助于了解是否存在高偏差或高方差问题。

- ✅ 如果一个学习算法受到高方差的影响，增加更多的训练实例可能会改善测试误差。

- 我们总是喜欢高方差的模型（而不是高偏差的模型），因为它们能够更好地适应训练集。

- ✅ 如果一个学习算法有很高的偏差，仅仅增加更多的训练实例可能不会显著改善测试误差。



## ✍ Quiz — Week 6 | 3 机器学习系统设计

### ① 第 1 题

你正在研究一个垃圾邮件分类系统，准备使用正则化的逻辑回归。“垃圾邮件”是正类（y=1），“非垃圾邮件”是负类（y=0）。您已经训练了分类器，交叉验证集中有m=1000个示例。预测类与实际类的图表为：

|                    | Actual Class：1 | Actual Class：0 |
| :----------------: | :-------------: | :-------------: |
| Predicted Class：1 |       85        |       890       |
| Predicted Class：0 |       15        |       10        |

分类器的召回率 Recall 是多少？

> 💡 Recall = 85 / 85 + 15 = 0.85
>
> ![](https://gitee.com/veal98/images/raw/master/img/20200611172604.png)

### ② 第 2 题

假设一个庞大的数据集可以用来训练一个学习算法。当以下两个条件成立时，对大量数据进行训练可能会产生良好的性能。两个条件是哪两个？

- ✅ 特征x包含足够的信息来精确地预测y。（例如，一个验证这一点的方法是，当只给x时，人类专家是否能够自信地预测y）。

- 我们训练一个具有少量参数的学习算法（因此不太可能过拟合）。

- ✅ 我们训练具有大量参数的学习算法（能够学习/表示相当复杂的函数）。

- 我们训练一个不使用正则化的模型。

### ③ 第 3 题

假设您已经训练了一个输出hθ(x)的逻辑回归分类器。 目前，如果hθ(x)≥threshold，则预测1， 如果hθ(x)≤threshold，则预测0，当前阈值设置为0.5。

假设您将阈值增加到0.9。以下哪项是正确的？选出所有正确项

- 现在分类器的精度可能更低。

- 分类器的准确度和召回率可能不变，但准确度较低。

- 分类器的准确度和召回率可能不变，但精度较高。

- ✅ 分类器现在可能具有较低的召回率。

假设您将阈值降低到0.3。以下哪项是正确的？选出所有正确项

- ✅ 分类器现在可能具有更高的召回率。

- 分类器的准确度和召回率可能不变，但精度较高。

- 分类器现在可能具有更高的精度。

- 分类器的准确度和召回率可能不变，但准确度较低。

> 💡 ![](https://gitee.com/veal98/images/raw/master/img/20200609160232.png)

### ④ 第 4 题

假设您正在使用垃圾邮件分类器，其中垃圾邮件是正例（y=1），非垃圾邮件是反例（y=0）。<u>您有一组电子邮件训练集，其中99%的电子邮件是非垃圾邮件，另1%是垃圾邮件</u>。以下哪项陈述是正确的？选出所有正确项

- 一个好的分类器应该在交叉验证集上同时具有高精度precision和高召回率recall。

- ✅ 如果您总是预测非垃圾邮件（输出y=0），那么您的分类器在训练集上的准确度accuracy将达到99%，而且它在交叉验证集上的性能可能类似。

- ✅ 如果您总是预测非垃圾邮件（输出y=0），那么您的分类器的准确度accuracy将达到99%。

- ✅ 如果您总是预测非垃圾邮件（输出y=0），那么您的分类器在训练集上的准确度accuracy将达到99%，但在交叉验证集上的准确率会更差，因为它过拟合训练数据。

- 如果总是预测垃圾邮件（输出y=1），则分类器的召回率recall为0%，精度precision为99%。

- ✅ 如果总是预测非垃圾邮件（输出y=0），则分类器的召回率recall为0%。

- ✅ 如果您总是预测垃圾邮件（输出y=1），那么您的分类器将具有召回率recall 100%和精度precision 1%。

- ✅ 如果您总是预测非垃圾邮件（输出y=0），那么您的分类器的准确度accuracy将达到99%。

### ⑤ 第 5 题

以下哪项陈述是正确的？选出所有正确项

- 在构建学习算法的第一个版本之前，花大量时间收集大量数据是一个好主意。
- ✅ 在倾斜的数据集上（例如，当有更多的正面例子而不是负面例子时），准确度不是一个很好的性能度量，您应该根据准确度和召回率使用F1分数。
- 训练完逻辑回归分类器后，必须使用0.5作为预测示例是正是负的阈值。
- ✅ 使用一个非常大的训练集使得模型不太可能过度拟合训练数据。
- 如果您的模型不适合训练集，那么获取更多数据可能会有帮助。



---

# 📚 References

- 🤖 [吴恩达机器学习经典名课【中英字幕】](https://www.bilibili.com/video/BV164411S78V?p=2)

- 💠 [黄海广 - 斯坦福大学2014机器学习教程中文笔记](http://www.ai-start.com/ml2014/)

- 🍧 [90题细品吴恩达《机器学习》，感受被刷题支配的恐惧](https://www.kesci.com/home/project/5e0f01282823a10036b280a7)

- 🥩 [吴恩达机器学习 课后实验 python实现](https://www.kesci.com/home/project/5da16a37037db3002d441810)

- 🍦 [吴恩达机器学习与深度学习作业目录](https://blog.csdn.net/Cowry5/article/details/83302646)

- 👘《周志华 - 机器学习》