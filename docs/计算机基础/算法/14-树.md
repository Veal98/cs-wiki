# ğŸŒ³ æ ‘

---

> ğŸ’¡ å…³äºæ ‘çš„åŸºæœ¬æ¦‚å¿µæ­¤å¤„å°±ä¸åšå™è¿°äº†ï¼Œå‚è§æ•°æ®ç»“æ„ç« èŠ‚

![](https://gitee.com/veal98/images/raw/master/img/20201118103034.png)

## 1. äºŒå‰æ ‘çš„éå†

```html
    1
   / \
  2   3
 / \   \
4   5   6
```

- å±‚æ¬¡éå†é¡ºåºï¼š[1 2 3 4 5 6]
- å‰åºéå†é¡ºåºï¼š[1 2 4 5 3 6]
- ä¸­åºéå†é¡ºåºï¼š[4 2 5 1 3 6]
- ååºéå†é¡ºåºï¼š[4 5 2 6 3 1]

**å…ˆä¸­åéå†å‡å€ŸåŠ©æ ˆåˆ©ç”¨ DFS å®ç°ï¼Œå±‚æ¬¡éå†å€ŸåŠ©é˜Ÿåˆ—ä½¿ç”¨ BFS å®ç°**

### â‘  å…ˆåºéå†

ğŸ‘‰ [144. äºŒå‰æ ‘çš„å‰åºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

**é€’å½’**

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    }
}
```

**éé€’å½’** 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // å­˜å‚¨èŠ‚ç‚¹éå†ç»“æœ
        Stack<TreeNode> stack = new Stack<>(); // åˆ©ç”¨æ ˆå®ç°å‰åºéå†
        TreeNode p = root; // å·¥ä½œæŒ‡é’ˆ
        
        while(p != null || !stack.isEmpty()){
            if(p != null){
                res.add(p.val);
                stack.push(p);
                p = p.left;
            }
            else{
                p = stack.pop();
                p = p.right;
            }
        }
        
        return res;
    }
}
```

### â‘¡ ä¸­åºéå†

ğŸ‘‰ [94. äºŒå‰æ ‘çš„ä¸­åºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**é€’å½’**

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}
```

**éé€’å½’**  

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode p = root; // å·¥ä½œæŒ‡é’ˆ
        
        while(p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                p = p.left;
            }
            else{
                p = stack.pop();
                res.add(p.val);
                p = p.right;
            }
        }
        
        return res;
    }
}
```

### â‘¢ ååºéå†

ğŸ‘‰ [145. äºŒå‰æ ‘çš„ååºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

**é€’å½’**

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```

**éé€’å½’**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode p = root; // å·¥ä½œæŒ‡é’ˆ
        TreeNode r = null; // æœ€è¿‘è®¿é—®è¿‡çš„èŠ‚ç‚¹
        
        while(p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                p = p.left;
            }
            else{
                p = stack.peek(); // è·å–æ ˆé¡¶å…ƒç´ 
                
                //å³å­©å­å­˜åœ¨ä¸”æœªè¢«è®¿é—®è¿‡,å°†å…¶å…¥æ ˆ
                if(p.right != null && r != p.right){
                    p = p.right;
                    stack.push(p);
                    p = p.left; // å†èµ°åˆ°æœ€å·¦
                }
                
                //è‹¥æ—¢æ— å·¦å­©å­ä¹Ÿæ— å³å­©å­ï¼Œåˆ™å¼¹å‡ºç»“ç‚¹å¹¶è®¿é—®
                else{ 
                    p = stack.pop();
                    res.add(p.val);
                    r = p; // è®¾ä¸ºæœ€è¿‘è®¿é—®èŠ‚ç‚¹
                    p = null; // p é‡ç½®(å³ç»§ç»­è·å–æ ˆé¡¶å…ƒç´ å¹¶å¯¹å…¶è¿›è¡Œåˆ¤æ–­)
                }
            }
        }
        return res;
    }
}
```

### â‘£ å±‚æ¬¡éå†

ğŸ‘‰ [äºŒå‰æ ‘çš„å±‚åºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 

åˆ©ç”¨é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºçš„ç‰¹æ€§ï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰ï¼š

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        
        if(root == null)
            return res;
        
        queue.offer(root); // é˜Ÿåˆ—å°¾éƒ¨æ·»åŠ å…ƒç´ ã€‚offer æ–¹æ³•åœ¨è¶…å‡ºé˜Ÿåˆ—ç•Œé™çš„æ—¶å€™ç›´æ¥è¿”å› false
        
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>(); // å­˜å‚¨æ¯ä¸ªå±‚çš„èŠ‚ç‚¹
            int currentLevelSize = queue.size();
            for (int i = 1; i <= currentLevelSize; ++i){
                TreeNode node = queue.poll();
                level.add(node.val);
                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            
            res.add(level);  
        }
        
        return res;
    }
}
```

## 2. äºŒå‰æ ‘çš„é€’å½’ç®—æ³•

ä¸€æ£µæ ‘è¦ä¹ˆæ˜¯ç©ºæ ‘ï¼Œè¦ä¹ˆæœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œæ¯ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€æ£µæ ‘ã€‚æ ‘æ˜¯ä¸€ç§é€’å½’ç»“æ„ï¼Œå¾ˆå¤šæ ‘çš„é—®é¢˜å¯ä»¥ä½¿ç”¨é€’å½’æ¥å¤„ç†ã€‚

### æ ‘çš„é«˜åº¦

ğŸ‘‰ [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ â€” Easy](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        if(root.left == null && root.right == null)
            return 1;
        
        int left = maxDepth(root.left); // å·¦å­æ ‘çš„é«˜åº¦
        int right = maxDepth(root.right); // å³å­æ ‘çš„é«˜åº¦
        
        return (left > right ? left : right) + 1;
    }
}
```

### å¹³è¡¡äºŒå‰æ ‘çš„åˆ¤å®š

ğŸ‘‰ [110. å¹³è¡¡äºŒå‰æ ‘ â€” Easy](https://leetcode-cn.com/problems/balanced-binary-tree/)

å¹³è¡¡äºŒå‰æ ‘çš„æ¯ä¸€ä¸ªç»“ç‚¹éƒ½æ˜¯å¹³è¡¡çš„(å·¦å³å­æ ‘é«˜åº¦å·®éƒ½å°äºç­‰äº 1)ã€‚

åˆ†åˆ«é€’å½’è®¡ç®—å·¦å­æ ‘å’Œå³å­æ ‘çš„é«˜åº¦ï¼Œç„¶åæ ¹æ®ä¸¤è€…é«˜åº¦å·®æ˜¯å¦å°äºç­‰äº 1 æ¥åˆ¤æ–­æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼ˆåªè¦æœ‰å…¶ä¸­æœ‰ä¸€å¯¹å·¦å³å­æ ‘ä¸æ»¡è¶³ï¼Œæ•´ä¸ªæ ‘å°±ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼‰ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    private boolean result = true;

    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return result;
    }

    public int maxDepth(TreeNode root) {
        if (root == null) 
            return 0;
        if(root.left == null && root.right == null)
            return 1;
        
        int left = maxDepth(root.left); // å·¦å­æ ‘çš„é«˜åº¦
        int right = maxDepth(root.right); // å³å­æ ‘çš„é«˜åº¦
        
        // åˆ¤æ–­å¹³è¡¡æ€§
        if (Math.abs(left - right) > 1) 
            result = false;
        
        return 1 + Math.max(left, right); 
    }
   
}
```

### äºŒå‰æ ‘çš„ç›´å¾„

ğŸ‘‰ [543. äºŒå‰æ ‘çš„ç›´å¾„ â€” Easy](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚

ç¤ºä¾‹ :

ç»™å®šäºŒå‰æ ‘

          1
         / \
        2   3
       / \     
      4   5    
è¿”å› 3, å®ƒçš„é•¿åº¦æ˜¯è·¯å¾„ [4,2,1,3] æˆ–è€… [5,2,1,3]ã€‚

ã€æ€è·¯ã€‘ï¼šç”±é¢˜æ„ï¼Œç›´å¾„å°±æ˜¯äºŒå‰æ ‘çš„å·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦ç›¸åŠ 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    private int maxDiam = 0; // æœ€å¤§ç›´å¾„
    
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return maxDiam;
    }
    
    private int maxDepth(TreeNode root){
        if(root == null)
            return 0;
        if(root.left == null && root.right == null)
            return 1;
        
        int left = maxDepth(root.left); // å·¦å­æ ‘çš„é«˜åº¦
        int right = maxDepth(root.right); // å³å­æ ‘çš„é«˜åº¦
        
        // æ›´æ–°æœ€å¤§ç›´å¾„
        maxDiam = Math.max(maxDiam, left + right);
        
        return 1 + Math.max(left, right); // æ•´æ£µæ ‘çš„é«˜åº¦
    }
}
```

### ç¿»è½¬äºŒå‰æ ‘

ğŸ‘‰ [226. ç¿»è½¬äºŒå‰æ ‘ â€” Easy](https://leetcode-cn.com/problems/invert-binary-tree/)

ç¤ºä¾‹ï¼š

```
è¾“å…¥ï¼š
     4
   /   \
  2     7
 / \   / \
1   3 6   9

è¾“å‡ºï¼š
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

å³äº¤æ¢äºŒå‰æ ‘çš„å·¦å³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹

ã€æ€è·¯ã€‘ï¼šå…ˆäº¤æ¢å·¦å³å­©å­çš„å·¦å³å­æ ‘ï¼Œå†äº¤æ¢å·¦å³å­©å­

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null)
            return null;
        
        // å…ˆäº¤æ¢å·¦å³å­©å­çš„å·¦å³å­æ ‘
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        // å†äº¤æ¢å·¦å³å­©å­
        root.left = right;
        root.right = left;
        
        return root;
        
    }
}
```

### åˆå¹¶äºŒå‰æ ‘

ğŸ‘‰ [617. åˆå¹¶äºŒå‰æ ‘ â€” Easy](https://leetcode-cn.com/problems/merge-two-binary-trees/)

ç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œæƒ³è±¡å½“ä½ å°†å®ƒä»¬ä¸­çš„ä¸€ä¸ªè¦†ç›–åˆ°å¦ä¸€ä¸ªä¸Šæ—¶ï¼Œä¸¤ä¸ªäºŒå‰æ ‘çš„ä¸€äº›èŠ‚ç‚¹ä¾¿ä¼šé‡å ã€‚

ä½ éœ€è¦å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚**åˆå¹¶çš„è§„åˆ™æ˜¯å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†ä»–ä»¬çš„å€¼ç›¸åŠ ä½œä¸ºèŠ‚ç‚¹åˆå¹¶åçš„æ–°å€¼ï¼Œå¦åˆ™ä¸ä¸º NULL çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹**ã€‚

ç¤ºä¾‹ 1:

```
è¾“å…¥: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  

è¾“å‡º: 
åˆå¹¶åçš„æ ‘:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if(t1 == null)
            return t2;
        if(t2 == null)
            return t1;
        
        TreeNode t3 = new TreeNode(t1.val + t2.val);
        t3.left = mergeTrees(t1.left, t2.left);
        t3.right = mergeTrees(t1.right, t2.right);

        return t3;
    }
}
```

### åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°

ğŸ‘‰ [112. è·¯å¾„æ€»å’Œ â€” Easy](https://leetcode-cn.com/problems/path-sum/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œä¸€ä¸ªç›®æ ‡å’Œï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œã€‚

ç¤ºä¾‹: 

ç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ sum = 22ï¼Œ

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
è¿”å› true, å› ä¸ºå­˜åœ¨ç›®æ ‡å’Œä¸º 22 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ 5->4->11->2ã€‚

ã€æ€è·¯ã€‘ï¼š<u>è‹¥å½“å‰èŠ‚ç‚¹å°±æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥åˆ¤æ–­ sum æ˜¯å¦ç­‰äº val å³å¯ï¼ˆå› ä¸ºè·¯å¾„å’Œå·²ç»ç¡®å®šï¼Œå°±æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­è¯¥è·¯å¾„å’Œæ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼‰ã€‚è‹¥å½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªéœ€è¦é€’å½’åœ°è¯¢é—®å®ƒçš„å­èŠ‚ç‚¹æ˜¯å¦èƒ½æ»¡è¶³æ¡ä»¶å³å¯ã€‚</u>

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)
            return false;
        if(root.left == null && root.right == null)
            return root.val == sum;
        
        return hasPathSum(root.left, sum-root.val) ||
               hasPathSum(root.right, sum-root.val);
    }
}
```

### ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡

ğŸ‘‰ [437. è·¯å¾„æ€»å’Œ III â€” Medium](https://leetcode-cn.com/problems/path-sum-iii/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªç»“ç‚¹éƒ½å­˜æ”¾ç€ä¸€ä¸ªæ•´æ•°å€¼ã€‚

æ‰¾å‡ºè·¯å¾„å’Œç­‰äºç»™å®šæ•°å€¼çš„è·¯å¾„æ€»æ•°ã€‚

**è·¯å¾„ä¸éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦åœ¨å¶å­èŠ‚ç‚¹ç»“æŸï¼Œä½†æ˜¯è·¯å¾„æ–¹å‘å¿…é¡»æ˜¯å‘ä¸‹çš„ï¼ˆåªèƒ½ä»çˆ¶èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹ï¼‰ã€‚**

äºŒå‰æ ‘ä¸è¶…è¿‡1000ä¸ªèŠ‚ç‚¹ï¼Œä¸”èŠ‚ç‚¹æ•°å€¼èŒƒå›´æ˜¯ [-1000000,1000000] çš„æ•´æ•°ã€‚

ç¤ºä¾‹ï¼š

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

è¿”å› 3ã€‚å’Œç­‰äº 8 çš„è·¯å¾„æœ‰:

1. 5 -> 3

2. 5 -> 2 -> 1

3. -3 -> 11
```

ã€æ€è·¯ã€‘ï¼šæˆ‘ä»¬åªéœ€è¦å»æ±‚ä¸‰éƒ¨åˆ†å³å¯ï¼š

- ä»¥å½“å‰èŠ‚ç‚¹ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡
- ä»¥å½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡
- ä»¥å½“å‰èŠ‚ç‚¹çš„å³å­©å­ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡

å°†è¿™ä¸‰éƒ¨åˆ†ä¹‹å’Œä½œä¸ºæœ€åç»“æœå³å¯ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    public int pathSum(TreeNode root, int sum) {
        if(root == null)
            return 0;
        
        return PathSumWithRoot(root, sum) 
            + pathSum(root.left, sum)
            + pathSum(root.right, sum);
    }
    
    // ä»¥å½“å‰èŠ‚ç‚¹ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡
    private int PathSumWithRoot(TreeNode root, int sum){
        if(root == null)
            return 0;
        
        int res = 0;
        
        if(root.val == sum)
            res ++;
        
        res += PathSumWithRoot(root.left, sum-root.val)
            + PathSumWithRoot(root.right, sum-root.val);
        
        return res;
    }
}
```

## âœ LeetCode æ±‡æ€» â€” æ ‘

**ã€äºŒå‰æ ‘çš„éå†ã€‘**ï¼š

|                            ğŸ¯ é¢˜è§£                            | ğŸ² éš¾åº¦ |
| :----------------------------------------------------------: | :----: |
| [144 - äºŒå‰æ ‘çš„å‰åºéå†](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/144-äºŒå‰æ ‘çš„å‰åºéå†.md) |   ğŸ‘»    |
| [94 - äºŒå‰æ ‘çš„ä¸­åºéå†](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/94-äºŒå‰æ ‘çš„ä¸­åºéå†.md) |   ğŸ‘»    |
| [145 - äºŒå‰æ ‘çš„ååºéå†](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/145-äºŒå‰æ ‘çš„ååºéå†.md) |   ğŸ‘»    |
| [102 - äºŒå‰æ ‘çš„å±‚åºéå†](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/102-äºŒå‰æ ‘çš„å±‚åºéå†.md) |   ğŸ‘»    |

**ã€äºŒå‰æ ‘çš„ç›¸å…³é€’å½’ç®—æ³•ã€‘**ï¼š

|                            ğŸ¯ é¢˜è§£                            | ğŸ² éš¾åº¦ |
| :----------------------------------------------------------: | :----: |
| [104 - äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/104-äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦.md) |   ğŸ˜    |
| [110 - å¹³è¡¡äºŒå‰æ ‘](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/110-å¹³è¡¡äºŒå‰æ ‘.md) |   ğŸ˜    |
| [543 - äºŒå‰æ ‘çš„ç›´å¾„](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/543-äºŒå‰æ ‘çš„ç›´å¾„.md) |   ğŸ˜    |
| [226 - ç¿»è½¬äºŒå‰æ ‘](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/226-ç¿»è½¬äºŒå‰æ ‘.md) |   ğŸ˜    |
| [617 - åˆå¹¶äºŒå‰æ ‘](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/617-åˆå¹¶äºŒå‰æ ‘.md) |   ğŸ˜    |
| [112 - è·¯å¾„æ€»å’Œ](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/112-è·¯å¾„æ€»å’Œ.md) |   ğŸ˜    |
| [437 - è·¯å¾„æ€»å’Œ III](è®¡ç®—æœºåŸºç¡€/ç®—æ³•/LeetCode/æ ‘/437-è·¯å¾„æ€»å’ŒIII.md) |   ğŸ‘»    |