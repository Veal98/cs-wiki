# 	ğŸŒ³ æ ‘

---

## 1. åŸºæœ¬æ¦‚å¿µ

- äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æŸ¥æ‰¾æ ‘ï¼‰
- å¹³è¡¡äºŒå‰æ ‘
- å®Œå…¨äºŒå‰æ ‘
- å“ˆå¤«æ›¼æ ‘
- çº¢é»‘æ ‘

![](https://gitee.com/veal98/images/raw/master/img/20201118103034.png)

## 2. äºŒå‰æ ‘çš„éå†

```html
    1
   / \
  2   3
 / \   \
4   5   6
```

- å±‚æ¬¡éå†é¡ºåºï¼š[1 2 3 4 5 6]
- å‰åºéå†é¡ºåºï¼š[1 2 4 5 3 6]
- ä¸­åºéå†é¡ºåºï¼š[4 2 5 1 3 6]
- ååºéå†é¡ºåºï¼š[4 5 2 6 3 1]

**å…ˆä¸­åéå†å‡å€ŸåŠ©æ ˆåˆ©ç”¨ DFS å®ç°ï¼Œå±‚æ¬¡éå†å€ŸåŠ©é˜Ÿåˆ—ä½¿ç”¨ BFS å®ç°**

### 144. å…ˆåºéå†

ğŸ‘‰ [144. äºŒå‰æ ‘çš„å‰åºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

**é€’å½’**

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    }
}
```

**éé€’å½’** 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // å­˜å‚¨èŠ‚ç‚¹éå†ç»“æœ
        Stack<TreeNode> stack = new Stack<>(); // åˆ©ç”¨æ ˆå®ç°å‰åºéå†
        TreeNode p = root; // å·¥ä½œæŒ‡é’ˆ
        
        while(p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                res.add(p.val);
                p = p.left;
            }
            else{
                p = stack.pop();
                p = p.right;
            }
        }
        
        return res;
    }
}
```

### 94. ä¸­åºéå†

ğŸ‘‰ [94. äºŒå‰æ ‘çš„ä¸­åºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**é€’å½’**

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}
```

**éé€’å½’**  

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode p = root; // å·¥ä½œæŒ‡é’ˆ
        
        while(p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                p = p.left;
            }
            else{
                p = stack.pop();
                res.add(p.val);
                p = p.right;
            }
        }
        
        return res;
    }
}
```

### 145. ååºéå†

ğŸ‘‰ [145. äºŒå‰æ ‘çš„ååºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

**é€’å½’**

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```

**éé€’å½’**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode p = root; // å·¥ä½œæŒ‡é’ˆ
        TreeNode r = null; // æœ€è¿‘è®¿é—®è¿‡çš„èŠ‚ç‚¹
        
        while(p != null || !stack.isEmpty()){
            if(p != null){
                stack.push(p);
                p = p.left;
            }
            else{
                p = stack.peek(); // è·å–æ ˆé¡¶å…ƒç´ 
                
                //å³å­©å­å­˜åœ¨ä¸”æœªè¢«è®¿é—®è¿‡,å°†å…¶å…¥æ ˆ
                if(p.right != null && r != p.right){
                    p = p.right;
                    stack.push(p);
                    p = p.left; // å†èµ°åˆ°æœ€å·¦
                }
                
                //è‹¥æ—¢æ— å·¦å­©å­ä¹Ÿæ— å³å­©å­ï¼Œåˆ™å¼¹å‡ºç»“ç‚¹å¹¶è®¿é—®
                else{ 
                    p = stack.pop();
                    res.add(p.val);
                    r = p; // è®¾ä¸ºæœ€è¿‘è®¿é—®èŠ‚ç‚¹
                    p = null; // p é‡ç½®(å³ç»§ç»­è·å–æ ˆé¡¶å…ƒç´ å¹¶å¯¹å…¶è¿›è¡Œåˆ¤æ–­)
                }
            }
        }
        return res;
    }
}
```

### 102. å±‚æ¬¡éå†

ğŸ‘‰ [102. äºŒå‰æ ‘çš„å±‚åºéå† â€” Medium](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 

[å‰‘æŒ‡ Offer 32 - II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II â€” Easy](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

åˆ©ç”¨é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºçš„ç‰¹æ€§ï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰ï¼š

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        
        if(root == null)
            return res;
        
        queue.offer(root); // é˜Ÿåˆ—å°¾éƒ¨æ·»åŠ å…ƒç´ ã€‚offer æ–¹æ³•åœ¨è¶…å‡ºé˜Ÿåˆ—ç•Œé™çš„æ—¶å€™ç›´æ¥è¿”å› false
        
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>(); // å­˜å‚¨æ¯ä¸ªå±‚çš„èŠ‚ç‚¹
            int currentLevelSize = queue.size();
            for (int i = 1; i <= currentLevelSize; ++i){
                TreeNode node = queue.poll();
                level.add(node.val);
                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            
            res.add(level);  
        }
        
        return res;
    }
}
```

### 199. äºŒå‰æ ‘çš„å³è§†å›¾

[199. äºŒå‰æ ‘çš„å³è§†å›¾ â€” Medium](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

ã€é¢˜ç›®æè¿°ã€‘ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚

ç¤ºä¾‹:

```
è¾“å…¥: [1,2,3,null,5,null,4]
è¾“å‡º: [1, 3, 4]
è§£é‡Š:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

ã€è§£é¢˜æ€è·¯ã€‘å°±æ˜¯å±‚æ¬¡éå†ï¼Œåªä¸è¿‡è®°å½•ä¸‹æ¯å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ç½¢äº†ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView (TreeNode root) {
        List<Integer> res = new ArrayList<>(); // å­˜å‚¨ç»“æœ
        
        if (root == null) {
            return res;
        }
        
        Queue<TreeNode> queue = new LinkedList<>(); // é˜Ÿåˆ—
        
        queue.offer(root); // æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
        
        while (!queue.isEmpty()) {
            int size = queue.size(); // æ¯å±‚èŠ‚ç‚¹çš„ä¸ªæ•°
            List<Integer> line = new ArrayList<>(); // å­˜å‚¨æ¯å±‚èŠ‚ç‚¹
            for (int i = 0; i < size; i ++) {
                TreeNode node = queue.poll(); // å–å‡ºé˜Ÿå¤´èŠ‚ç‚¹
                line.add(node.val);
                
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                
            }
            // æ¯å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
            res.add(line.get(size-1));
        }
        
        return res;
    }
}
```

### å‰‘æŒ‡ Offer 32 - III. ä¹‹å­—å‹æ‰“å°äºŒå‰æ ‘

[å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

ã€é¢˜ç›®æè¿°ã€‘è¯·å®ç°ä¸€ä¸ªå‡½æ•°æŒ‰ç…§ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘ï¼Œå³ç¬¬ä¸€è¡ŒæŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œç¬¬äºŒå±‚æŒ‰ç…§ä»å³åˆ°å·¦çš„é¡ºåºæ‰“å°ï¼Œç¬¬ä¸‰è¡Œå†æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œå…¶ä»–è¡Œä»¥æ­¤ç±»æ¨ã€‚

 ä¾‹å¦‚:

```
ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
è¿”å›å…¶å±‚æ¬¡éå†ç»“æœï¼š
[
  [3],
  [20,9],
  [15,7]
]
```

ã€è§£é¢˜æ€è·¯ã€‘ç›´æ¥å±‚æ¬¡éå†ï¼Œåªä¸è¿‡æ˜¯åœ¨å¥‡æ•°å¶æ•°è¡Œå…ƒç´ çš„æ’å…¥é¡ºåºä¸ä¸€æ ·ã€‚å¯ä»¥ä½¿ç”¨ LinkedList åŒå‘é“¾è¡¨å­˜å‚¨æ¯è¡Œæ•°æ®ï¼Œæ—¢èƒ½åœ¨å¤´éƒ¨æ·»åŠ ä¹Ÿèƒ½åœ¨å°¾éƒ¨æ·»åŠ 

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // é˜Ÿåˆ—
        Queue<TreeNode> queue = new LinkedList<>();
        
        // å­˜å‚¨æœ€ç»ˆç»“æœ
        List<List<Integer>> res = new ArrayList<>();
        
        if(root == null) {
            return res;
        }
        
        // æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
        queue.add(root);
        
        int height = 1;
        
        while(!queue.isEmpty()) {
            // åŒå‘é“¾è¡¨å­˜å‚¨æ¯è¡Œæ•°æ®ï¼Œæ—¢èƒ½åœ¨å¤´éƒ¨æ·»åŠ ä¹Ÿèƒ½åœ¨å°¾éƒ¨æ·»åŠ 
            LinkedList<Integer> line = new LinkedList<>();
            int size = queue.size();
            
            for(int i = 0; i < size; i ++) {
                TreeNode node = queue.poll();
                // å¥‡æ•°è¡Œ
                if(height % 2 != 0) 
                    line.addLast(node.val);
                // å¶æ•°è¡Œ
                else 
                    line.addFirst(node.val);
                
                // å­©å­èŠ‚ç‚¹å…¨éƒ¨å…¥é˜Ÿ
                if(node.left != null) 
                    queue.add(node.left);
                if(node.right != null) 
                    queue.add(node.right);
            }
            res.add(line);
            height ++;
        }
        return res;
    }
}
```

### å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬ k å¤§èŠ‚ç‚¹

ğŸ‘‰ [å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬ k å¤§èŠ‚ç‚¹ â€” Easy](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

ã€é¢˜ç›®æè¿°ã€‘ç»™å®šä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œè¯·æ‰¾å‡ºå…¶ä¸­ç¬¬kå¤§çš„èŠ‚ç‚¹ã€‚

ç¤ºä¾‹ 1:

```
è¾“å…¥: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
è¾“å‡º: 4
```


ç¤ºä¾‹ 2:

```
è¾“å…¥: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
è¾“å‡º: 4
```

ã€è§£é¢˜æ€è·¯ã€‘ä¸­åºéå†ï¼ˆå·¦æ ¹å³ï¼‰çš„ç»“æœå°±æ˜¯å‡åºæ’åºï¼Œé‚£ä¹ˆé€†ä¸­åºéå†ï¼ˆå³å·¦æ ¹ï¼‰çš„ç»“æœå°±æ˜¯é™åºæ’åºï¼Œç¬¬ k å¤§çš„å…ƒç´ å°±æ˜¯é€†ä¸­åºéå†ç»“æœçš„ç¬¬ k ä¸ªæ•°ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthLargest(TreeNode root, int k) {
        List<TreeNode> res = new ArrayList<>();
        inorderTree(root, k, res);
        return res.get(res.size()-1).val;
    }
    
    // é€†ä¸­åºéå†
    private void inorderTree(TreeNode root, int k, List<TreeNode> res) {
        if (root == null) {
            return ;
        }
        
        inorderTree(root.right, k, res);
        
        if (res.size() != k) {
            res.add(root);
        }
        
        inorderTree(root.left, k, res);
    }
}
```

### å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨

[å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨ â€” Medium](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

ã€é¢˜ç›®æè¿°ã€‘è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„å¾ªç¯åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„èŠ‚ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­èŠ‚ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚

ä¸ºäº†è®©æ‚¨æ›´å¥½åœ°ç†è§£é—®é¢˜ï¼Œä»¥ä¸‹é¢çš„äºŒå‰æœç´¢æ ‘ä¸ºä¾‹ï¼š

 ![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

 

æˆ‘ä»¬å¸Œæœ›å°†è¿™ä¸ªäºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºåŒå‘å¾ªç¯é“¾è¡¨ã€‚é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå‰é©±å’Œåç»§æŒ‡é’ˆã€‚å¯¹äºåŒå‘å¾ªç¯é“¾è¡¨ï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å‰é©±æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åç»§æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚

ä¸‹å›¾å±•ç¤ºäº†ä¸Šé¢çš„äºŒå‰æœç´¢æ ‘è½¬åŒ–æˆçš„é“¾è¡¨ã€‚â€œheadâ€ è¡¨ç¤ºæŒ‡å‘é“¾è¡¨ä¸­æœ‰æœ€å°å…ƒç´ çš„èŠ‚ç‚¹ã€‚

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)

ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥å°±åœ°å®Œæˆè½¬æ¢æ“ä½œã€‚å½“è½¬åŒ–å®Œæˆä»¥åï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆéœ€è¦æŒ‡å‘å‰é©±ï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å³æŒ‡é’ˆéœ€è¦æŒ‡å‘åç»§ã€‚è¿˜éœ€è¦è¿”å›é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚

ã€è§£é¢˜æ€è·¯ã€‘è¦æŠŠä¸€ä¸ªäºŒå‰æ ‘è½¬æ¢æˆæœ‰åºçš„ï¼Œé‚£æ˜¾ç„¶éœ€è¦ä¸­åºéå†ï¼Œå› ä¸ºä¸­åºéå†çš„ç»“æœå°±æ˜¯å‡åºçš„ã€‚æˆ‘ä»¬æŠŠä¸­åºéå†çš„ç»“æœå­˜åˆ°é˜Ÿåˆ—ä¸­ï¼Œç„¶åä»é˜Ÿåˆ—ä¸­ä¾æ¬¡å–å‡ºè¿™äº›å…ƒç´ ç»„æˆå¾ªç¯åŒé“¾è¡¨å°±è¡Œäº†ã€‚

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    public Node treeToDoublyList(Node root) {
        if (root == null) {
            return null;
        }
        
        // ä»é˜Ÿåˆ—ä¸­ä¾æ¬¡å–å‡ºèŠ‚ç‚¹ï¼Œæ„å»ºå¾ªç¯åŒé“¾è¡¨
        Queue<Node> queue = new LinkedList<>();
        queue = inorder(root);
        
       
        Node head = queue.poll(); // é“¾è¡¨å¤´
        Node pre = head; // å‰ç½®èŠ‚ç‚¹
        Node cur = head; // å·¥ä½œæŒ‡é’ˆ
            
        while (!queue.isEmpty()) {
            cur = queue.poll();
            cur.left = pre;
            pre.right = cur;
            pre = cur;
        }
        
        // æˆç¯
        head.left = pre;
        pre.right = head;

        
        return head;
    }
    
    // éé€’å½’ä¸­åºéå†(å°†ä¸­åºéå†ç»“æœæ”¾å…¥é˜Ÿåˆ—ä¸­)
    private Queue<Node> inorder(Node root) {
        
        Queue<Node> res = new LinkedList<>();
        
        if (root == null) {
            return res;
        }
        
        Stack<Node> stack = new Stack<>(); // æ ˆ
        
        Node p = root;
        
        while (p != null || !stack.isEmpty()) {
            if (p != null) {
                stack.push(p);
                p = p.left;
            }
            else {
                p = stack.pop();
                res.offer(p);
                p = p.right;
            }
        }
        
        return res;
        
    }
}
```



## 3. äºŒå‰æ ‘çš„é€’å½’ç®—æ³•

ä¸€æ£µæ ‘è¦ä¹ˆæ˜¯ç©ºæ ‘ï¼Œè¦ä¹ˆæœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œæ¯ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€æ£µæ ‘ã€‚æ ‘æ˜¯ä¸€ç§é€’å½’ç»“æ„ï¼Œå¾ˆå¤šæ ‘çš„é—®é¢˜å¯ä»¥ä½¿ç”¨é€’å½’æ¥å¤„ç†ã€‚

### 104. æ ‘çš„é«˜åº¦/æ·±åº¦

ğŸ‘‰ [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ â€” Easy](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

ğŸ‘‰ [å‰‘æŒ‡ Offer 55 - I. äºŒå‰æ ‘çš„æ·±åº¦ â€” Easy](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        if(root.left == null && root.right == null)
            return 1;
        
        int left = maxDepth(root.left); // å·¦å­æ ‘çš„é«˜åº¦
        int right = maxDepth(root.right); // å³å­æ ‘çš„é«˜åº¦
        
        return (left > right ? left : right) + 1;
    }
}
```

### 110. å¹³è¡¡äºŒå‰æ ‘çš„åˆ¤å®š

ğŸ‘‰ [110. å¹³è¡¡äºŒå‰æ ‘ â€” Easy](https://leetcode-cn.com/problems/balanced-binary-tree/)

å¹³è¡¡äºŒå‰æ ‘çš„æ¯ä¸€ä¸ªç»“ç‚¹éƒ½æ˜¯å¹³è¡¡çš„(å·¦å³å­æ ‘é«˜åº¦å·®éƒ½å°äºç­‰äº 1)ã€‚

åˆ†åˆ«é€’å½’è®¡ç®—å·¦å­æ ‘å’Œå³å­æ ‘çš„é«˜åº¦ï¼Œç„¶åæ ¹æ®ä¸¤è€…é«˜åº¦å·®æ˜¯å¦å°äºç­‰äº 1 æ¥åˆ¤æ–­æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼ˆåªè¦æœ‰å…¶ä¸­æœ‰ä¸€å¯¹å·¦å³å­æ ‘ä¸æ»¡è¶³ï¼Œæ•´ä¸ªæ ‘å°±ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼‰ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    private boolean result = true;

    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return result;
    }

    public int maxDepth(TreeNode root) {
        if (root == null) 
            return 0;
        if(root.left == null && root.right == null)
            return 1;
        
        int left = maxDepth(root.left); // å·¦å­æ ‘çš„é«˜åº¦
        int right = maxDepth(root.right); // å³å­æ ‘çš„é«˜åº¦
        
        // åˆ¤æ–­å¹³è¡¡æ€§
        if (Math.abs(left - right) > 1) 
            result = false;
        
        return 1 + Math.max(left, right); 
    }
   
}
```

### 543. äºŒå‰æ ‘çš„ç›´å¾„

ğŸ‘‰ [543. äºŒå‰æ ‘çš„ç›´å¾„ â€” Easy](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚

ç¤ºä¾‹ :

ç»™å®šäºŒå‰æ ‘

          1
         / \
        2   3
       / \     
      4   5    
è¿”å› 3, å®ƒçš„é•¿åº¦æ˜¯è·¯å¾„ [4,2,1,3] æˆ–è€… [5,2,1,3]ã€‚

ã€æ€è·¯ã€‘ï¼šç”±é¢˜æ„ï¼Œç›´å¾„å°±æ˜¯äºŒå‰æ ‘çš„å·¦å³å­æ ‘çš„æœ€å¤§é«˜åº¦ç›¸åŠ 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    private int maxDiam = 0; // æœ€å¤§ç›´å¾„
    
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return maxDiam;
    }
    
    private int maxDepth(TreeNode root){
        if(root == null)
            return 0;
        if(root.left == null && root.right == null)
            return 1;
        
        int left = maxDepth(root.left); // å·¦å­æ ‘çš„é«˜åº¦
        int right = maxDepth(root.right); // å³å­æ ‘çš„é«˜åº¦
        
        // æ›´æ–°æœ€å¤§ç›´å¾„
        maxDiam = Math.max(maxDiam, left + right);
        
        return 1 + Math.max(left, right); // æ•´æ£µæ ‘çš„é«˜åº¦
    }
}
```

### 226. ç¿»è½¬/é•œåƒäºŒå‰æ ‘

ğŸ‘‰ [226. ç¿»è½¬äºŒå‰æ ‘ â€” Easy](https://leetcode-cn.com/problems/invert-binary-tree/)

ğŸ‘‰ [å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ â€” Easy](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

ç¤ºä¾‹ï¼š

```
è¾“å…¥ï¼š
     4
   /   \
  2     7
 / \   / \
1   3 6   9

è¾“å‡ºï¼š
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

å³äº¤æ¢äºŒå‰æ ‘çš„å·¦å³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹

ã€æ€è·¯ã€‘ï¼šå…ˆäº¤æ¢å·¦å³å­©å­çš„å·¦å³å­æ ‘ï¼Œå†äº¤æ¢å·¦å³å­©å­

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null)
            return null;
        
        if (root.left == null && root.right == null) {
            return root;
        }
        
        // å…ˆäº¤æ¢å·¦å³å­©å­çš„å·¦å³å­æ ‘
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        // å†äº¤æ¢å·¦å³å­©å­
        root.left = right;
        root.right = left;
        
        return root;
        
    }
}
```

### 101. å¯¹ç§°äºŒå‰æ ‘

ã€é¢˜ç›®æè¿°ã€‘ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚

ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

```
    1
   / \
  2   2
   \   \
   3    3
```

ã€è§£é¢˜æ€è·¯ã€‘é€’å½’

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return isSymmetric(root.left, root.right);
    }
    
    private boolean isSymmetric(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) {
            return true;
        }
        if (root1 == null || root2 == null) {
            return false;
        }
        return root1.val == root2.val && 
               isSymmetric(root1.left, root2.right) &&
               isSymmetric(root1.right, root2.left);
    }
}
```



### 617. åˆå¹¶äºŒå‰æ ‘

ğŸ‘‰ [617. åˆå¹¶äºŒå‰æ ‘ â€” Easy](https://leetcode-cn.com/problems/merge-two-binary-trees/)

ç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œæƒ³è±¡å½“ä½ å°†å®ƒä»¬ä¸­çš„ä¸€ä¸ªè¦†ç›–åˆ°å¦ä¸€ä¸ªä¸Šæ—¶ï¼Œä¸¤ä¸ªäºŒå‰æ ‘çš„ä¸€äº›èŠ‚ç‚¹ä¾¿ä¼šé‡å ã€‚

ä½ éœ€è¦å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚**åˆå¹¶çš„è§„åˆ™æ˜¯å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†ä»–ä»¬çš„å€¼ç›¸åŠ ä½œä¸ºèŠ‚ç‚¹åˆå¹¶åçš„æ–°å€¼ï¼Œå¦åˆ™ä¸ä¸º NULL çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹**ã€‚

ç¤ºä¾‹ 1:

```
è¾“å…¥: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  

è¾“å‡º: 
åˆå¹¶åçš„æ ‘:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if(t1 == null)
            return t2;
        if(t2 == null)
            return t1;
        
        TreeNode t3 = new TreeNode(t1.val + t2.val);
        t3.left = mergeTrees(t1.left, t2.left);
        t3.right = mergeTrees(t1.right, t2.right);

        return t3;
    }
}
```

### 112. åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°

ğŸ‘‰ [112. è·¯å¾„æ€»å’Œ â€” Easy](https://leetcode-cn.com/problems/path-sum/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œä¸€ä¸ªç›®æ ‡å’Œï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œã€‚

ç¤ºä¾‹: 

ç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ sum = 22ï¼Œ

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
è¿”å› true, å› ä¸ºå­˜åœ¨ç›®æ ‡å’Œä¸º 22 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ 5->4->11->2ã€‚

ã€æ€è·¯ã€‘ï¼š<u>è‹¥å½“å‰èŠ‚ç‚¹å°±æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥åˆ¤æ–­ sum æ˜¯å¦ç­‰äº val å³å¯ï¼ˆå› ä¸ºè·¯å¾„å’Œå·²ç»ç¡®å®šï¼Œå°±æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­è¯¥è·¯å¾„å’Œæ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼‰ã€‚è‹¥å½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªéœ€è¦é€’å½’åœ°è¯¢é—®å®ƒçš„å­èŠ‚ç‚¹æ˜¯å¦èƒ½æ»¡è¶³æ¡ä»¶å³å¯ã€‚</u>

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)
            return false;
        if(root.left == null && root.right == null)
            return root.val == sum;
        
        return hasPathSum(root.left, sum-root.val) ||
               hasPathSum(root.right, sum-root.val);
    }
}
```

### 437. ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡

ğŸ‘‰ [437. è·¯å¾„æ€»å’Œ III â€” Medium](https://leetcode-cn.com/problems/path-sum-iii/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªç»“ç‚¹éƒ½å­˜æ”¾ç€ä¸€ä¸ªæ•´æ•°å€¼ã€‚

æ‰¾å‡ºè·¯å¾„å’Œç­‰äºç»™å®šæ•°å€¼çš„è·¯å¾„æ€»æ•°ã€‚

**è·¯å¾„ä¸éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦åœ¨å¶å­èŠ‚ç‚¹ç»“æŸï¼Œä½†æ˜¯è·¯å¾„æ–¹å‘å¿…é¡»æ˜¯å‘ä¸‹çš„ï¼ˆåªèƒ½ä»çˆ¶èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹ï¼‰ã€‚**

äºŒå‰æ ‘ä¸è¶…è¿‡1000ä¸ªèŠ‚ç‚¹ï¼Œä¸”èŠ‚ç‚¹æ•°å€¼èŒƒå›´æ˜¯ [-1000000,1000000] çš„æ•´æ•°ã€‚

ç¤ºä¾‹ï¼š

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

è¿”å› 3ã€‚å’Œç­‰äº 8 çš„è·¯å¾„æœ‰:

1. 5 -> 3

2. 5 -> 2 -> 1

3. -3 -> 11
```

ã€æ€è·¯ã€‘ï¼šæˆ‘ä»¬åªéœ€è¦å»æ±‚ä¸‰éƒ¨åˆ†å³å¯ï¼š

- ä»¥å½“å‰èŠ‚ç‚¹ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡
- ä»¥å½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡
- ä»¥å½“å‰èŠ‚ç‚¹çš„å³å­©å­ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡

å°†è¿™ä¸‰éƒ¨åˆ†ä¹‹å’Œä½œä¸ºæœ€åç»“æœå³å¯ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    public int pathSum(TreeNode root, int sum) {
        if(root == null)
            return 0;
        
        return PathSumWithRoot(root, sum) 
            + pathSum(root.left, sum)
            + pathSum(root.right, sum);
    }
    
    // ä»¥å½“å‰èŠ‚ç‚¹ä½œä¸ºå¤´ç»“ç‚¹çš„è·¯å¾„æ•°é‡
    private int PathSumWithRoot(TreeNode root, int sum){
        if(root == null)
            return 0;
        
        int res = 0;
        
        if(root.val == sum)
            res ++;
        
        res += PathSumWithRoot(root.left, sum-root.val)
            + PathSumWithRoot(root.right, sum-root.val);
        
        return res;
    }
}
```

### 572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘

ğŸ‘‰ [572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘ â€” Easy](https://leetcode-cn.com/problems/subtree-of-another-tree/)

**ã€é¢˜ç›®æè¿°ã€‘**ï¼šç»™å®šä¸¤ä¸ªéç©ºäºŒå‰æ ‘ s å’Œ tï¼Œæ£€éªŒ s ä¸­æ˜¯å¦åŒ…å«å’Œ t å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚s çš„ä¸€ä¸ªå­æ ‘åŒ…æ‹¬ s çš„ä¸€ä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­å­™ã€‚s ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚

ç¤ºä¾‹ 1:

```
ç»™å®šçš„æ ‘ s:
     3
    / \
   4   5
  / \
 1   2
 
ç»™å®šçš„æ ‘ tï¼š
   4 
  / \
 1   2
 
è¿”å› trueï¼Œå› ä¸º t ä¸ s çš„ä¸€ä¸ªå­æ ‘æ‹¥æœ‰ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚
```

ç¤ºä¾‹ 2:

```
ç»™å®šçš„æ ‘ sï¼š
     3
    / \
   4   5
  / \
 1   2
    /
   0
   
ç»™å®šçš„æ ‘ tï¼š
   4
  / \
 1   2
 
è¿”å› falseã€‚
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼šä¸¤æ£µæ ‘å®Œå…¨ç›¸åŒä¹Ÿå¯ä»¥çœ‹åšä¸€æ£µæ ‘æ˜¯å¦ä¸€æ£µæ ‘çš„å­æ ‘ã€‚æ‰€ä»¥æˆ‘ä»¬ä¸ä»…éœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯å­æ•°ï¼Œä¹Ÿéœ€è¦åˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦å®Œå…¨ç›¸åŒ

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if(t == null)
            return true; // t ä¸º null ä¸€å®šæ˜¯ true
        if(s == null)
            return false;
        return isSameTree(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }
    
    // åˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦å®Œå…¨ç›¸åŒ
    private boolean isSameTree(TreeNode s, TreeNode t){
        if(s == null && t == null)
            return true;
        if(s == null || t == null)
            return false;
        if(s.val != t.val)
            return false;
        return isSameTree(s.left, t.left) && isSameTree(s.right, t.right);
    }
}
```

### 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

ğŸ‘‰ [236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

ğŸ‘‰ [å‰‘æŒ‡ Offer 68 - II. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

ã€é¢˜ç›®æè¿°ã€‘ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€

ç¤ºä¾‹ 1ï¼š

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
è¾“å‡ºï¼š3
è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 1 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 3 ã€‚
```

ç¤ºä¾‹ 2ï¼š

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
è¾“å‡ºï¼š5
è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 5 ã€‚å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
```


ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šroot = [1,2], p = 1, q = 2
è¾“å‡ºï¼š1
```

ã€è§£é¢˜æ€è·¯ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ï¼š è®¾èŠ‚ç‚¹ root ä¸ºèŠ‚ç‚¹ p,q çš„æŸå…¬å…±ç¥–å…ˆï¼Œè‹¥å…¶å·¦å­èŠ‚ç‚¹ root.left å’Œå³å­èŠ‚ç‚¹ root.right éƒ½ä¸æ˜¯ p,q çš„å…¬å…±ç¥–å…ˆï¼Œåˆ™ç§° root æ˜¯ â€œæœ€è¿‘çš„å…¬å…±ç¥–å…ˆâ€ ã€‚

æœ¬é¢˜çš„å…³é”®å°±åœ¨äºè¿™å¥è¯ï¼š**å¦‚æœ p å’Œ q åœ¨ root çš„ä¸¤ä¾§ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªåœ¨å·¦å­æ ‘ï¼Œä¸€ä¸ªåœ¨å³å­æ ‘ï¼Œé‚£ä¹ˆ p å’Œ q çš„æœ€è¿‘å…¬å…±ç¥–å…ˆå°±æ˜¯ root**ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        
        // p æˆ–è€… q ä¸º root, é‚£ä¹ˆ root å°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆ
        if (root == p || root == q) {
            return root;
        }
        
        // åˆ†åˆ«å‘å·¦å­æ ‘å’Œå³å­æ ‘æŸ¥è¯¢ä¸¤ä¸ªç›®æ ‡èŠ‚ç‚¹ p q æ˜¯å¦å­˜åœ¨
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        
        // è‹¥å…¶ä¸­ä¸€æ£µå­æ ‘æ²¡æœ‰æŸ¥åˆ°ï¼Œåˆ™å…¬å…±ç¥–å…ˆä¸ºå¦ä¸€æ£µå­æ ‘
        if (left == null) {
            return right;
        }
        
        if (right == null) {
            return left;
        }
        
        // è‹¥éƒ½æŸ¥è¯¢åˆ°äº†ï¼Œåˆ™ç›®æ ‡èŠ‚ç‚¹åœ¨å½“å‰ root ä¸¤ä¾§ï¼Œé‚£ä¹ˆå½“å‰rootä¸ºæœ€è¿‘å…¬å…±ç¥–å…ˆ
        return root;
        
    }
}
```

### 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

ğŸ‘‰ [235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

ğŸ‘‰ [å‰‘æŒ‡ Offer 68 - I. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

ã€é¢˜ç›®æè¿°ã€‘ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€

ä¾‹å¦‚ï¼Œç»™å®šå¦‚ä¸‹äºŒå‰æœç´¢æ ‘:  root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

ç¤ºä¾‹ 1:

```
è¾“å…¥: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
è¾“å‡º: 6 
è§£é‡Š: èŠ‚ç‚¹ 2 å’ŒèŠ‚ç‚¹ 8 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯ 6ã€‚
```


ç¤ºä¾‹ 2:

```
è¾“å…¥: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
è¾“å‡º: 2
è§£é‡Š: èŠ‚ç‚¹ 2 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯ 2, å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
```

ã€è§£é¢˜æ€è·¯ã€‘å’Œä¸Šé¢é‚£é¢˜ä¸€æ ·ï¼Œè¿™é¢˜æ›´åŠ ç®€å•ï¼ŒæŠ“ä½äºŒå‰æœç´¢æ ‘å·¦å­æ ‘æ€»æ˜¯å°äºæ ¹èŠ‚ç‚¹ï¼Œå³å­æ ‘æ€»æ˜¯å¤§äºæ ¹èŠ‚ç‚¹è¿™ä¸ªç‰¹æ€§å°± OK äº†ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        
        if (root == p || root == q) {
            return root;
        }
        
        if (root.val > p.val && root.val > q.val) {
            // p q éƒ½ä½äº root çš„å·¦å­æ ‘ä¸Š
            return lowestCommonAncestor(root.left, p, q);
        }
        
        if (root.val < p.val && root.val < q.val) {
            // p q éƒ½ä½äº root çš„å³å­æ ‘ä¸Š
            return lowestCommonAncestor(root.right, p, q);
        }
        
        // p q åˆ†å±… root çš„ä¸¤ä¾§, åˆ™ä»–ä¿©çš„æœ€è¿‘å…¬å…±ç¥–å…ˆç»“ç‚¹ä¸º root
        return root;
        
    }
}
```

### ç‰›å®¢é¢˜éœ¸. åºåˆ—åŒ–äºŒå‰æ ‘

[ç‰›å®¢é¢˜éœ¸. åºåˆ—åŒ–äºŒå‰æ ‘](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=117&tqId=37782&companyId=134&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F134&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

[å‰‘æŒ‡ Offer 37. åºåˆ—åŒ–äºŒå‰æ ‘ â€” Hard](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

[297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ– â€” Hard](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

ã€é¢˜ç›®æè¿°ã€‘è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘

äºŒå‰æ ‘çš„åºåˆ—åŒ–æ˜¯æŒ‡ï¼šæŠŠä¸€æ£µäºŒå‰æ ‘æŒ‰ç…§æŸç§éå†æ–¹å¼çš„ç»“æœä»¥æŸç§æ ¼å¼ä¿å­˜ä¸ºå­—ç¬¦ä¸²ï¼Œä»è€Œä½¿å¾—å†…å­˜ä¸­å»ºç«‹èµ·æ¥çš„äºŒå‰æ ‘å¯ä»¥æŒä¹…ä¿å­˜ã€‚åºåˆ—åŒ–å¯ä»¥åŸºäºå…ˆåºã€ä¸­åºã€ååºã€å±‚åºçš„äºŒå‰æ ‘éå†æ–¹å¼æ¥è¿›è¡Œä¿®æ”¹ï¼Œåºåˆ—åŒ–çš„ç»“æœæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåºåˆ—åŒ–æ—¶é€šè¿‡ æŸç§ç¬¦å·è¡¨ç¤ºç©ºèŠ‚ç‚¹ï¼ˆ#ï¼‰ï¼Œä»¥ ï¼ è¡¨ç¤ºä¸€ä¸ªç»“ç‚¹å€¼çš„ç»“æŸï¼ˆvalue!ï¼‰ã€‚

äºŒå‰æ ‘çš„ååºåˆ—åŒ–æ˜¯æŒ‡ï¼šæ ¹æ®æŸç§éå†é¡ºåºå¾—åˆ°çš„åºåˆ—åŒ–å­—ç¬¦ä¸²ç»“æœstrï¼Œé‡æ„äºŒå‰æ ‘ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªåªæœ‰æ ¹èŠ‚ç‚¹ä¸º 1 çš„äºŒå‰æ ‘åºåˆ—åŒ–ä¸º "1,"ï¼Œç„¶åé€šè¿‡è‡ªå·±çš„å‡½æ•°æ¥è§£æå›è¿™ä¸ªäºŒå‰æ ‘

ã€è§£é¢˜æ€è·¯ã€‘åºåˆ—åŒ–å°±æ˜¯éå†ã€‚ä»å­—ç¬¦ä¸²ååºåˆ—æˆäºŒå‰æ ‘çš„è¯ï¼Œæˆ‘ä»¬æ¯æ¬¡éƒ½æŠŠå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åä»å­—ç¬¦ä¸²ä¸­åˆ é™¤è¿™ä¸ªèŠ‚ç‚¹ï¼Œé€’å½’æ„å»ºè¿™ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ã€‚

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    
    private StringBuilder res = new StringBuilder(); // å­˜å‚¨åºåˆ—åŒ–åçš„ç»“æœ
    private TreeNode root = null; // å­˜å‚¨ååºåˆ—åŒ–åçš„ç»“æœ
    
    String Serialize(TreeNode root) {
        // å…ˆåºéå†
        if (root == null) {
            res.append("#!");
        }
        else {
            res.append(root.val + "!");
            Serialize(root.left);
            Serialize(root.right);
        }
        
        return res.toString();
    }
    
    TreeNode Deserialize(String str) {
        String[] nodes = str.split("!"); // åˆ†å‰²å­—ç¬¦ä¸²
        List<String> list = new ArrayList<>(Arrays.asList(nodes));
        return rDeserialize(list);
    }
    
    // æ¯æ¬¡ä»å­—ç¬¦æ•°ç»„ä¸­å–å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦è¿›è¡Œåˆ¤æ–­
    private TreeNode rDeserialize (List<String> list) {
        // å½“å‰èŠ‚ç‚¹ä¸ºç©º
        if (list.get(0).equals("#")) {
            list.remove(0);
            return null;
        }
        //æ€»æ˜¯æ ¹æ®é¦–ä½å…ƒç´ ç¡®å®šå½“å‰å­æ ‘çš„æ ¹
        TreeNode root = new TreeNode(Integer.valueOf(list.get(0)));
        list.remove(0);
        root.left = rDeserialize(list);
        root.right = rDeserialize(list);
        
        return root;
    }
}
```

### 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

[105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ â€” Medium](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘ â€” Medium](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

ã€é¢˜ç›®æè¿°ã€‘è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚

```
ä¾‹å¦‚ï¼Œç»™å‡º
å‰åºéå† preorder = [3,9,20,15,7]
ä¸­åºéå† inorder = [9,3,15,20,7]
è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š

    3
   / \
  9  20
    /  \
   15   7
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼šé€’å½’ã€‚é€šè¿‡å‰åºéå†çš„ç»“æœå»ä¸­åºéå†ä¸­æ‰¾åˆ°è¿™ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘

```java
import java.util.*;

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if (pre.length == 0 || in.length == 0) {
            return null;
        }
        
        TreeNode root = new TreeNode(pre[0]); // æ ¹èŠ‚ç‚¹
        
        for (int i = 0; i < in.length; i ++) {
            // åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹
            if (in[i] == root.val) {
                // é€’å½’å¤„ç†(copyOfRange å·¦é—­å³å¼€)
                root.left = reConstructBinaryTree(
                    Arrays.copyOfRange(pre, 1, i+1),
                    Arrays.copyOfRange(in, 0, i));
                root.right = reConstructBinaryTree(
                    Arrays.copyOfRange(pre, i+1, pre.length),
                    Arrays.copyOfRange(in, i+1, in.length));
                break;
            }
        }
        return root;
    }
}
```

