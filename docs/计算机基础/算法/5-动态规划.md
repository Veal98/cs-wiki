# 🌳 动态规划 Dynamic Programming

---

## 1. 基本思想

**动态规划算法与分治法类似，其基本思想都是将待求解问题分解成若干个子问题，先求解子问题，再结合这些子问题的解得到原问题的解。**

与分治法不同的是，**适合用动态规划法求解的问题经分解得到的子问题往往不是互相独立的**。若用分治法来解这类问题，则分解得到的子问题数目太多，以至最后解决原问题需要耗费指数级时间。

**动态规划问题的一般形式就是求最值**。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。

首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要<u>「备忘录」</u>或者<u>「辅助表 DP table」</u>来记录所有已解决的子问题的答案，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**才能正确地穷举。<u>在实际的算法问题中，**写出状态转移方程是最困难的**。</u>

⭐ 动态规划算法适用于最优化问题，通常有以下 4 个步骤：

- ① 找出最优解的性质，并刻画其结构特征（最优子结构）
- ② 递归地定义最优值（状态转移方程）
- ③ 以自底向上的方式计算最优值（实现状态转移方程）
- ④ 根据计算最优值时得到的信息，构造最优解（若不需要最优解则第 ④ 步可省略）

## 2. 引例：矩阵连乘问题

**【问题描述】**：给定 n 个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1，2…，n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。

例如，给定三个连乘矩阵{A1，A2，A3}的维数分别是 $10*100$，$100*5$和$5*50$，采用$(A1A2)A3$，乘法次数为$10*100*5+10*5*50=7500次$，而采用$A1(A2A3)$，乘法次数为$100*5*50+10*100*50=75000次$乘法，显然，最好的次序是$(A1A2)A3$，乘法次数为7500次。

首先考虑计算两个矩阵乘积所需的计算量。假设 A 是 $p * q$ 的矩阵，B 是 $q * r$ 的矩阵，则 C = AB 是一个 $p * r$ 的矩阵，一共需要 $p * q * r$ 次数乘。在计算多个矩阵的连乘的时候，不同的加括号方式对整个计算量来说具有很大的影响。下面我们用动态规划法来求解该问题：

### ① 最优子结构

该问题符合【最优子结构】：

<img src="https://gitee.com/veal98/images/raw/master/img/20201003205948.png" style="zoom: 55%;" />

### ② 状态转移方程

<img src="https://gitee.com/veal98/images/raw/master/img/20201003210401.png" style="zoom: 40%;" />

**辅助表 `m[i][j]` 记录了最优值，即计算 `A[i:j]` 所需的最少数乘次数**。同时确定了计算 `A[i:j]` 的最优次序中的断开位置 `k`。

若将对应 `m[i:j]` 的断开位置 `k` 记为 `s[i][j]`，则在计算出最优质 `m[i][j]` 后，可递归地由 `s[i][j]` 构造出相应的最优解。

### ③ 实现状态转移方程

由上一步的递归式可以看出，递归的过程中会出现很多的**重复子问题**。可以用两个  `n * n` 维的辅助表：

- `m[n][n]`  表示最优乘积代价（最少数乘次数）
- `s[n][n]`  表示每个子问题的最优分割位置 k

对于一组矩阵: $A1(30*35),A2(35*15),A3(15*5),A4(5*10),A5(10*20),A6(20*25)  $ ，个数 n = 6

那么 p 数组保存它们的行数和列数：$p={30,35,15,5,10,20,25}$，共有 n+1 即 7 个元素

`p[0], p[1]` 分别代表第一个矩阵的行数和列数，`p[1],p[2]` 分别代表第二个矩阵的行数和列数...... `p[5],p[6]` 代表第六个矩阵的行数和列数

> 🔗 下图来源 [动态规划算法之矩阵连乘问题思路](https://blog.csdn.net/qq_32919451/article/details/80643118)

![](https://gitee.com/veal98/images/raw/master/img/20201004105239.png)

⭐ 辅助表 `s[n][n]` 可以由 2 种方法构造（下节会详细讲解）：

- 一种是**自底向上（动态规划算法）**构建，该方法要求按照递增的方式逐步填写子问题的解，也就是先计算 2 个矩阵连乘的最优分割位置，然后计算 3 个矩阵连乘的最优分割位置，直到长度 n；
- 另一种是**自顶向下（备忘录法）**，该方法将表的每个元素初始化为某特殊值(本问题中可以将最优乘积代价设置为一极大值)，以表示待计算，在递归的过程中逐个填入遇到的子问题的解。

<u>采用动态规划自底向上的方式，则计算顺序为</u>：

![](https://gitee.com/veal98/images/raw/master/img/20201004105431.png)：

辅助表 `m[i][j]`代表从矩阵 $A_i，A_{i+1}，A_{i+2}......$ 直到矩阵 $A_j$ 连乘的最小的相乘次数，比如 `m[2][5]` 代表矩阵 `A2 A3 A4 A5` 最小的相乘次数，即最优的乘积代价。我们看上图，从矩阵 A2 到 A5 有三种断链方式：`A2{A3A4A5}`、`{A2A3}{A4A5}`、`{A2A3A4}A5`，我们分别算出这三个不同断链方式的总乘积次数，然后选出最小的一个，就是 `m[2][5]` 的值。同时保留断开的位置 k 在 `s[2][5]` 数组中。

<img src="https://gitee.com/veal98/images/raw/master/img/20201004110056.png" style="zoom: 50%;" />

即 `m[2][5] = 7125, s[2][5] = 3`

```java
// p 存储矩阵的行列数
// n 表示一共多少个矩阵
// m 数组存储每个子问题的最优值(计算量)
// s 数组存储每个子问题的最优断开位置
public void MatixChain(int[] p, int n, int[][] m, int[][] s){

    // m[i][i]只有一个矩阵，所以相乘次数为0，即 m[i][i] = 0;
    for(int i = 1; i <= n; i ++)
        m[i][i] = 0; 

    // r 表示矩阵链的长度（r 个矩阵相乘）
    for(int r = 2; r <= n; r ++){
        for(int i = 1; i <= n-r+1; i ++){
            // 以 i 为起始位置，j 为长度为 n 的矩阵链的末位
            int j = i + r - 1;
            // 将链 A[i:j] 划分为 A(i) * ( A[i+1:j] ) 
            m[i][j] = m[i+1][j] + p[i-1] * p[i] * p[j];
            s[i][j] = i; // 初始化断开点位置

            // 将链 A[i:j] 划分为 A[i:k] * A[k+1:j]
            for(int k = i + 1; k < j; k ++){
                int temp = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j];
                if(temp < m[i][j]){
                    m[i][j] = temp; // 更新最优值
                    s[i][j] = k; // 更新断开点位置
                }
            }
        }
    }
}
```

至此，我们比计算出来矩阵连乘的最少数乘次数，接下来我们需要计算什么样的的计算次序能够达到此最少数乘次数 👇

### ④ 构造最优计算次序

<img src="https://gitee.com/veal98/images/raw/master/img/20201003214047.png" style="zoom:40%;" />

```java
// 返回 s 数组 i~j 范围内的最优值
public void Traceback(int i, int j, int[][] s){
    if(i == j)
       return ;
    Traceback(i, s[i][j], s);
    Traceback(s[i][j]+1, j, s);
    System.out.println("Multiply  A" + i + "," + s[i][j] + " and A" + (s[i][j] + 1) + "," + j);
}
```

要输出 `A[1:n]` 的最优计算次序只需要调用  `Traceback(1,n,s)` 即可。

### ⑤ 完整程序 (Java)

整合一下上述代码段，将其写成一个完整的程序：

```java

public class Matrix {
    
    private static int n = 6; // 表示一共 n 个矩阵
    private  int[] p; // 存储矩阵的行列数
    private  int[][] m; // 存储每个子问题的最优值(计算量)
    private  int[][] s; // 存储每个子问题的最优断开位置

    public Matrix(){
        p = new int[]{30, 35, 15, 5, 10, 20, 25};
        m = new int[n+1][n+1];
        s = new int[n+1][n+1];
    }
	
    // 核心算法（状态转移方程）
    public void MatixChain(){

        // m[i][i]只有一个矩阵，所以相乘次数为0，即 m[i][i] = 0;
        for(int i = 1; i <= n; i ++)
            m[i][i] = 0; 
        
        // r 表示矩阵链的长度（r 个矩阵相乘）
        for(int r = 2; r <= n; r ++){
            for(int i = 1; i <= n-r+1; i ++){
                // 以 i 为起始位置，j 为长度为 n 的矩阵链的末位
                int j = i + r - 1;
                // 将链 A[i:j] 划分为 A(i) * ( A[i+1:j] ) 
                m[i][j] = m[i+1][j] + p[i-1] * p[i] * p[j];
                s[i][j] = i; // 初始化断开点位置
                
                // 将链 A[i:j] 划分为 A[i:k] * A[k+1:j]
                for(int k = i + 1; k < j; k ++){
                    int temp = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j];
                    if(temp < m[i][j]){
                        m[i][j] = temp; // 更新最优值
                        s[i][j] = k; // 更新断开点位置
                    }
                }
            }
        }
    }

    // 返回 s 数组 i~j 范围内的最优值
    public void Traceback(int i, int j){
        if(i == j)
           return ;
        Traceback(i, s[i][j]);
        Traceback(s[i][j]+1, j);
        System.out.println("Multiply  A" + i + "," + s[i][j] + " and A" + (s[i][j] + 1) + "," + j);
    }

    public static void main(String[] args){
        Matrix matrix = new Matrix();
        matrix.MatixChain();
        matrix.Traceback(1, n);
    }
}
```

## 3. 动态规划算法的基本要素

动态规划算法的有效性依赖于问题本身所具有的两个重要性质：

- 最优子结构
- 子问题重叠性质

众所周知，状态转移方程是 DP 系列最难的一步，本节还会给出写状态转移方程的套路模板 😃。

### ① 最优子结构

**当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质**。 

问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。

举个例子：给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。

比如说 `k = 3`，面值分别为 1，2，5，总金额 `amount = 11`。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

上述问题就符合最优子结构。比如你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。

### ② 重叠子问题

在用递归算法自顶向下计算该问题时，每次产生的子问题并不总是新的问题，有些子问题被反复计算。以上面的矩阵连乘为例，我们直接使用递归计算 `A[i:j]` 的最小数乘次数：

```java
// 递归求解矩阵连乘最少次数
public int RecurMatirxChain(int i, int j){
    if(i == j)
        return 0;
    int u = RecurMatirxChain(i,i) + RecurMatirxChain(i+1,j) + p[i-1] * p[i] * p[j];
    s[i][j] = i;
    for(int k = i + 1; k < j; k ++){
        int t = RecurMatirxChain(i,k) + RecurMatirxChain(k+1,j) + p[i-1] * p[k] * p[j];
        if(t < u){
            u = t;
            s[i][j] = k;
        }
    }
}
```

<img src="https://gitee.com/veal98/images/raw/master/img/20201004145544.png" style="zoom:40%;" />

可以证明该算法的计算时间 T(n) 具有指数下界：

<img src="https://gitee.com/veal98/images/raw/master/img/20201004151112.png" style="zoom:40%;" />

有两种方法可以解决重叠子问题带来的问题 👇

#### Ⅰ 自底向上（动态规划）

如上面引例的解法，动态规划算法正是利用了这种子问题的重叠性质，对每个子问题只求解一次，然后**按照递增（自底向上）的方式逐步将子问题的解存储在辅助表内**，当再次需要解此问题时，查找该辅助表即可。

> 💡 **自底向上**：注意上图 3-2 的递归树（或者说图）。动态规划算法就是从问题规模最小的基本情况（base case）比如 `A[2:2]` 开始逐层往上推导，直到我们想要的上层答案比如 `A[1:4]`。这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

**相比于直接递归的指数级时间复杂度，动态规划的主要计算量取决于程序中的三重循环，时间复杂度只有 $O(n^3)$**

#### Ⅱ 自顶向下（备忘录法）

💉 **备忘录方法是动态规划算法的变形**。与动态规划算法一样，备忘录法需要使用辅助表存储已解决的子问题的答案。不同的是，**动态规划算法是自底向上递归的，而备忘录法是自顶向下递归的**。因此，**备忘录法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以便需要时查看**。

> 💡 **自顶向下**：注意上图 3-2 的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题向下逐渐分解规模，直到类似于 `A[2: 2]` 这种基本情况 (base case)，然后自底层逐层向上返回答案，这就叫「自顶向下」。

💧 **备忘录方法为每个子问题建立一个记录项，并将其初始化为某个特殊的值，表示该子问题尚未求解。在递归的过程中，对每个待求的子问题，首先查找对应的记录项**，若为初始值，则表示该子问题是第一次遇到，则计算出该子问题的解并存储在对应的记录项中，以便需要时查看。

以引例-矩阵连乘问题为例，备忘录方法的代码如下：

```java
// 备忘录
public int MemoizeMatirxChain(int n, int[][] m, int[][] s){
    for(int i = 1; i <= n; i++){
        for(int j = i; j <= n; j++){
            m[i][j] = 0; // 初始化备忘录
        }
        return LookupChain(1, n);
    }
}

public int LookupChain(int i, int j){
    if(m[i][j] > 0)
        return m[i][j];
    if(i == j)
        return 0;
    int u = LookupChain(i,i) + LookupChain(i+1,j) + p[i-1] * p[i] * p[j];
    s[i][j] = i;
    for(int k = i + 1; k < j; k ++){
        int t = LookupChain(i,k) + LookupChain(k+1,j) + p[i-1] * p[k] * p[j];
        if(t < u){
            u = t;
            s[i][j] = k;
        }
    }
    m[i][j] = u; // 更新备忘录
    return u;
}
```

显然，大家也能看出来，😊 <u>备忘录算法不过就是在直接递归算法的基础上加入了一个用来记忆的数组罢了</u>。

对于上述代码，**备忘录算法的时间复杂度和动态规划一样**同为 $O(n^3)$：共有 $O(n^2)$ 个备忘录项 `m[n][n]`，这些记录项的初始化时间为 $O(n^2)$，每个记录项值填入一次，共耗费 $O(n)$ 时间，因此，备忘录算法填入 $O(n^2)$ 个记录项总共耗费 $O(n^3)$ 的计算时间。

#### Ⅲ 两种方法的比较

一般来讲：

- 当一个问题的所有子问题都需要至少求解一次时，用动态规划算法比用备忘录方法好。

- 当部分子问题可不必求解时，用备忘录方法则比较有利，因此从其控制结构来说，该方法只解决那些确实需要求解的问题。

### ③ 状态转移方程

在实际的算法问题中，**写出状态转移方程是最困难的**，此处提供一个思维框架，辅助你思考状态转移方程：

- 👉 明确「状态」
- 👉 明确「选择」
- 👉 明确辅助表/数组/函数 DP Table 的含义（用辅助表把状态表示出来）
- 👉 明确 base case

⭐ 按上面的套路走，最后的结果就可以套这个框架：

```java
// 初始化 base case
dp[0][0][...] = base
// 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

注意，**对于辅助表是二维数组的情况，一定要注意双重循环的顺序问题**，下文会有提到 😊

## 4. 经典实例：不连续子序列问题

连续的子序列可以说是子数组，不连续的子序列问题显然比子数组问题要更困难一些。而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的最长公共子序列，如果没有一定的处理经验，真的不容易想出来。所以此处就来扒一扒子序列问题的套路，其实只有**两种模板**。

### ① 算法模板

- 第一种思路模板是一个**一维的 dp 数组**：

    ```java
    int n = array.length;
    int[] dp = new int[n];

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] = 最值(dp[i], dp[j] + ...)
        }
    }
    ```

    如下最长上升子序列问题

- 第二种思路模板是一个**二维的 dp 数组**：

    ```java
    int n = arr.length;
    int[][] dp = new dp[n][n];

    for (int i = 0; i < n; i++) {
        for (int j = 1; j < n; j++) {
            if (arr[i] == arr[j]) 
                dp[i][j] = dp[i][j] + ...
            else
                dp[i][j] = 最值(...)
        }
    }
    ```

    这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。

    - **涉及两个字符串/数组**时（比如最长公共子序列），dp 数组的含义如下：在子数组 `arr1[0..i]`和子数组`arr2[0..j]`中，我们要求的子序列长度为`dp[i][j]`。
- **只涉及一个字符串/数组**时（比如最长回文子序列），dp 数组的含义如下：在子数组 `array[i..j]`中，我们要求的子序列的长度为`dp[i][j]`。

<img src="https://gitee.com/veal98/images/raw/master/img/20201008210926.png" style="zoom:67%;" />

### ② 最长上升子序列 LIS

**【问题描述】**：

给定一个无序的整数数组，找到其中**最长上升子序列（Longest Increasing Subsequence）**的长度。

示例:

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```


说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。

你算法的时间复杂度应该为 $O(n^2) $。

#### Ⅰ 最优子结构

该问题符合最优子结构性质。以第 `i` 个数结尾的最长递增序列，一定包含以第 `j` 个数（`j < i`）结尾的最长递增序列

#### Ⅱ 状态转移方程

🔸 首先**明确状态**：状态只有一个，就是「数组的长度」。

🔸 **明确选择**：对于每个数字，选择有两个，就是「加入递增序列」或者「不加入递增序列」。

🔸 **明确辅助表的定义**：用辅助表表示状态，看看刚才找到的「状态」，只有一个，也就是说我们只需要一个一维`dp`数组，表示数组的长度。**`dp[i]`的定义如下：以第 `i` 个数结尾的最长递增子序列长度。**举个例子：

<img src="https://gitee.com/veal98/images/raw/master/img/20201008111522.png" style="zoom:50%;" />

**根据这个定义，我们想求的最终答案就是`dp[N]`， `N` 为数组的最大下标。**

🔸 最后明确**基本情况 base case**：以第 `i` 个数结尾的最长递增子序列长度至少是 1（因为子序列最少也要包含自己）。

⭐ OK，下面可以开始写状态转移方程（**选择与状态的关系**）：根据最优子结构性质，对于以第 `i` 个数结尾的最长递增子序列长度，一定包含以第 `j` 个数（`j < i`）结尾的最长递增序列。举个例子：假如我们想求 `dp[5]` 的值，也就是想求以 `nums[5]` 为结尾的最长递增子序列。`nums[5] = 3`

<img src="https://gitee.com/veal98/images/raw/master/img/20201008112035.png" style="zoom: 50%;" />

**我们只要找到前面那些结尾比 3 小的最长递增子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**：

- `num[0] = 1 < 3`, 则 `dp[5] = dp[0] + 1 = 2`
- `num[1] = 4 > 3`, 不是以 nums[5] 结尾的递增子序列
- `num[2] = 3 = 3`, 不是以 nums[5] 结尾的递增子序列
- `num[3] = 4 > 3`, 不是以 nums[5] 结尾的递增子序列
- `num[4] = 2 < 3`, 则 `dp[5] = dp[4] + 1 = 3`

从中选出最大的 `dp[5] = 3`，即以 `nums[5]` 为结尾的最长递增子序列长度为 3

用公式表示出来就是：💡  `dp[i] = max(dp[i], dp[j] + 1) , j < i`

#### Ⅲ 实现状态转移方程

```java
class Solution {
    public int lengthOfLIS(int[] nums) {

        int N = nums.length;
        int maxLength = 0; // 最长递增子序列长度

        // 辅助数组
        int[] dp = new int[N];

        // base case 初始化为 1
        Arrays.fill(dp, 1);
        
        // 状态转移方程
        for(int i = 0; i < N; i ++){
            for(int j = 0; j < i; j ++){
                if(nums[j] < nums[i])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }

        // 遍历 dp，查找最大值
        for(int i = 0; i < N; i ++){
            if(dp[i] > maxLength)
                maxLength = dp[i];   
        }

        return maxLength;
    }
}
```

#### 📜 对应LeetCode

- [300 - 最长上升子序列 — Medium](计算机基础/算法/LeetCode/动态规划/300-最长上升子序列.md)

### ③ 最长公共子序列 LCS

**【问题描述】**：

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列 (`Longest Common Subsequence, LCS`) 的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
```


示例 2:

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```


示例 3:

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```

下面按照动态规划算法的设计步骤来解决此问题 👇

#### Ⅰ 最优子结构

<img src="https://gitee.com/veal98/images/raw/master/img/20201004154015.png" style="zoom:42%;" />

由此可见，**两个序列的最长公共子序列必然包含着这两个序列的前缀的最长公共子序列**。举个例子：

比如：text1 = "abcde"，text2 = "abqcwe"

取 text1 前面某些部分 "abc"，取 text2 前面某个部分"abqc"，那么这两个子序列的最长公共子序列为 "abc"

显然 text1 和 text2 的最长公共子序列 "abce" 是包含 "abc" 的

#### Ⅱ 状态转移方程

🔸 首先**明确状态**：状态有两个，就是「序列 X 的长度」 和 「序列 Y 的长度」。

🔸 **明确选择**：对于每个数字，选择有两个，就是「加入公共子序列」或者「不加入公共子序列」。

🔸 **明确辅助表的定义**：用辅助表表示状态，看看刚才找到的「状态」，有两个，也就是说我们需要一个二维`dp`数组，表示递增序列的长度。**`dp[i][j]`的定义如下：序列 $X_i$ 和 $Y_j$ 的最长公共子序列的长度**。根据这个定义，**我们想求的最终答案就是`dp[m][n]`**

🔸 最后明确**基本情况 base case**：当 i = 0 或 j = 0 时，$X_i$  和 $Y_i$ 的最长公共子序列长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。

比如说对于字符串 `b a b c d e` 和字符串 `a c e` 构造一个辅助表：

<img src="https://gitee.com/veal98/images/raw/master/img/20201004212648.png" style="zoom:60%;" />

其中，`dp[i][j]` 的含义是：对于 `s1[1..i]` 和 `s2[1..j]`，它们的最长公共子序列长度是 `dp[i][j]`。比如上图的例子，`dp[2][4]` 的含义就是：对于 `"ac"` 和 `"babc"`，它们的最长公共子序列长度是 2。 `dp[0][3]=0` 的含义是：对于字符串 `""` 和 `"bab"`，其 LCS 的长度为 0。**我们最终想得到的答案应该是 `dp[3][6]`**。

⭐ OK，下面可以开始写状态转移方程（**选择与状态的关系**）：

<img src="https://gitee.com/veal98/images/raw/master/img/20201004155021.png" style="zoom:42%;" />

```java
// m 是第一个序列的长度，n 是第二个序列的长度
// 由于我们辅助表的第 0 行和第 0 列不用，所以需要 new int[m+1][n+1]
int[][] dp = new int[m+1][n+1];
```

#### Ⅲ 实现状态转移方程

根据上面的状态转移方程，在计算 `dp[i][j]` 之前，我们需要先计算 `dp[i-1][j-1]` 和 `dp[i-1][j]` 以及 `dp[i][j-1]`，从图中可以看出，我们直接从 0 开始顺序遍历即可保证计算顺序。

<img src="https://gitee.com/veal98/images/raw/master/img/20201008155421.png" style="zoom:50%;" />

计算最长公共子序列的长度：

```java
/**
 * @param m 序列 x 的个数：X_1, X_2 ...  X_m
 * @param n 序列 y 的个数：Y_1, Y_2 ...  Y_n
 * @param x 序列 x
 * @param y 序列 y
 * @param dp dp[i][j] 存储 X_i 和 Y_j 的最长公共子序列的长度
 * @param b b[i][j] 记录 dp[i][j] 的值是由哪个子问题的解得到的
 */
public void LCSlength(int m, int n, char[] x, char[] y, int[][] dp, int[][] b){
    
    // base case
    for(int i = 1; i <= m; i ++){
        dp[i][0] = 0;
    }
    for(int i = 1; i <= n; i++){
        dp[0][i] = 0;
    }
	
    // 状态转移方程
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++){
            // 加入公共子序列
            // 注意一下这个地方, 因为我们在辅助表的外围加了一圈 0
            // 所以对应于字符串的下标需要相应的 - 1，看一下上面的图就明白了
            if(x[i-1] == y[j-1]){ 
                dp[i][j] = dp[i-1][j-1] + 1;
                b[i][j] = 1;
            }
            // 不加入公共子序列的两种情况
            else if(dp[i-1][j] >= dp[i][j-1]){  
                dp[i][j] = dp[i-1][j];
                b[i][j] = 2;
            }
            else{ // dp[i][j-1] > dp[i-1][j])  
                dp[i][j] = dp[i][j-1];
                b[i][j] = 3;
            }
        }
    }
}
```

> 💡 上面两段 base case 的过程其实是可以省略的，因为 new 的时候就已经初始成 0 了。

⏰ 上述代码的时间复杂度主要在于两个 for 循环，因此算法 `LCSLength` 时间复杂度为 `O(mn)`

#### Ⅳ 状态压缩

**<u>如果只需要计算最长公共子序列的长度，则上述算法还能够继续优化</u>**。我们在计算 `c[i][j]` 的时候，只用到数组 c 的第 i 行和 第 i-1 行，只需要用两行的数组空间就可以计算出最长公共子序列的长度。

💡 **这就是状态压缩的技巧。也就是说我们发现每次状态转移只需要辅助表 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，从而实现进一步减少空间复杂度**

<img src="https://gitee.com/veal98/images/raw/master/img/20201008114921.png" style="zoom:67%;" />

准备几个变量：

- `last`:表示是当前 `dp[j](dp[i][j])` 左上角的数，相当于 `dp[i-1][j-1]` ,初始化的时候为 0
- `temp`:表示是当前 `dp[j](dp[i][j])` 正上方的数，相当于 `dp[i- 1][j]` 
- `dp[j-1]`:表示是当前 `dp[j](dp[i][j])` 左边的数，相当于 `dp[i][j-1]`
- 每一轮结束后，`last `的值都向前滚动一个，变成正上方的数，也就是 `temp`

之前的状态转移方程为：

`dp[i][j] = 0 / dp[i-1][j-1] + 1 / max{ dp[i][j-1] | dp[i-1][j] }`

转换为：

`dp[j] = 0 / last + 1 / max{ dp[j-1] | temp }`

代码如下：

```java

// 计算最长公共子序列的长度
public void LCSlength(char[] x, char[] y){
    int m = x.length;
    int n = y.length;
    int[] dp = new int[n+1]; // 辅助数组
    int temp = 0;
    for(int i = 1; i <= m; i ++){
        int last = 0;
        for(int j = 1; j <= n; j++){
            temp = dp[j];
            if(x.charAt(i-1) == y.charAt(j-1))
                dp[j] = last + 1;
            else if(temp >= dp[j-1])
                dp[j] = temp;
            else
                dp[j] = dp[j-1];
            last = temp;
        }
    }
    return dp[n];
}

```

空间复杂度降至 `O(min{m,n})`

#### Ⅴ 构造最长公共子序列

根据上述代码算出的 `b[i][j]`，我们开始构造最长公共子序列：

```java
/**
 * @param i X_1, X_2 ... X_i
 * @param j Y_1, Y_2 ... Y_j
 * @param x 序列 X（这里我们传入一个序列用来输出公共子序列，X Y 随便哪个都可以）
 * @param b 由 LCSlength 计算出来的 b[i][j]，表示 i 到 j 范围的子问题属于哪种情况
 */
public void LCS(int i, int j, char[] x, int[][] b){

    if(i == 0 || j == 0)
        return ;
    if(b[i][j] == 1){
        LCS(i-1, j-1, x, b);
        System.out.println(x[i-1]);
    }
    else if(b[i][j] == 2){
        LCS(i-1, j, x, b);
    }
    else{
        LCS(i, j-1, x, b);
    }
}
```

⏰ 每次递归调用使 `i` 或 `j` 减 1，因此算法 `LCS` 时间复杂度为 `O(m+n)`

#### Ⅵ 完整程序 (Java)

整理一下上述代码，将其写成一个完整的程序：

```java
public class LCSTest {

    private char[] x; // 序列 X
    private char[] y; // 序列 Y
    private int m; // 序列 X 的长度（字符个数）
    private int n; // 序列 Y 的长度
    private int[][] dp; // dp[i][j] 存储 X_i 和 Y_j 的最长公共子序列的长度
    private int[][] b; // b[i][j] 记录 c[i][j] 的值是由哪个子问题的解得到的

    public LCSTest(){
        x = new char[]{'a', 'b', 'c', 'd', 'f','e'};
        y = new char[]{'a', 'c', 'f', 'e'};
        m = x.length;
        n = y.length;
        b = new int[m+1][n+1];
        dp = new int[m+1][n+1];
    }

    public static void main(String[] args){
        LCSTest lcsTest = new LCSTest();
        lcsTest.LCSlength();
        lcsTest.LCS(lcsTest.m, lcsTest.n);
    }
	
    // 核心算法（状态转移方程）
    public void LCSlength(){
        
		// base case 可省略
        
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(x[i-1] == y[j-1]){ // 情况 1
                    dp[i][j] = dp[i-1][j-1] + 1;
                    b[i][j] = 1;
                }
                // 取较大值为最大公共子序列长度
                else if(dp[i-1][j] >= dp[i][j-1]){  // 情况 2
                    dp[i][j] = dp[i-1][j];
                    b[i][j] = 2;
                }
                else{ // dp[i][j-1] > dp[i-1][j])  情况 3 
                    dp[i][j] = dp[i][j-1];
                    b[i][j] = 3;
                }
            }
        }
    }
    /**
     * @param i X_1, X_2 ... X_i
     * @param j Y_1, Y_2 ... Y_j
     */
    public void LCS(int i, int j){

        if(i == 0 || j == 0)
            return ;
        if(b[i][j] == 1){
            LCS(i-1, j-1);
            System.out.println(x[i-1]); // 这里我们传入一个序列用来输出公共子序列，X Y 随便哪个都可以
        }
        else if(b[i][j] == 2){
            LCS(i-1, j);
        }
        else{
            LCS(i, j-1);
        }
    }   
}
```

#### 📜 对应LeetCode

- [1143 - 最长公共子序列 — Medium](计算机基础/算法/LeetCode/动态规划/1143-最长公共子序列.md)

### ④ 最长回文子序列 LPS

**【问题描述】**：

给定一个字符串 s ，找到其中**最长的回文子序列（ Longest Palindromic Subsequence）**，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1:

```
输入: "bbbab"
输出: 4
一个可能的最长回文子序列为 "bbbb"。
```

示例 2:

```
输入: "cbbd"
输出: 2
一个可能的最长回文子序列为 "bb"。
```

#### Ⅰ 最优子结构

该题符合最优子结构的性质：假设要求下标 i 和 j 之间的最长回文子序列长度 A，已知下标 i+1 和 j-1 之间的最长回文子序列长度 B。A 一定包含或者等于 B。如果 s[i] 和 s[j] 相等， 那么 A = B + 2：

<img src="https://gitee.com/veal98/images/raw/master/img/20201008150659.png" style="zoom:50%;" />

如果 s[i] 和 s[j] 不相等， 说明他俩不可能同时出现在 `s[i : j]` 的最长回文序列中，那么将它们分别加入 `s[i+1 : j-1]` 中，看看哪个子串产生的回文子序列更长即可

<img src="https://gitee.com/veal98/images/raw/master/img/20201008150713.png" style="zoom:50%;" />

#### Ⅱ 状态转移方程

🔸 首先**明确状态**：状态有两个，就是「待求序列的下标上限 i」 和 「待求序列的下标下限 j」。

🔸 **明确选择**：对于每个数字，选择有两个，就是「加入回文子序列」或者「不加入回文子序列」。

🔸 **明确辅助表的定义**：用辅助表表示状态，看看刚才找到的「状态」，有两个，也就是说我们需要一个二维`dp`数组，其中一维表示待求序列的下标上限，另一维表示表示待求序列的下标下限。**`dp[i][j]`的定义如下：在子串`s[i..j]`中，最长回文子序列的长度为`dp[i][j]`。**根据这个定义，**我们想求的最终答案就是`dp[0][N-1]`， `N` 为数组的长度**。

🔸 最后明确**基本情况 base case**：如果只有一个字符，显然最长回文子序列长度是 1，也就是`dp[i][j] = 1,(i == j)`。并且对于那些`i > j`的位置，不存在子序列，也就是说辅助表 dp 的对角线的左边都是不需要使用的：

<img src="https://gitee.com/veal98/images/raw/master/img/20201008161840.png" style="zoom:60%;" />

⭐ OK，下面可以开始写状态转移方程（**选择与状态的关系**）：根据最优子结构性质：

- `dp[i][j] = dp[i+1][j-1] + 2, s[i] = s[j]`
- `dp[i][j] = max( dp[i][j-1], dp[i+1][j]), s[i] ≠ s[j]`

#### Ⅲ 实现状态转移方程

根据状态转移方程，在计算 `dp[i][j]` 之前，我们需要计算 `dp[i][j-1]` 和 `dp[i+1][j]` 以及 `dp[i+1][j-1]`，从图中可以看出，我们不能从 0 开始顺序遍历，**只能斜着遍历或者反着遍历以保证计算顺序**：

<img src="https://gitee.com/veal98/images/raw/master/img/20201008155740.png" style="zoom: 50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20201008160117.png" style="zoom:60%;" />

我选择反向遍历：`i` 从最后一个字符开始往前遍历，`j` 从 `i + 1` 开始往后遍历

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];

        // base case
        for(int i = 0; i < n; i ++)
            dp[i][i] = 1;
        
        // 状态转移方程
        for(int i = n - 1; i >= 0; i --){
            for(int j = i + 1; j < n; j ++){
                if(s.charAt(i) == s.charAt(j))
                    dp[i][j] = dp[i+1][j-1] + 2;
                else
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
            }
        }
        return dp[0][n-1];
    }
}
```

#### 📜 对应LeetCode

- [516 - 最长回文子序列 — Medium](计算机基础/算法/LeetCode/动态规划/516-最长回文子序列.md)

## 5. 经典实例：背包问题

### ① 0-1 背包问题

**【问题描述】**：给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性，且每个物品只有一件。其中第 `i` 个物品的重量为 `w[i]`，价值为 `v[i]`，现在让你用这个背包装物品，且每个物品只能使用一次，最多能装的价值是多少？

<img src="https://gitee.com/veal98/images/raw/master/img/20201007093550.png" style="zoom:50%;" />

<img src="https://gitee.com/veal98/images/raw/master/img/20201007100720.png" style="zoom:40%;" />

举个简单的例子，输入如下：

```
N = 3, W = 4
w = [2, 1, 3]
v = [4, 2, 3]
```

算法返回 6，选择前两件物品装进背包，总重量 3 小于 `W`，可以获得最大价值 6。

题目就是这么简单，一个典型的动态规划问题。这个题目中的**物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历**。

#### Ⅰ 最优子结构

该问题符合最优子结构性质：设 $(y_1,y_2...y_n)$ 是该问题的一个最优解，则 $(y_2,y_3...y_n)$ 是下面相应子问题的一个最优解：

<img src="https://gitee.com/veal98/images/raw/master/img/20201007100814.png" style="zoom:50%;" />

#### Ⅱ 状态转移方程

🔸 按照套路来，首先**明确状态**：先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，所以状态有两个，就是「背包的容量」和「可选择的物品」。

🔸 **明确选择**：对于每件物品，你能选择什么？选择也有两个，就是「装进背包 1」或者「不装进背包 0」。

🔸 **明确辅助表的定义**：用辅助表表示状态，看看刚才找到的「状态」，有两个，也就是说我们需要一个二维`dp`数组，一维表示可选择的物品，一维表示背包的容量。**`dp[i][w]`的定义如下：对于前`i`个物品，当前背包的容量为`w` (还能装入 `w` 重量的物品)，这种情况下可以装的最大价值是`dp[i][w]`。** 比如说，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。**根据这个定义，我们想求的最终答案就是**`dp[N][W]`。

🔸 最后明确**基本情况 base case**：

- 背包容量为空时（N=0），能装的最大价值为 0  即 `dp[0][W] = 0`

- 物品容量为空时（W=0），能装的最大价值为 0  即 `dp[N][0] = 0`

  > 💡 在 Java 中，`dp = new int[N+1][W+1];` 会将 dp 数组全部初始化成 0，所以 base case 不必在代码中手动实现~

⭐ OK，下面可以开始写状态转移方程（**选择与状态的关系**）：对于前`i`个物品，当前背包的容量为`w`时，这种情况下可以装下的最大价值是`dp[i][w]`：

- **如果你没有把这第 `i`个物品装入背包**，那么很显然，最大价值`dp[i][w]`应该等于`dp[i-1][w]`。

- **如果你把这第 `i` 个物品装入了背包**，那么`dp[i][w]`应该等于`dp[i-1][w-w[i-1]] + v[i-1]`。

  🚨 注意 `i` 的取值范围为 `1~N`，从 1 开始计数，对应于 `w[] `和 `v[]` 数组的下标应为 `i - 1`

分析结束，接下来套模板即可 👇

#### Ⅲ 实现状态转移方程

根据上面的状态转移方程，在计算 `dp[i][w]` 之前，我们需要先计算 `dp[i-1][w]` 和 `dp[i-1][w-w[i-1]]` ，直接从 0 开始顺序遍历即可保证计算顺序。

```java
private int[][] dp;
private int[] weight; // 物品对应重量 
private int[] value; // 物品对应价值

/**
 * 返回最大价值
 * @param W 背包最大承受的物品总重量
 * @param N 背包最多承受的物品总数量
 * @return
 */
public int Knapsack(int N, int W){
    dp = new int[N+1][W+1];
    for(int i = 1; i <= N; i ++){ // 状态 1：可选择的物品
        for(int w = 1; w <= W; w ++){ // 状态 2：背包容量
            // 挑选最佳选择存入辅助表
            if(w - weight[i-1] < 0) // 当前背包容量装不下，只能选择不装入背包
                dp[i][w] = dp[i-1][w];
            else{ // 装入或者不装入背包，择优
                dp[i][w] = Math.max(dp[i-1][w-weight[i-1]] + value[i-1], dp[i-1][w]);
            }
        }
    }
    return dp[N][W];
}
```

🚨 注意，我们传入的 N 必须要和物品的数量一致。

#### Ⅳ 完整程序 (Java)

一般题目求出最优值也就结束了，此处求最优解 0-1 向量的代码就不写了（🐶）

```java
public class KnapsackTest {
    
    private int[][] dp;
    private int[] weight;
    private int[] value;

    public KnapsackTest(){
        weight = new int[]{2,1,3};
        value = new int[]{4,2,3};
    }

    /**
     * 返回最大价值
     * @param W 背包最大承受的物品总重量
     * @param N 背包最多承受的物品总数量
     * @return
     */
    public int Knapsack(int N, int W){
        dp = new int[N+1][W+1];
        // base case
        dp[N][0] = 0;
        dp[0][W] = 0;
        for(int i = 1; i <= N; i ++){ // 状态 1：可选择的物品
            for(int w = 1; w <= W; w ++){ // 状态 2：背包容量
                // 挑选最佳选择存入辅助表
                
                if(w - weight[i-1] < 0) // 当前背包容量装不下，只能选择不装入背包
                    dp[i][w] = dp[i-1][w];
                else{
                    // 装入或者不装入背包，择优
                    dp[i][w] = Math.max(dp[i-1][w-weight[i-1]] + value[i-1], dp[i-1][w]);
                }
            }
        }
        return dp[N][W];
    }

    public static void main(String[] args){
        KnapsackTest knapsackTest = new KnapsackTest();
        // 注意，我们传入的 N 必须要和物品的数量一致
        int maxValue = knapsackTest.Knapsack(knapsackTest.weight.length, 4);
        System.out.println(maxValue); // 6
    }
}
```

#### 📜 对应LeetCode

- 👻 [474 - 一和零](计算机基础/算法/LeetCode/动态规划/474-一和零.md)
- 👻 [416 - 分割等和子集](计算机基础/算法/LeetCode/动态规划/416-分割等和子集.md)

### ② 完全背包问题

#### Ⅰ 最优子结构

#### Ⅱ 状态转移方程

#### Ⅲ 实现状态转移方程

#### 📜  对应 LeetCode

## ✍ LeetCode 汇总 — 动态规划

- 😎 [1025 - 除数博弈](计算机基础/算法/LeetCode/动态规划/1025-除数博弈.md)
- 😎 [303 - 区域和检索 - 数组不可变](计算机基础/算法/LeetCode/动态规划/303-区域和检索-数组不可变.md)
- 😎 [53 - 最大连续子序列和](计算机基础/算法/LeetCode/动态规划/53-最大连续子序列和.md)
- 👻 [1143 - 最长公共子序列](计算机基础/算法/LeetCode/动态规划/1143-最长公共子序列.md)
- 👻 [516 - 最长回文子序列](计算机基础/算法/LeetCode/动态规划/516-最长回文子序列.md)
- 👻 [474 - 一和零](计算机基础/算法/LeetCode/动态规划/474-一和零.md)
- 👻 [416 - 分割等和子集](计算机基础/算法/LeetCode/动态规划/416-分割等和子集.md)
- 👻 [300 - 最长上升子序列](计算机基础/算法/LeetCode/动态规划/300-最长上升子序列.md)



## 📚 References

- 《算法导论 — 第 3 版 机械工业出版社》
- [LeetCode](https://leetcode-cn.com/problemset/algorithms/)
- [动态规划算法之矩阵连乘问题思路](https://blog.csdn.net/qq_32919451/article/details/80643118)
- [动态规划---矩阵连乘问题](https://blog.csdn.net/qq_22238021/article/details/78859946?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)
- [labuladong 的算法小抄](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bei-bao-wen-ti)