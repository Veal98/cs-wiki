# ğŸƒ 4 - é‡å»ºäºŒå‰æ ‘

---



### é¢˜ç›®æè¿°

è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºå‡ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚ä¾‹å¦‚è¾“å…¥å‰åºéå†åºåˆ—{1,2,4,7,3,5,6,8}å’Œä¸­åºéå†åºåˆ—{4,7,2,1,5,3,8,6}ï¼Œåˆ™é‡å»ºäºŒå‰æ ‘å¹¶è¿”å›ã€‚



### è§£é¢˜æ€è·¯ï¼š

ä¾‹å¦‚ï¼š

å‰åºåºåˆ—{1,2,4,7,3,5,6,8} = pre

ä¸­åºåºåˆ—{4,7,2,1,5,3,8,6} = in



- æ ¹æ®å½“å‰å‰åºåºåˆ—çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ç¡®å®šæ ¹ç»“ç‚¹ï¼Œä¸º 1
- æ‰¾åˆ° 1 åœ¨ä¸­åºéå†åºåˆ—ä¸­çš„ä½ç½®ï¼Œä¸º in[3]
- åˆ‡å‰²å·¦å³å­æ ‘ï¼Œåˆ™ in[3] å‰é¢çš„ä¸ºå·¦å­æ ‘ï¼Œ in[3] åé¢çš„ä¸ºå³å­æ ‘
- åˆ™åˆ‡å‰²åçš„å·¦å­æ ‘å‰åºåºåˆ—ä¸ºï¼š{2,4,7}ï¼Œåˆ‡å‰²åçš„å·¦å­æ ‘ä¸­åºåºåˆ—ä¸ºï¼š{4,7,2}ï¼›
- åˆ‡å‰²åçš„å³å­æ ‘å‰åºåºåˆ—ä¸ºï¼š{3,5,6,8}ï¼Œåˆ‡å‰²åçš„å³å­æ ‘ä¸­åºåºåˆ—ä¸ºï¼š{5,3,8,6}
- å¯¹å­æ ‘åˆ†åˆ«ä½¿ç”¨åŒæ ·çš„æ–¹æ³•åˆ†è§£



### å…·ä½“ä»£ç ï¼š

- C++

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        int len = vin.size();
        if(len <= 0)
            return NULL;
        // å­˜å‚¨åœ¨å‰åºéå†å’Œä¸­åºéå†åºåˆ—ä¸­çš„å·¦å³å­æ ‘é¡ºåº
        vector<int> pre_left, pre_right;
        vector<int> vin_left, vin_right;
        // 1. åˆ›å»ºæ ¹èŠ‚ç‚¹ï¼Œå³å…ˆåºéå†çš„ç¬¬ä¸€ä¸ªç»“ç‚¹
        TreeNode *root = new TreeNode(pre[0]);
        // 2. åœ¨ä¸­åºéå†ä¸­æŸ¥æ‰¾æ ¹èŠ‚ç‚¹, ä¸‹æ ‡å­˜æ”¾åœ¨indexä¸­
        int index = 0;
        for(int i = 0; i < len; i++){
            if(vin[i] == pre[0]){
                index = i;
                break;
            }
        }
        // 3. ä¸­åºéå†ä¸­æ ¹èŠ‚ç‚¹çš„å·¦ä¾§ä¸ºå·¦å­æ ‘ï¼Œå³ä¾§ä¸ºå³å­æ ‘
        //    æ ¹æ® ä¸­åºéå†å·¦/å³å­æ ‘çš„æ•°é‡ ç¡®å®š å·¦/å³å­æ ‘åœ¨å…ˆåºéå†ä¸­çš„åºåˆ—
        for(int i = 0; i < index; i++){
            vin_left.push_back(vin[i]);
            pre_left.push_back(pre[i+1]);
        }
        for(int i = index+1; i<len; i++){
            vin_right.push_back(vin[i]);
            pre_right.push_back(pre[i]);
        }
        
        //4. é€’å½’
        root->left = reConstructBinaryTree(pre_left, vin_left);
        root->right = reConstructBinaryTree(pre_right, vin_right);
        
        return root;
    }
};
```



- Java

```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
import java.util.Arrays;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        int len = pre.length;
        if(pre.length <= 0 || in.length <= 0)
            return null;
        TreeNode root = new TreeNode(pre[0]);
        for(int i = 0; i < len; i++){
            if(in[i] == pre[0]){
                //copyOfRangeæ˜¯å·¦é—­å³å¼€çš„
                //å·¦å­æ ‘
                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,1,i+1), Arrays.copyOfRange(in,0,i));
                // å³å­æ ‘
                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,i+1,len), Arrays.copyOfRange(in,i+1,len));
                
                break;
            }
        }
        return root;
    }
}
```



> - å…³äºJavaä¸­çš„`Arrays.copyOfRange()` æ–¹æ³•
>    è¦ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ï¼Œé¦–å…ˆè¦ `import java.util.*;`
>    Arrays.copyOfRange(T[ ] original,int from,int to)
>    å°†ä¸€ä¸ªåŸå§‹çš„æ•°ç»„originalï¼Œä»ä¸‹æ ‡fromå¼€å§‹å¤åˆ¶ï¼Œå¤åˆ¶åˆ°ä¸Šæ ‡toï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„æ•°ç»„ã€‚
>    æ³¨æ„è¿™é‡Œ`åŒ…æ‹¬ä¸‹æ ‡fromï¼Œä¸åŒ…æ‹¬ä¸Šæ ‡to` ã€‚