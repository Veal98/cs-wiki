# å“ˆå¸Œè¡¨

---

å“ˆå¸Œè¡¨ä½¿ç”¨ O(N) ç©ºé—´å¤æ‚åº¦å­˜å‚¨æ•°æ®ï¼Œå¹¶ä¸”ä»¥ O(1) æ—¶é—´å¤æ‚åº¦æ±‚è§£é—®é¢˜ã€‚é€šå¸¸æ¥è¯´ï¼Œä½¿ç”¨å“ˆå¸Œè¡¨å¯ä»¥å¸®åŠ©æˆ‘ä»¬é™ä½æ—¶é—´å¤æ‚åº¦ï¼ˆç”¨ç©ºé—´æ¢æ—¶é—´ï¼‰

## 1. ä¸¤æ•°ä¹‹å’Œ

ğŸ‘‰ [1. ä¸¤æ•°ä¹‹å’Œ â€” Easy](https://leetcode-cn.com/problems/two-sum/)

ã€é¢˜ç›®æè¿°ã€‘ï¼šç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ ä¸èƒ½ä½¿ç”¨ä¸¤éã€‚

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šnums = [2,7,11,15], target = 9
è¾“å‡ºï¼š[0,1]
è§£é‡Šï¼šå› ä¸º nums[0] + nums[1] == 9 ï¼Œè¿”å› [0, 1] ã€‚
```


ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šnums = [3,2,4], target = 6
è¾“å‡ºï¼š[1,2]
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼šæœ€ç®€å•çš„æ€è·¯å°±æ˜¯ç©·ä¸¾

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i ++) {
            for (int j = i+1; j < nums.length; j ++){
                if (nums[i] + nums[j] == target){
                    return new int[]{i, j};
                }
            }
        }
        // ä¸å­˜åœ¨è¿™ä¹ˆä¸¤ä¸ªæ•°
        return new int[] {-1, -1};
    }
}
```

æ—¶é—´å¤æ‚åº¦ O(N^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚

å¯ä»¥**é€šè¿‡ä¸€ä¸ªå“ˆå¸Œè¡¨å‡å°‘æ—¶é—´å¤æ‚åº¦**ï¼šå“ˆå¸Œè¡¨çš„ key å¯¹åº”å…ƒç´ çš„å€¼ï¼Œå“ˆå¸Œè¡¨çš„ value å¯¹åº”å…ƒç´ çš„ä¸‹æ ‡ï¼Œæ¯”å¦‚æŸä¸ªå…ƒç´ å€¼ä¸º 2ï¼Œå°±å°†è¿™ä¸ªå…ƒç´ çš„ä¸‹æ ‡å­˜æ”¾åœ¨å“ˆå¸Œè¡¨çš„ key = 2 çš„ value ä¸Šã€‚è¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦éå†ä¸€éå“ˆå¸Œè¡¨çš„ keyï¼ŒæŸ¥çœ‹ key = target - 2 çš„ä½ç½®ä¸Šå¯¹åº”çš„ value æ˜¯å¦ä¸ºç©ºï¼Œå°±èƒ½çŸ¥é“æœ‰æ²¡æœ‰å…ƒç´ èƒ½å’Œ 2 ç»„æˆ target äº†ã€‚

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        
        HashMap<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < n; i ++) {
            map.put(nums[i], i);
        }
        
        // éå†ç´¢å¼•
        for (int i = 0; i < n; i ++) {
            int j = target - nums[i];
            // å¦‚æœ j å­˜åœ¨ä¸”ä¸æ˜¯ nums[i] æœ¬èº«
            if (map.containsKey(j) && map.get(j) != i) {
                return new int[] {i, map.get(j)};
            }
        }
        
        return new int[] {-1, -1};
    }
}
```

è¿™æ ·ï¼Œç”±äºå“ˆå¸Œè¡¨çš„æŸ¥è¯¢æ—¶é—´ä¸º O(1)ï¼Œç®—æ³•çš„æ—¶é—´å¤æ‚åº¦é™ä½åˆ° O(N)ï¼Œä½†æ˜¯éœ€è¦ O(N) çš„ç©ºé—´å¤æ‚åº¦æ¥å­˜å‚¨å“ˆå¸Œè¡¨ã€‚ä¸è¿‡ç»¼åˆæ¥çœ‹ï¼Œæ˜¯è¦æ¯”æš´åŠ›å¾ªç¯è§£æ³•é«˜æ•ˆçš„ã€‚

## 146. LRU ç¼“å­˜æœºåˆ¶

[146. LRU ç¼“å­˜æœºåˆ¶](https://leetcode-cn.com/problems/lru-cache/)ï¼Œè¶…çº§é«˜é¢‘é¢è¯•é¢˜ï¼ï¼ï¼

ã€é¢˜ç›®æè¿°ã€‘ï¼šè¿ç”¨ä½ æ‰€æŒæ¡çš„æ•°æ®ç»“æ„ï¼Œè®¾è®¡å’Œå®ç°ä¸€ä¸ª  LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜æœºåˆ¶ ã€‚å®ç° LRUCache ç±»ï¼š

- `LRUCache(int capacity)` ä»¥æ­£æ•´æ•°ä½œä¸ºå®¹é‡ capacity åˆå§‹åŒ– LRU ç¼“å­˜
- `int get(int key)` å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› -1 ã€‚
- `void put(int key, int value)` å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ï¼›å¦‚æœå…³é”®å­—ä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥è¯¥ç»„ã€Œå…³é”®å­—-å€¼ã€ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ã€‚


è¿›é˜¶ï¼šä½ æ˜¯å¦å¯ä»¥åœ¨ O(1) æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸¤ç§æ“ä½œï¼Ÿ

ç¤ºä¾‹ï¼š

```
è¾“å…¥
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
è¾“å‡º
[null, null, null, 1, null, -1, null, -1, 3, 4]

è§£é‡Š
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // ç¼“å­˜æ˜¯ {1=1}
lRUCache.put(2, 2); // ç¼“å­˜æ˜¯ {1=1, 2=2}
lRUCache.get(1);    // è¿”å› 1
lRUCache.put(3, 3); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {1=1, 3=3}
lRUCache.get(2);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.put(4, 4); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {4=4, 3=3}
lRUCache.get(1);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.get(3);    // è¿”å› 3
lRUCache.get(4);    // è¿”å› 4
```



ã€è§£é¢˜æ€è·¯ã€‘ï¼šè¯¦è§ [https://mp.weixin.qq.com/s/b0YVCccJ8mFP6lI-1NiQOQ](https://mp.weixin.qq.com/s/b0YVCccJ8mFP6lI-1NiQOQ)ã€‚å¯çŸ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé˜Ÿåˆ—ï¼Œåˆ©ç”¨å…¶å…ˆè¿›åå‡ºçš„æ€æƒ³ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨é“¾è¡¨å®ç°ï¼Œæ¯æ¬¡ä»é“¾è¡¨çš„å°¾éƒ¨æ’å…¥å…ƒç´ ï¼Œå¹¶ä¸”æœ€è¿‘è®¿é—®çš„å…ƒç´ ä¹Ÿå°†å…¶å…ˆåˆ é™¤å†é‡æ–°æ’å…¥é“¾è¡¨çš„å°¾éƒ¨ï¼Œè¿™æ ·ï¼Œé“¾è¡¨çš„é¦–éƒ¨å…ƒç´ å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ã€‚ç”±äº get æ“ä½œéœ€è¦æ ¹æ®ä¸‹æ ‡æ¥è®¿é—®ï¼Œè€Œé“¾è¡¨æ— æ³•å…·å¤‡è¿™æ ·çš„æ€§è´¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ·»åŠ ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œç”¨äºå­˜å‚¨é“¾è¡¨ key çš„æ˜ å°„ï¼Œè¿™ç§æ•°æ®ç»“æ„ä¹Ÿç§°å“ˆå¸Œé“¾è¡¨ã€‚æ¥ä¸‹æ¥æˆ‘ä¼šå…ˆè‡ªå·±å®ç°è¿™ä¸ªæ•°æ®ç»“æ„ï¼Œç„¶åå†ç›´æ¥ä½¿ç”¨ Java çš„ LinkedHashMapï¼š

ä¸‹é¢è¿™æ®µä»£ç æ˜¯ä½¿ç”¨æˆ‘ä»¬è‡ªå·±å®ç°çš„å“ˆå¸Œé“¾è¡¨ï¼š

```java
class LRUCache {

    private HashMap<Integer, Node> map; // å“ˆå¸Œè¡¨ key-Node
    private DoubleList cache; // åŒå‘é“¾è¡¨ key-val
    private int capacity; // ç¼“å­˜çš„æœ€å¤§å®¹é‡
    
    // å°†å½“å‰ç¼“å­˜ä¸­æŸä¸ª key-val æå‡ä¸ºæœ€è¿‘ä½¿ç”¨çš„
    private void makeRecently (int key) {
        Node node = map.get(key);
        // å…ˆä»é“¾è¡¨ä¸­åˆ é™¤è¯¥èŠ‚ç‚¹
        cache.remove(node);
        // å†é‡æ–°æ’å…¥è¯¥èŠ‚ç‚¹åˆ°é˜Ÿå°¾
        cache.addLast(node);
    }
    
    // æ·»åŠ ä¸€ä¸ª key-val
    private void addRecently (int key, int val) {
        Node node = new Node(key, val);
        // å°†è¿™ä¸ªæ–°èŠ‚ç‚¹å­˜å…¥é“¾è¡¨å°¾éƒ¨(è¡¨ç¤ºæœ€è¿‘ä½¿ç”¨çš„å…ƒç´ )
        cache.addLast(node);
        // å¹¶åœ¨å“ˆå¸Œè¡¨ä¸­å­˜ä¸€ä»½è¿™ä¸ªèŠ‚ç‚¹çš„æ˜ å°„
        map.put(key, node);
    }
    
    // åˆ é™¤æŸä¸ª key-val
    private void delete (int key) {
        Node node = map.get(key);
        // ä»é“¾è¡¨ä¸­åˆ é™¤
        cache.remove(node);
        // å¹¶åˆ é™¤å“ˆå¸Œè¡¨ä¸­çš„æ˜ å°„
        map.remove(key);
    }
    
    // åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„ key-val
    public void removeLeastRencently () {
        // åŒå‘é“¾è¡¨å¤´éƒ¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ èŠ‚ç‚¹å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„
        Node deleteNode = cache.removeFirst();
        // å¹¶åˆ é™¤å“ˆå¸Œè¡¨ä¸­çš„æ˜ å°„
        map.remove(deleteNode.key);
    }
    
    // æ„é€ å‡½æ•°
    public LRUCache(int capacity) {
        map = new HashMap<>();
        cache = new DoubleList();
        this.capacity = capacity;
    }
    
    // ä»ç¼“å­˜ä¸­è·å– key å¯¹åº”çš„ val
    public int get(int key) {
        if (!map.containsKey(key)) {
            // å…³é”®å­— key ä¸åœ¨ç¼“å­˜ä¸­
            return -1;
        }
        // å°†è¯¥æ•°æ®æå‡ä¸ºæœ€è¿‘ä½¿ç”¨çš„
        makeRecently(key);
        return map.get(key).val;
    }
    
    // å°† key-val å­˜å…¥ç¼“å­˜
    public void put(int key, int val) {
        if (map.containsKey(key)) {
            // å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼, å¹¶å°†å…¶æå‡ä¸ºæœ€è¿‘ä½¿ç”¨çš„
            delete(key);
            addRecently(key, val);
            return ;
        }
        
        // å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œåœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼
        if (cache.getSize() == capacity) {
            removeLeastRencently();
        }
        
        // å°†æ–°çš„ key-val æ·»åŠ ä¸ºæœ€è¿‘ä½¿ç”¨çš„å…ƒç´ 
        addRecently(key, val);
    }
}

// èŠ‚ç‚¹
class Node {
    public int key;
    public int val;
    public Node next; // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    public Node pre; // ä¸Šä¸€ä¸ªèŠ‚ç‚¹
    public Node(int key, int val) {
        this.key = key;
        this.val = val;
    }
}

// åŒå‘é“¾è¡¨
class DoubleList {
    public Node head; // å¤´èŠ‚ç‚¹(éå…ƒç´ èŠ‚ç‚¹)
    public Node tail; // å°¾èŠ‚ç‚¹(éå…ƒç´ èŠ‚ç‚¹)
    public int size; // é“¾è¡¨å…ƒç´ æ•°é‡
    
    // æ„é€ å‡½æ•°
    public DoubleList () {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.pre = head;
        size = 0;
    }
    
    // åœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ èŠ‚ç‚¹
    public void addLast (Node node) {
        node.pre = tail.pre;
        node.next = tail;
        tail.pre.next = node;
        tail.pre = node;
        size ++;
    }
    
    // åˆ é™¤é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹
    public void remove (Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
        size --;
    }
    
    // åˆ é™¤é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ èŠ‚ç‚¹
    public Node removeFirst () {
        if (head.next == tail) {
            // é“¾è¡¨ä¸ºç©º
            return null;
        }
        Node first = head.next; // ç¬¬ä¸€ä¸ªå…ƒç´ èŠ‚ç‚¹
        remove(first);
        return first;
    }
    
    // è¿”å›é“¾è¡¨é•¿åº¦
    public int getSize() {
        return this.size;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

æ¥ä¸‹æ¥å†ä½¿ç”¨ Java å°è£…å¥½çš„å“ˆå¸Œé“¾è¡¨ LinkedHashMap æ¥å®ç°ï¼š

```java
class LRUCache {
    
    private LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>(); // key-val
    private int capacity; // ç¼“å­˜çš„æœ€å¤§å®¹é‡
    
    // å°†æŸä¸ª key-val æå‡ä¸ºæœ€è¿‘ä½¿ç”¨çš„
    private void makeRecently(int key) {
        int val = cache.get(key);
        // å…ˆåˆ é™¤
        cache.remove(key);
        // å†ä»å°¾éƒ¨æ’å…¥
        cache.put(key, val);
    }
    
    // æ„é€ å‡½æ•°
    public LRUCache(int capacity) {
        this.capacity = capacity;
    }
    
    // ä»ç¼“å­˜ä¸­è·å– key å¯¹åº”çš„ val
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        // å°† key-val å˜ä¸ºæœ€è¿‘ä½¿ç”¨
        makeRecently(key);
        return cache.get(key);
    }
    
    // å°† key-val å­˜å…¥ç¼“å­˜
    public void put(int key, int val) {
        // å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼, å¹¶å°†å…¶æå‡ä¸ºæœ€è¿‘ä½¿ç”¨çš„
        if (cache.containsKey(key)) {
            cache.put(key, val);
            makeRecently(key);
            return ;
        }
        // å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œåœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼
        if (cache.size() == capacity) {
            // é“¾è¡¨å¤´éƒ¨å°±æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ key
            int deleteKey = cache.keySet().iterator().next();
            cache.remove(deleteKey);
        }
        // å°†æ–°çš„ key-val æ·»åŠ ä¸ºæœ€è¿‘ä½¿ç”¨çš„å…ƒç´ 
        cache.put(key, val);
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

## 347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ 

[347. å‰ K ä¸ªé«˜é¢‘å…ƒç´  â€” Medium](https://leetcode-cn.com/problems/top-k-frequent-elements/)ï¼Œä¿—ç§° TopKï¼Œé¢è¯•é«˜é¢‘é¢˜ã€‚

ã€é¢˜ç›®æè¿°ã€‘ç»™å®šä¸€ä¸ªéç©ºçš„æ•´æ•°æ•°ç»„ï¼Œè¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ k é«˜çš„å…ƒç´ ã€‚

ç¤ºä¾‹ 1:

```
è¾“å…¥: nums = [1,1,1,2,2,3], k = 2
è¾“å‡º: [1,2]
```


ç¤ºä¾‹ 2:

```
è¾“å…¥: nums = [1], k = 1
è¾“å‡º: [1]
```

ã€è§£é¢˜æ€è·¯ã€‘**æ¡¶æ’åº**ã€‚ä½¿ç”¨ä¸€ä¸ª HashMap å­˜å‚¨æ•°ç»„ï¼Œæ•°ç»„çš„å€¼å¯¹åº” Map çš„ Keyï¼Œå€¼å‡ºç°çš„æ¬¡æ•°å¯¹åº” Map çš„ Valueã€‚ç„¶åå†å°†è¿™ä¸ª Map å­˜åˆ°ä¸€ä¸ª List ä¸­ï¼ŒList çš„ä¸‹æ ‡å¯¹åº” Map çš„ Valueï¼Œä¹Ÿå°±æ˜¯å€¼å‡ºç°çš„æ¬¡æ•°ï¼ŒList ä¸­å­˜å‚¨çš„æ•°æ®å°±æ˜¯ Map çš„ Keyï¼Œä¹Ÿå°±æ˜¯æ•°ç»„çš„å€¼ã€‚è¿™æ ·æˆ‘ä»¬ä»åå¾€å‰éå†ä¸€ä¸‹ Listï¼Œå°±èƒ½æ‰¾åˆ° topKã€‚

![](https://gitee.com/veal98/images/raw/master/img/20210309162849.png)

> å¯¹äº TopK é—®é¢˜ï¼Œå †æ’åºä¹Ÿæ˜¯ä¸€æŠŠå¥½æ‰‹ï¼Œæ—¥åæœ‰æ—¶é—´å†æ¥è¡¥å……å †æ’çš„è§£æ³•

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int len = nums.length;
        if (k > len || len <= 0) {
            return null;
        }
        
        // key: æ•°å€¼ï¼Œvalue: å€¼å‡ºç°çš„æ¬¡æ•°
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < len; i ++) {
            int key = nums[i];
            if (map.containsKey(key)) {
                // æ¬¡æ•° +1
                map.put(key, map.get(key) + 1);
            }
            else {
                map.put(key, 1);
            }
        }
        
        // ä¸‹æ ‡ï¼šå€¼å‡ºç°çš„æ¬¡æ•°ï¼Œvalue: æ•°å€¼
        // å› ä¸ºä¸‹æ ‡ 0 æ˜¯ä¸å­˜å‚¨æ•°æ®çš„ï¼Œæ‰€ä»¥éœ€è¦å¼€è¾Ÿ len + 1 çš„å†…å­˜ç©ºé—´
        ArrayList<Integer>[] list = new ArrayList[len + 1];
        for (int key : map.keySet()) {
            int value = map.get(key); // ä¸‹æ ‡
            if (list[value] == null) {
                // å­˜æ•°æ®å‰éœ€è¦å…ˆå¼€è¾Ÿç©ºé—´
                list[value] = new ArrayList<>();
            }
            
            list[value].add(key);
        }
        
        // ä»åå¾€å‰éå† ArrayList
        int[] res = new int[k];
        int index = 0; // res çš„ä¸‹æ ‡
        for (int i = list.length-1; i > 0 && index < k; i --) {
            if (list[i] == null) {
                continue;
            }
            // å°† list[i] ä¸­çš„æ•°åŠ å…¥ res
            for (int num : list[i]) {
                res[index] = num;
                index ++;
            }
        }
        
        return res;
     }
}
```

## 287. å¯»æ‰¾é‡å¤æ•°

[287. å¯»æ‰¾é‡å¤æ•°](https://leetcode-cn.com/problems/find-the-duplicate-number/)

ç»™å®šä¸€ä¸ªåŒ…å« n + 1 ä¸ªæ•´æ•°çš„æ•°ç»„ nums ï¼Œå…¶æ•°å­—éƒ½åœ¨ 1 åˆ° n ä¹‹é—´ï¼ˆåŒ…æ‹¬ 1 å’Œ nï¼‰ï¼Œå¯çŸ¥è‡³å°‘å­˜åœ¨ä¸€ä¸ªé‡å¤çš„æ•´æ•°ã€‚

å‡è®¾ nums åªæœ‰ ä¸€ä¸ªé‡å¤çš„æ•´æ•° ï¼Œæ‰¾å‡º è¿™ä¸ªé‡å¤çš„æ•° ã€‚

```java
class Solution {
    public int findDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        
        for (int i = 0; i < nums.length; i ++) {
            if (set.contains(nums[i])) {
                return nums[i];
            }
            set.add(nums[i]);
        }
        
        return -1;
    }
}
```

## 1394. æ‰¾å‡ºæ•°ç»„ä¸­çš„å¹¸è¿æ•°

[1394. æ‰¾å‡ºæ•°ç»„ä¸­çš„å¹¸è¿æ•° â€” Easy](https://leetcode-cn.com/problems/find-lucky-integer-in-an-array/)

ã€é¢˜ç›®æè¿°ã€‘åœ¨æ•´æ•°æ•°ç»„ä¸­ï¼Œå¦‚æœä¸€ä¸ªæ•´æ•°çš„å‡ºç°é¢‘æ¬¡å’Œå®ƒçš„æ•°å€¼å¤§å°ç›¸ç­‰ï¼Œæˆ‘ä»¬å°±ç§°è¿™ä¸ªæ•´æ•°ä¸ºã€Œå¹¸è¿æ•°ã€ã€‚

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `arr`ï¼Œè¯·ä½ ä»ä¸­æ‰¾å‡ºå¹¶è¿”å›ä¸€ä¸ªå¹¸è¿æ•°ã€‚

- å¦‚æœæ•°ç»„ä¸­å­˜åœ¨å¤šä¸ªå¹¸è¿æ•°ï¼Œåªéœ€è¿”å› **æœ€å¤§** çš„é‚£ä¸ªã€‚
- å¦‚æœæ•°ç»„ä¸­ä¸å«å¹¸è¿æ•°ï¼Œåˆ™è¿”å› **-1** ã€‚

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šarr = [2,2,3,4]
è¾“å‡ºï¼š2
è§£é‡Šï¼šæ•°ç»„ä¸­å”¯ä¸€çš„å¹¸è¿æ•°æ˜¯ 2 ï¼Œå› ä¸ºæ•°å€¼ 2 çš„å‡ºç°é¢‘æ¬¡ä¹Ÿæ˜¯ 2 ã€‚
```

ã€è§£é¢˜æ€è·¯ã€‘HashMapï¼Œkey å­˜å‚¨æ•°å€¼ï¼Œvalue å­˜å‚¨è¯¥æ•°å‡ºç°çš„æ¬¡æ•°

```java
class Solution {
    public int findLucky(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < arr.length; i ++) {
            if (map.containsKey(arr[i])) {
                map.put(arr[i], map.get(arr[i]) + 1);
            }
            else {
                map.put(arr[i], 1);
            }
        }
        
        int max = -1; // è®°å½•æœ€å¤§å¹¸è¿æ•°
        
        for (int num : map.keySet()) {
            if (num == map.get(num)) {
                max = Math.max(max, num);        
            }
            
        }
        
        return max;
    }
}
```

## 387. å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªå”¯ä¸€å­—ç¬¦

ã€é¢˜ç›®æè¿°ã€‘ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°å®ƒçš„ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦ï¼Œå¹¶è¿”å›å®ƒçš„ç´¢å¼•ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å› -1ã€‚

ç¤ºä¾‹ï¼š

```
s = "leetcode"
è¿”å› 0

s = "loveleetcode"
è¿”å› 2
```

ã€è§£é¢˜æ€è·¯ã€‘HashMapï¼škey å­˜å‚¨å­—ç¬¦ï¼Œvalue å­˜å‚¨è¿™ä¸ªå­—ç¬¦é¦–æ¬¡å‡ºç°çš„ä¸‹æ ‡ã€‚å¦‚æœä¸€ä¸ªå­—ç¬¦é‡å¤å‡ºç°ï¼Œå°±å°†å…¶ä¸‹æ ‡ç½®ä¸º -1ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬éå†ä¸€é Mapï¼Œæ‰¾åˆ°æœ€å°çš„ä¸ä¸º -1 çš„ value å³å¯ã€‚ 

```java
class Solution {
    public int firstUniqChar(String s) {
        
        if (s == "" || s.length() == 0) {
            return -1;
        }
        
        // key: å­—ç¬¦ value: é¦–æ¬¡å‡ºç°çš„ä¸‹æ ‡
        HashMap<Character,Integer> map = new HashMap<>();
    
        for (int i = 0; i < s.length(); i ++) {
            char ch = s.charAt(i);
            if (map.containsKey(ch)) {
                // é‡å¤å‡ºç°
                map.put(ch, -1);
            }
            else {
                // åªå‡ºç°ä¸€æ¬¡
                map.put(ch, i);
            }
        }
    
        // éå† mapï¼Œæ‰¾åˆ°æœ€å°çš„ä¸ä¸º -1 çš„ value
        int res = Integer.MAX_VALUE;
        for (char i : map.keySet()) {
            if (map.get(i) != -1) {
                res = Math.min(res, map.get(i));
            }
        }
        
        return res == Integer.MAX_VALUE ? -1 : res;
    }
}
```

