# 416. 分割等和子集

---

👉 [416. Partition Equal Subset Sum — Medium](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

## 📜 题目描述

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

示例 1：

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```


示例 2：

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

## 💡 解题思路

**【动态规划】**：类似于 0-1 背包问题：给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性，且每个物品只有一件。其中第 `i` 个物品的重量为 `w[i]`，价值为 `v[i]`，现在让你用这个背包装物品，以获得最大价值，且每个物品只能使用一次。

本题要求将一个数组分成两部分，每部分的和相等，令数组所有数的和为 `sum`，则每个部分的和为 `sum/2`。OK，将这个问题转换成 0-1 背包问题：给一个可装载数值为 sum/2 （类比于背包问题的可装载重量）的背包和 N 个数字（类比于背包问题的 N 个物品），每个物品的数值为 `nums[i]`（类比于背包问题的每个物品的重量）。且每个数字只能使用一次。现在开始用这个背包装物品，是否存在一种方法，能够正好将背包装满（即存在一种划分方法，使得左(右)部分的和等于 `sum/2`）

显然，本题唯一的最大不同点就在于：

- 0-1 背包问题选取的物品的容积总量 **不能超过** 规定的总量；
- 本题选取的数字之和需要 **恰好等于** 规定的和的一半。

按照 0-1 背包问题的套路，状态就是「子集之和」和「可选择的数字」，选择就是「加入子集」或者「不加入子集」。可以给出如下定义：

**`dp[i][j] = true/false` 表示，对于前 `i` 个数字，能否使得它们的和恰好等于 `j`。**比如说，如果 `dp[4][9] = true`，其含义为：对于给定的集合中，若只对前 4 个数字进行选择，存在一个子集的和可以恰好凑出 9。根据这个定义，**我们想求的最终答案就是 `dp[N][sum/2]`**。

**base case** 就是 `dp[..][0] = true` 和 `dp[0][..] = false`，因为背包没有空间 (所需要的数值和达到了) 的时候，就相当于装满了，而当没有物品（数字）可选择的时候，肯定没办法装满背包。

下面开始写状态转移方程：

- 首先，如果背包容量不足，不能装入第 `i` 个物品（对应 `nums `数组下标 `i - 1`)，即 `nums[i-1] > j`。那么是否能够恰好装满背包，取决于上一个状态 `dp[i-1][j]`，继承之前的结果。即 `dp[i][j] = dp[i-1][j]`

- 如果背包容量足够，可以考虑装入第 `i` 个物品，即  `nums[i-1] <= j`，我们需要在装入和不装入之间选取最优值：

  - 如果不把第 `i ` 个数算入子集，**或者说你不把这第** **`i`** **个物品装入背包**，那么是否能够恰好装满背包，取决于上一个状态 `dp[i-1][j]`，继承之前的结果。即 `dp[i][j] = dp[i-1][j]`

  - 如果把第 `i` 个数算入子集，**或者说你把这第** **`i`** **个物品装入了背包使得重量恰好为 `j`**，那就意味着在 `[0, i - 1]` 这个子区间内得找到一部分元素，使得它们的和为 `j - nums[i-1]`。 即 `dp[i][j] = dp[i-1][j-nums[i-1]]`。

> 💡 注意，由于计算 `dp[i]` 之前我们需要先计算 `dp[i-1]`，所以我们将 `i` 从 `1` 开始计算，在辅助表的外围加一圈 0 （也就是说 `i = 0` 不作为辅助表的正式计算使用，**辅助表的有效下标从 1 开始**）。**但是第 `i` 个数对应数组的下标的下标是 `i - 1`**。不要搞混了

## ✅  具体代码 

### ① 动态规划基础解法


```java
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        int sum = 0; // 数组和
        for(int num : nums){
            sum += num;
        }
        // 和为奇数时，不可能划分成两个和相等的集合
        if (sum % 2 != 0) return false;

        boolean[][] dp = new boolean[len + 1][sum/2 + 1];

        // base case 
        for(int i = 0; i <= len; i ++)
            dp[i][0] = true;
        /**
        * 可不写，因为 new boolean 的时候已经全部初始化成 false 了
        * for(int i = 0; i <= sum/2; i ++){
        *     dp[0][i] = false;
        * }
        **/

        for(int i = 1; i <= len; i++){
            // 数组只包含正整数，所以 j 也从 1 开始
            for(int j = 1; j <= sum/2; j ++){
                if(nums[i-1] > j){
                    // 第 i 个数大于剩余和 j，不能将第 i 个数装入子集
                    dp[i][j] = dp[i-1][j];
                }
                else{
                    // 转入或不装入子集，择优
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
                }
            }
        }
        return dp[len][sum/2];
    }
}
```

<img src="https://gitee.com/veal98/images/raw/master/img/20201010215839.png" style="zoom:67%;" />

### ② 状态压缩

从上面代码中，注意到 **`dp[i][j]` 只需要上一行的数据  `dp[i-1][..]`** ，所以，我们可以进行状态压缩，将二维 `dp` 数组压缩为一维保存上一次计算的结果（去除第一维即 `dp[i]` 的那一维），节约空间复杂度。并且由判断条件可知只有在 `nums[i-1] <= j` 时，才会考虑是否将该数字加入子集。💡 所以我们只需要修改一下判断条件，**将 `j`  从 `sum/2` 开始依次递减，类似于递归的方式，这样就可以保存上一次计算的结果（子结果）**：

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        int sum = 0; // 数组和
        for(int num : nums){
            sum += num;
        }
        // 和为奇数时，不可能划分成两个和相等的集合
        if (sum % 2 != 0) return false;

        boolean[] dp = new boolean[sum/2 + 1];

        // base case 
        dp[0] = true;

        for(int i = 1; i <= len; i ++){
            for(int j = sum/2; nums[i-1] <= j; j --){
                dp[j] = dp[j] || dp[j-nums[i-1]];
            }
        }
        
        return dp[sum/2];
    }
}
```

<img src="https://gitee.com/veal98/images/raw/master/img/20201010220438.png" style="zoom:67%;" />