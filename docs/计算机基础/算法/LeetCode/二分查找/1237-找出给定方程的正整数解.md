# 1237. æ‰¾å‡ºç»™å®šæ–¹ç¨‹çš„æ­£æ•´æ•°è§£

---

ğŸ‘‰ [1237. Find Positive Integer Solution for a Given Equation â€” Easy](https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/)

## ğŸ“œ é¢˜ç›®æè¿°

Given a function  `f(x, y)` and a value `z`, return all positive integer pairs x and y where `f(x,y) == z`.

The function is constantly increasing, i.e.:

- `f(x, y) < f(x + 1, y)`
- `f(x, y) < f(x, y + 1)`

The function interface is defined like this: 

```java
interface CustomFunction {
public:
  // Returns positive integer f(x, y) for any given positive integer x and y.
  int f(int x, int y);
};
```


For custom testing purposes you're given an integer function_id and a target z as input, where function_id represent one function from an secret internal list, on the examples you'll know only two functions from the list.  

You may return the solutions in any order.

**Example 1**:

```
Input: function_id = 1, z = 5
Output: [[1,4],[2,3],[3,2],[4,1]]
Explanation: function_id = 1 means that f(x, y) = x + y
```

**Example 2**:

```
Input: function_id = 2, z = 5
Output: [[1,5],[5,1]]
Explanation: function_id = 2 means that f(x, y) = x * y
```

**Constraints**:

- 1 <= function_id <= 9

- 1 <= z <= 100

- It's guaranteed that the solutions of f(x, y) == z will be on the range 1 <= x, y <= 1000

- It's also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 <= x, y <= 1000

## ğŸ’¡ è§£é¢˜æ€è·¯ 

**ã€äºŒåˆ†æ³•ã€‘**ï¼šå¯¹äºæ¯ä¸€ä¸ª xï¼Œéƒ½å¯èƒ½æœ‰ä¸€ä¸ª y ä¸ä¹‹å¯¹åº”ï¼Œä½¿å¾— `f(x, y) = z`ã€‚ç”±é¢˜å¯çŸ¥ï¼Œy æ˜¯å•è°ƒé€’å¢çš„ï¼Œå³ä¸é‡å¤ä¸”æœ‰åºçš„ï¼Œç›´æ¥å¯¹ y ä½¿ç”¨æ ‡å‡†çš„äºŒåˆ†æŸ¥æ‰¾å³å¯ã€‚

**ã€åŒæŒ‡é’ˆæ³•ã€‘**ï¼šäºŒåˆ†æ³•åªåˆ©ç”¨äº† y çš„å•è°ƒæ€§ï¼Œå¹¶æœªåˆ©ç”¨  x çš„å•è°ƒæ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆæ³•å¯¹ x å’Œ y è¿›è¡Œç›¸åæ–¹å‘çš„éå†

## âœ…  å…·ä½“ä»£ç  

### â‘  äºŒåˆ†æ³•


```java
/*
 * // This is the custom function interface.
 * // You should not implement it, or speculate about its implementation
 * class CustomFunction {
 *     // Returns f(x, y) for any given positive integers x and y.
 *     // Note that f(x, y) is increasing with respect to both x and y.
 *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)
 *     public int f(int x, int y);
 * };
 */
class Solution {
    public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {

        List<List<Integer>> res = new ArrayList<>();
        // å›ºå®š xï¼Œå¯¹ y è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾
        for(int x = 1; x <= 1000; x ++){
            int left = 1;
            int right = 1000 ;
            while(left <= right){
                int mid = left + (right - left) / 2;
                if(customfunction.f(x, mid) < z)
                    left = mid + 1;
                else if(customfunction.f(x, mid) > z)
                    right = mid - 1;
                else{
                    res.add(new ArrayList<>(Arrays.asList(x, mid)));
                    break;
                }
            }
        }

        return res;
    }
}
```

æ—¶é—´å¤æ‚åº¦ï¼š$O(nlog_{2}n)$

### â‘¡ åŒæŒ‡é’ˆæ³•

```java
class Solution {
    public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {

        List<List<Integer>> res = new ArrayList<>();

        int left = 1;
        int right = 1000 ;
        
        // ç”±äº ï¼ˆ1ï¼Œ4ï¼‰ å’Œ ï¼ˆ4ï¼Œ1ï¼‰ å±äºä¸åŒçš„ç»„åˆï¼Œæ‰€ä»¥æ­¤å¤„çš„å¾ªç¯æ¡ä»¶ä¸æ˜¯ left <= rightï¼Œè€Œæ˜¯ left <= 1000 && right >= 1
        while(left <= 1000 && right >= 1){
            if(customfunction.f(left, right) < z)
                left ++;
            else if(customfunction.f(left, right) > z)
                right --;
            else{
                res.add(new ArrayList<>(Arrays.asList(left, right)));
                left ++;
                right --;
            }
        }

        return res;
    }
}
```

