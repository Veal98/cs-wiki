# å…¶ä»–é—®é¢˜

---

## å¹¶æŸ¥é›†

å¹¶æŸ¥é›†å¹¶ä¸æ˜¯çƒ­é—¨è€ƒç‚¹ï¼Œå¸¸ç”¨äºåˆ¤æ–­ä¸€å¯¹å…ƒç´ æ˜¯å¦ç›¸è¿ï¼Œå®ƒä»¬çš„å…³ç³»æ˜¯åŠ¨æ€æ·»åŠ çš„ï¼Œè¿™ä¸€ç±»é—®é¢˜å«ä½œ**åŠ¨æ€è¿é€šæ€§é—®é¢˜**ã€‚

![](https://gitee.com/veal98/images/raw/master/img/20210511200741.png)

### CD66. å¹¶æŸ¥é›†çš„å®ç°

ã€é¢˜ç›®é“¾æ¥ã€‘ï¼š

- NowCoderï¼š[CD66. å¹¶æŸ¥é›†çš„å®ç°](https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372?tpId=101&tqId=33134&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

ã€é¢˜ç›®æè¿°ã€‘ï¼š

ç»™å®šä¸€ä¸ªæ²¡æœ‰é‡å¤å€¼çš„æ•´å‹æ•°ç»„ arrï¼Œåˆå§‹æ—¶è®¤ä¸º arr ä¸­æ¯ä¸€ä¸ªæ•°å„è‡ªéƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„é›†åˆã€‚è¯·è®¾è®¡ä¸€ç§å« UnionFind çš„ç»“æ„ï¼Œå¹¶æä¾›ä»¥ä¸‹ä¸¤ä¸ªæ“ä½œã€‚

1ï¼‰boolean isSameSet(int a, int b)ï¼šæŸ¥è¯¢ a å’Œ b è¿™ä¸¤ä¸ªæ•°æ˜¯å¦å±äºä¸€ä¸ªé›†åˆã€‚

2ï¼‰void union(int a, int b)ï¼šæŠŠ a æ‰€åœ¨çš„é›†åˆä¸ b æ‰€åœ¨çš„é›†åˆåˆå¹¶åœ¨ä¸€èµ·ï¼ŒåŸæœ¬ä¸¤ä¸ªé›†åˆå„è‡ªçš„å…ƒç´ ä»¥åéƒ½ç®—ä½œåŒä¸€ä¸ªé›†åˆã€‚

è¦æ±‚ï¼š

å¦‚æœè°ƒç”¨ isSameSet å’Œ union çš„æ€»æ¬¡æ•°é€¼è¿‘æˆ–è¶…è¿‡ O(N)ï¼Œè¯·åšåˆ°å•æ¬¡è°ƒç”¨ isSameSet æˆ– union æ–¹æ³•çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(1)ã€‚

è¾“å…¥æè¿°:

```
ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° N, Mã€‚åˆ†åˆ«è¡¨ç¤ºæ•°ç»„å¤§å°ã€æ“ä½œæ¬¡æ•°
æ¥ä¸‹æ¥Mè¡Œï¼Œæ¯è¡Œæœ‰ä¸€ä¸ªæ•´æ•°opt
è‹¥opt = 1ï¼Œåé¢æœ‰ä¸¤ä¸ªæ•°x, yï¼Œè¡¨ç¤ºæŸ¥è¯¢(x, y)è¿™ä¸¤ä¸ªæ•°æ˜¯å¦å±äºåŒä¸€ä¸ªé›†åˆ
è‹¥opt = 2ï¼Œåé¢æœ‰ä¸¤ä¸ªæ•°x, yï¼Œè¡¨ç¤ºæŠŠx, yæ‰€åœ¨çš„é›†åˆåˆå¹¶åœ¨ä¸€èµ·
```

> è¿™ä¸ªé¢˜ç›®çš„è¾“å…¥ N æ•°ç»„å¤§å°ï¼ŒåŒæ—¶ä¹Ÿè¡¨ç¤ºäº†è¿™ä¸ªé›†åˆä¸­æœ‰å“ªäº›æ•°ã€‚
>
> æ¯”å¦‚è¾“å…¥ 4ï¼Œå°±è¡¨ç¤ºé›†åˆä¸­çš„æ•°æ˜¯ 1 2 3 4

è¾“å‡ºæè¿°:

```
å¯¹äºæ¯ä¸ª opt = 1çš„æ“ä½œï¼Œè‹¥ä¸ºçœŸåˆ™è¾“å‡º"Yes"ï¼Œå¦åˆ™è¾“å‡º"No"
```

ç¤ºä¾‹1

```
è¾“å…¥
4 5
1 1 2
2 2 3
2 1 3
1 1 1
1 2 3

è¾“å‡º
No
Yes
Yes

è¯´æ˜
æ¯æ¬¡2æ“ä½œåçš„é›†åˆä¸º
({1}, {2}, {3}, {4})
({1}, {2, 3}, {4})
({1, 2, 3}, {4})
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼š

å…ˆä»‹ç»ä¸‹ä»€ä¹ˆæ˜¯å¹¶æŸ¥é›†ã€‚

å¹¶æŸ¥é›†ç”±ä¸€ç¾¤é›†åˆæ„æˆï¼Œæœ€å¼€å§‹æ—¶æ‰€æœ‰å…ƒç´ å„è‡ªå•ç‹¬æ„æˆä¸€ä¸ªé›†åˆã€‚æ¯”å¦‚ï¼Œæœ‰ä¸€æ‰¹å…ƒç´ arr= {a, b, c, d, e}ï¼Œå¼€å§‹æ—¶å¹¶æŸ¥é›†é‡Œæœ‰ 5 ä¸ªå°é›†åˆï¼Œa å•ç‹¬æ„æˆçš„é›†åˆã€bå•ç‹¬æ„æˆçš„é›†åˆ ..... e å•ç‹¬æ„æˆçš„é›†åˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¹¶æŸ¥é›†å…ˆç»å†åˆå§‹åŒ–çš„è¿‡ç¨‹ã€‚é‚£ä¹ˆå¹¶æŸ¥é›†ä¸­çš„å•ä¸ªé›†åˆæ˜¯ä»€ä¹ˆç»“æ„å‘¢ï¼Ÿå¦‚æœé›†åˆä¸­åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œè®°ä¸ºèŠ‚ç‚¹ aæ—¶ï¼Œå¦‚å›¾ 9-9 æ‰€ç¤ºï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20210508220328.png" style="zoom:80%;" />



å½“é›†åˆä¸­åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œè¿™ä¸ªå…ƒç´ çš„ father ä¸ºè‡ªå·±ã€‚å®ç°è®°å½•èŠ‚ç‚¹ fathe rä¿¡æ¯çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œæˆ‘ä»¬ä½¿ç”¨å“ˆå¸Œè¡¨æ¥ä¿å­˜æ‰€æœ‰å¹¶æŸ¥é›†ä¸­æ‰€æœ‰é›†åˆçš„æ‰€æœ‰å…ƒç´ çš„ father ä¿¡æ¯ï¼Œè®°ä¸º fatherMapã€‚æ¯”å¦‚ï¼Œå¯¹äºè¿™ä¸ªé›†åˆï¼Œåœ¨ fatherMap ä¸­è‚¯å®šæœ‰æŸä¸€æ¡è®°å½•ä¸ºï¼ˆèŠ‚ç‚¹a(key)ï¼ŒèŠ‚ç‚¹a(value)ï¼‰ï¼Œè¡¨ç¤º key èŠ‚ç‚¹çš„ father ä¸º value èŠ‚ç‚¹ã€‚

æ¯ä¸ªå…ƒç´ éƒ½æœ‰ father çš„ä¿¡æ¯ï¼Œè¿˜æœ‰å¦ä¸€ä¸ªä¿¡æ¯å« rankï¼Œåªæœ‰ä»£è¡¨èŠ‚ç‚¹æ‰ä¼šæœ‰è¿™ä¸ªä¿¡æ¯ï¼Œ **rank æ˜¯è¿™ä¸ªé›†åˆä¸€å…±æœ‰å¤šå°‘å…ƒç´ **ã€‚

æ‰€è°“ä»£è¡¨èŠ‚ç‚¹å°±æ˜¯è¯´ï¼šå½“ä¸€ä¸ªé›†åˆæœ‰å¤šä¸ªèŠ‚ç‚¹æ—¶ï¼Œ**ä¸‹å±‚èŠ‚ç‚¹çš„ father ä¸ºä¸Šå±‚èŠ‚ç‚¹ï¼Œæœ€ä¸Šå±‚çš„èŠ‚ç‚¹ father æŒ‡å‘è‡ªå·±ï¼Œæœ€ä¸Šå±‚çš„èŠ‚ç‚¹å«è¿™ä¸ªé›†åˆçš„ä»£è¡¨èŠ‚ç‚¹**ã€‚

é›†åˆä¸­åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œè¿™ä¸ªå…ƒç´ ä¹Ÿå°±æ˜¯ä»£è¡¨èŠ‚ç‚¹ï¼Œå…¶ rank åˆå§‹åŒ–ä¸º1ã€‚æ‰€æœ‰ä»£è¡¨èŠ‚ç‚¹çš„ rank ä¿¡æ¯ä¿å­˜åœ¨ rankMap ä¸­ã€‚

å¦‚ä¸‹å›¾ï¼Œa å°±æ˜¯è¿™ä¸ªé›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ï¼š

<img src="https://gitee.com/veal98/images/raw/master/img/20210508223834.png" style="zoom: 50%;" />

**åœ¨å¹¶æŸ¥é›†ä¸­ï¼Œè‹¥è¦æŸ¥ä¸€ä¸ªèŠ‚ç‚¹å±äºå“ªä¸ªé›†åˆï¼Œå…¶å®å°±æ˜¯åœ¨æŸ¥è¿™ä¸ªèŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹æ˜¯ä»€ä¹ˆ**ï¼Œä¸€ä¸ªèŠ‚ç‚¹é€šè¿‡ father ä¿¡æ¯é€æ¸æ‰¾åˆ°æœ€ä¸Šé¢çš„èŠ‚ç‚¹ï¼Œ**å½“æ‰¾åˆ°æŸä¸ªèŠ‚ç‚¹çš„ father æ˜¯è‡ªå·±æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯è¿™ä¸ªé›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ï¼ˆæ­¤å¤„ç§°å‘¼ä¸º â€œé¢†é˜Ÿâ€ å¯èƒ½æ›´å®¹æ˜“ç†è§£ï¼‰**ã€‚

æ¯”å¦‚ä¸Šå›¾ä¸­ï¼Œä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹æœ€ç»ˆéƒ½æ‰¾åˆ°èŠ‚ç‚¹ aï¼Œæ¯”å¦‚èŠ‚ç‚¹ gã€‚å¦‚æœå¦å¤–ä¸€ä¸ªèŠ‚ç‚¹å‡è®¾ä¸º zï¼Œæ‰¾åˆ°çš„ä»£è¡¨èŠ‚ç‚¹ä¸æ˜¯èŠ‚ç‚¹ aï¼Œé‚£ä¹ˆå¯ä»¥è‚¯å®šèŠ‚ç‚¹ g å’ŒèŠ‚ç‚¹ z ä¸åœ¨ä¸€ä¸ªé›†åˆä¸­ã€‚



é€šè¿‡ä¸€ä¸ªèŠ‚ç‚¹æ‰¾åˆ°æ‰€åœ¨é›†åˆä»£è¡¨èŠ‚ç‚¹çš„è¿‡ç¨‹å«ä½œ findFather è¿‡ç¨‹ã€‚findFather æœ€ç»ˆä¼šè¿”å›ä»£è¡¨èŠ‚ç‚¹ï¼Œä½†è¿‡ç¨‹å¹¶ä¸ä»…æ˜¯å•çº¯çš„æŸ¥æ‰¾è¿‡ç¨‹ï¼Œè¿˜ä¼š**æŠŠæ•´ä¸ªæŸ¥æ‰¾è·¯å¾„å‹ç¼©**ã€‚æ¯”å¦‚ï¼Œæ‰§è¡Œ findFather(g)ï¼Œé€šè¿‡ father é€æ¸å‘ä¸Šï¼Œæ‰¾åˆ°æœ€ä¸Šå±‚èŠ‚ç‚¹ a ä¹‹åï¼Œä¼š**æŠŠä» a åˆ° g è¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„ father éƒ½è®¾ç½®ä¸º a**ã€‚

ç»è¿‡è·¯å¾„å‹ç¼©ä¹‹åï¼Œè·¯å¾„ä¸Šæ¯ä¸ªèŠ‚ç‚¹ä¸‹æ¬¡åœ¨æ‰¾ä»£è¡¨èŠ‚ç‚¹çš„æ—¶å€™éƒ½åªéœ€ç»è¿‡ä¸€æ¬¡ç§»åŠ¨è¿‡ç¨‹ã€‚è¿™ä¹Ÿæ˜¯æ•´ä¸ªå¹¶æŸ¥é›†ç»“æ„è®¾è®¡ä¸­æœ€é‡è¦çš„ä¼˜åŒ–ã€‚

<img src="https://gitee.com/veal98/images/raw/master/img/20210508224041.png" style="zoom:50%;" />

OKï¼Œæ¥ä¸‹æ¥ä»‹ç»é›†åˆå¦‚ä½•åˆå¹¶ã€‚

é¦–å…ˆï¼Œä¸¤ä¸ªé›†åˆè¿›è¡Œåˆå¹¶æ“ä½œæ—¶ï¼Œå‚æ•°å¹¶ä¸æ˜¯ä¸¤ä¸ªé›†åˆï¼Œè€Œæ˜¯å¹¶æŸ¥é›†ä¸­ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œè®°ä¸º a å’Œ bã€‚

æ‰€ä»¥é›†åˆçš„åˆå¹¶æ›´å‡†ç¡®çš„è¯´æ³•æ˜¯ï¼Œæ ¹æ® a æ‰¾åˆ° a æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ï¼Œè®°ä¸º aFï¼Œæ ¹æ® b æ‰¾åˆ° b æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ï¼Œè®°ä¸º bFï¼Œç„¶åç”¨å¦‚ä¸‹ç­–ç•¥å†³å®šç”±å“ªä¸ªä»£è¡¨èŠ‚ç‚¹ä½œä¸ºåˆå¹¶åå¤§é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ã€‚

1ï¼‰å¦‚æœaF == bFï¼Œè¯´æ˜aå’Œbæœ¬èº«å°±åœ¨ä¸€ä¸ªé›†åˆé‡Œï¼Œä¸ç”¨åˆå¹¶ã€‚

2ï¼‰å¦‚æœ aF! =bFï¼Œå› ä¸º aF å’Œ bF æ˜¯å„è‡ªé›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥åœ¨ rankMap ä¸­æŸ¥è¯¢åˆ° aF çš„ rank å€¼ï¼Œè®°ä¸º aFrank, bF çš„ rank å€¼è®°ä¸º bFrankï¼ˆrank å°±æ˜¯ä¸€ä¸ªé›†åˆçš„èŠ‚ç‚¹ä¸ªæ•°ï¼‰

- å¦‚æœ aFrank<bFrankï¼Œé‚£ä¹ˆæŠŠ aF çš„ father è®¾ä¸º bFï¼Œè¿™ä¹ˆåšçš„å«ä¹‰æ˜¯ aF æ‰€åœ¨çš„é›†åˆèŠ‚ç‚¹æ•°è¾ƒå°‘ï¼Œæ‰€ä»¥æ”¾åœ¨äº† bF æ‰€åœ¨çš„é›†åˆé‡Œï¼ŒåŒæ—¶æ›´æ–° bFrank += aFrankï¼Œå› ä¸º aF æ‰€åœ¨çš„é›†åˆå·²åˆå¹¶ï¼ŒåŒæ—¶åˆ é™¤ aF çš„ rank ä¿¡æ¯ï¼Œå› ä¸º aF ä¸å†æ˜¯ä»»ä½•é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ã€‚
- å¦‚æœ aFrank > bFrankï¼Œå°±æŠŠ bF çš„ father è®¾ä¸ºaFã€‚åŒæ—¶æ›´æ–° aFrank += bFrankï¼Œå¹¶åˆ é™¤bFçš„rankä¿¡æ¯ï¼Œå› ä¸º bF ä¸å†æ˜¯ä»»ä½•é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ã€‚
- å¦‚æœ aFrank==bFrankï¼Œé‚£ä¹ˆ aF å’Œ bF è°åšå¤§é›†åˆçš„ä»£è¡¨éƒ½å¯ä»¥ï¼Œä½†ä¸è¦å¿˜è®°æ›´æ–° rankMap

<img src="https://gitee.com/veal98/images/raw/master/img/20210508224719.png" style="zoom: 67%;" />

ã€å…·ä½“ä»£ç ã€‘ï¼š

```java
import java.util.*;

public class CD66 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); //  æ•°ç»„å¤§å°
        int M = sc.nextInt(); // æ“ä½œæ¬¡æ•°

        // æ„é€ å¹¶æŸ¥é›†
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < N; i ++) {
            list.add(i + 1);
        }
        UnionFindSet<Integer> unionFindSet = new UnionFindSet<>(list);

        sc.nextLine();

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < M; i ++) {
            String[] line = sc.nextLine().split(" ");
            String opt = line[0];
            int a = Integer.parseInt(line[1]);
            int b = Integer.parseInt(line[2]);
            if (opt.equals("1")) {
                // åˆ¤æ–­æ˜¯å¦å±äºåŒä¸€é›†åˆ
                if (unionFindSet.isSameSet(a, b)) {
                    sb.append("Yes");
                    sb.append("\n");
                }
                else {
                    sb.append("No");
                    sb.append("\n");
                }
            }
            else if (opt.equals("2")) {
                // åˆå¹¶
                unionFindSet.union(a, b);
            }
        }

        System.out.print(sb);
    }

    static class UnionFindSet<V> {
        private HashMap<V, Element<V>> elementMap; // key: èŠ‚ç‚¹çš„å€¼ value: èŠ‚ç‚¹æœ¬èº«
        private HashMap<Element<V>, Element<V>> fatherMap; // key èŠ‚ç‚¹çš„ father ä¸º value èŠ‚ç‚¹
        private HashMap<Element<V>, Integer> rankMap; // key: ä»£è¡¨èŠ‚ç‚¹ value: ä»£è¡¨èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„èŠ‚ç‚¹ä¸ªæ•°

        // åˆå§‹åŒ–å¹¶æŸ¥é›†
        public UnionFindSet(List<V> list) {
            elementMap = new HashMap<>();
            fatherMap = new HashMap<>();
            rankMap = new HashMap<>();
            for (V value : list) {
                Element<V> element = new Element<>(value);
                elementMap.put(value, element);
                fatherMap.put(element, element);
                rankMap.put(element, 1);
            }
        }

        // æ‰¾åˆ° element èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
        public Element<V> findFather(Element<V> element) {
            Stack<Element<V>> path = new Stack<>();
            // ä»£è¡¨èŠ‚ç‚¹çš„ father ä¸€å®šæŒ‡å‘ä»£è¡¨èŠ‚ç‚¹æœ¬èº«
            while (element != fatherMap.get(element)) {
                path.push(element);
                element = fatherMap.get(element);
            }
            // è·¯å¾„å‹ç¼©ï¼Œå°†è¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„fatheréƒ½è®¾ç½®ä¸ºè¿™ä¸ªä»£è¡¨èŠ‚ç‚¹
            while (!path.isEmpty()) {
                fatherMap.put(path.pop(), element);
            }

            return element;
        }

        // åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦å¤„åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼ˆå…¶å®å°±æ˜¯åˆ¤æ–­å®ƒä»¬æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ï¼‰
        public boolean isSameSet(V a, V b) {
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                return findFather(elementMap.get(a)) == findFather(elementMap.get(b));
            }

            return false;
        }

        // åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆ
        public void union(V a, V b) {
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                Element<V> aF = findFather(elementMap.get(a)); // æ‰¾åˆ° a èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
                Element<V> bF = findFather(elementMap.get(b)); // æ‰¾åˆ° b èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
                if (aF != bF) {
                    // ä¸¤ä¸ªèŠ‚ç‚¹ä¸åœ¨åŒä¸€ä¸ªé›†åˆ
                    Element<V> big = rankMap.get(aF) >= rankMap.get(bF) ? aF : bF;
                    Element<V> small = big == aF ? bF : aF;
                    fatherMap.put(small, big);
                    rankMap.put(big, rankMap.get(aF) + rankMap.get(bF));
                    rankMap.remove(small);
                }
            }
        }
    }

    static class Element<V> {
        public V value;
        public Element(V value) {
            this.value = value;
        }
    }
}
```

è¿™æ®µä»£ç æ— æ³• ACï¼Œè¿è¡Œè¶…æ—¶

![](https://gitee.com/veal98/images/raw/master/img/20210508233723.png)

è€ƒè™‘å¯¹è¿™æ®µä»£ç ä¸­çš„å¹¶æŸ¥é›†ç»“æ„è¿›è¡Œç›¸åº”çš„ç®€åŒ–ï¼Œå»é™¤æ³›å‹ã€‚è€Œä¸”å¯¹äºè¿™é“é¢˜ç›®ï¼Œæ•°å­—ä» 1 å¼€å§‹ï¼Œå¹¶ä¸”æ˜¯è¿ç»­çš„ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥ä½¿ç”¨æ•°ç»„ä»£æ›¿ HashMapï¼Œç›´æ¥ç”¨ä¸‹æ ‡åš keyã€‚

```java

import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); //  æ•°ç»„å¤§å°
        int M = sc.nextInt(); // æ“ä½œæ¬¡æ•°

        // æ„é€ å¹¶æŸ¥é›†
        UnionFindSet unionFindSet = new UnionFindSet(N);

        // åŒä¸Š
    }

    static class UnionFindSet<V> {
        private int[] father; // ä¸‹æ ‡ï¼šèŠ‚ç‚¹çš„å€¼ï¼Œ valueï¼š è¯¥èŠ‚ç‚¹çš„ father èŠ‚ç‚¹
        private int[] rank; // ä¸‹æ ‡ï¼šä»£è¡¨èŠ‚ç‚¹çš„å€¼ï¼Œ value: è¯¥ä»£è¡¨èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„èŠ‚ç‚¹ä¸ªæ•°

        // ä½¿ç”¨ä» 1 åˆ° n çš„æ•´æ•°åˆå§‹åŒ–å¹¶æŸ¥é›†
        public UnionFindSet(int n) {
            father = new int[n + 1];
            rank = new int[n + 1];
            for (int i = 1; i <= n; i ++) {
                father[i] = i;
                rank[i] = 1;
            }
        }

        // æ‰¾åˆ° x èŠ‚ç‚¹(å€¼ä¸º xï¼Œå³ä¸‹æ ‡ä¸º x)æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
        public int findFather(int x) {
            Stack<Integer> path = new Stack<>();
            // ä»£è¡¨èŠ‚ç‚¹çš„ father ä¸€å®šæŒ‡å‘ä»£è¡¨èŠ‚ç‚¹æœ¬èº«
            while (father[x] != x) {
                path.push(x);
                x = father[x];
            }

            // è·¯å¾„å‹ç¼©ï¼Œå°†è¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„fatheréƒ½è®¾ç½®ä¸ºè¿™ä¸ªä»£è¡¨èŠ‚ç‚¹
            while (!path.isEmpty()) {
                father[path.pop()] = x;
            }

            return x;
        }

        // åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦å¤„åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼ˆå…¶å®å°±æ˜¯åˆ¤æ–­å®ƒä»¬æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹ï¼‰
        public boolean isSameSet(int a, int b) {
            int aF = findFather(a);
            int bF = findFather(b);
            return aF == bF;
        }

        // åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆ
        public void union(int a, int b) {
            int aF = findFather(a); // æ‰¾åˆ° a èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
            int bF = findFather(b); // æ‰¾åˆ° b èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
            if (aF != bF) {
                // ä¸¤ä¸ªèŠ‚ç‚¹ä¸åœ¨åŒä¸€ä¸ªé›†åˆ
                int big = rank[aF] >= rank[bF] ? aF : bF;
                int small = big == aF ? bF : aF;
                father[small] = big;
                rank[big] = rank[aF] + rank[bF];
            }
        }

    }

}
```

æœç„¶ï¼ŒæˆåŠŸ AC

### LC128. æœ€é•¿è¿ç»­åºåˆ—

ã€é¢˜ç›®é“¾æ¥ã€‘ï¼š

- LeetCodeï¼š[128. æœ€é•¿è¿ç»­åºåˆ— â€” Hard](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

ã€é¢˜ç›®æè¿°ã€‘ï¼š

ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºæ•°å­—è¿ç»­çš„æœ€é•¿åºåˆ—ï¼ˆä¸è¦æ±‚åºåˆ—å…ƒç´ åœ¨åŸæ•°ç»„ä¸­è¿ç»­ï¼‰çš„é•¿åº¦ã€‚

è¿›é˜¶ï¼šä½ å¯ä»¥è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º O(n) çš„è§£å†³æ–¹æ¡ˆå—ï¼Ÿ

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šnums = [100,4,200,1,3,2]
è¾“å‡ºï¼š4
è§£é‡Šï¼šæœ€é•¿æ•°å­—è¿ç»­åºåˆ—æ˜¯ [1, 2, 3, 4]ã€‚å®ƒçš„é•¿åº¦ä¸º 4ã€‚
```


ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šnums = [0,3,7,2,5,8,4,6,0,1]
è¾“å‡ºï¼š9
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼š

è¿™ç¯‡æ–‡ç« è®²çš„å¾ˆ niceï¼š[æ’åº/é›†åˆ/å“ˆå¸Œè¡¨/å¹¶æŸ¥é›† - æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/java-pai-xu-ji-he-ha-xi-biao-bing-cha-ji-by-lzhlyl/)

- åˆå§‹ï¼šæ‰€æœ‰å…ƒç´ å„è‡ªä¸ºæˆ˜
- é¦–æ¬¡éå†ï¼šæ‰€æœ‰å…ƒç´  x å‘å„è‡ªé‚»å±… x + 1ï¼Œå‘èµ·ç»“ç›Ÿï¼Œå¹¶ã€Œä»¥å¤§è€…ä¸ºé¢†é˜Ÿã€
  - è‹¥æœ‰é‚»å±…ï¼Œæ‰ç»“ç›ŸæˆåŠŸ
  - é¢†é˜Ÿï¼Œå³ åŒºé—´å³è¾¹ç•Œ
  - ä¸åªæ˜¯å…ƒç´  x ä¸é‚»å±… x + 1 ç»“ç›Ÿï¼Œè€Œæ˜¯æ•´ä¸ª x æ‰€åœ¨é˜Ÿä¼ä¸æ•´ä¸ª x + 1 æ‰€åœ¨é˜Ÿä¼ç»“ç›Ÿã€‚å¦‚ [1, 2, 3] ä¸ [4, 5] ä¸¤ä¸ªé˜Ÿä¼ç»“ç›Ÿ
- äºŒæ¬¡éå†ï¼šè®°å½•æ‰€æœ‰äººä¸å…¶é¢†é˜Ÿè·ç¦»
  - è·ç¦»ï¼Œå³ åŒºé—´å³è¾¹ç•Œ - å½“å‰å…ƒç´  + 1

ä»£ç ä¸Šå¤§å·®ä¸å·®ï¼Œåªæ˜¯æœ‰å‡ ä¸ªåœ°æ–¹éœ€è¦æ³¨æ„ä¸€ä¸‹ï¼Œä¸‹è¿°ä»£ç é‡Œé¢å·²ç»æ³¨é‡Šå‡ºæ¥äº†ã€‚

ã€å…·ä½“ä»£ç ã€‘ï¼š

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }

        // æ„é€ å¹¶æŸ¥é›†
        UnionFindSet unionFindSet = new UnionFindSet(nums);
        // åˆå¹¶ (æ³¨æ„è¿™é‡Œçš„å–å€¼)
        for (int num : nums) {
            unionFindSet.union(num, num + 1);
        }
        // éå† rankMap, æ‰¾åˆ°åŒ…å«æœ€å¤šæ•°å­—çš„é›†åˆ
        return unionFindSet.getMaxRank();
    }

    class UnionFindSet {
        private HashMap<Integer, Integer> fatherMap; // key: èŠ‚ç‚¹çš„å€¼, value: è¯¥èŠ‚ç‚¹çš„ father èŠ‚ç‚¹
        private HashMap<Integer, Integer> rankMap; // key: ä»£è¡¨èŠ‚ç‚¹çš„å€¼, value: è¯¥ä»£è¡¨èŠ‚ç‚¹æ‰€åœ¨é›†åˆçš„èŠ‚ç‚¹ä¸ªæ•°

        // ä½¿ç”¨æ•°ç»„åˆå§‹åŒ–å¹¶æŸ¥é›†
        public UnionFindSet(int[] nums) {
            fatherMap = new HashMap<>();
            rankMap = new HashMap<>();
            for (int i : nums) {
                fatherMap.put(i, i);
                rankMap.put(i, 1);
            }
        }

        // æ‰¾åˆ° x èŠ‚ç‚¹(å€¼ä¸º x)æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
        public int findFather(int x) {
            Stack<Integer> path = new Stack<>();
            // ä»£è¡¨èŠ‚ç‚¹çš„ father ä¸€å®šæŒ‡å‘ä»£è¡¨èŠ‚ç‚¹æœ¬èº«
            while (fatherMap.get(x) != x) {
                path.push(x);
                x = fatherMap.get(x);
            }

            // è·¯å¾„å‹ç¼©
            while (!path.isEmpty()) {
                fatherMap.put(path.pop(), x);
            }

            return x;
        }

        // åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆ
        public void union(int a, int b) {
            if (fatherMap.containsKey(b)) { // æ³¨æ„ï¼Œè¿™ä¸ª if åˆ¤æ–­ç¨æœ‰ä¸åŒ
                int aF = findFather(a);
                int bF = findFather(b);
                // æœ¬é¢˜æˆ‘ä»¬æ°¸è¿œå°†å€¼è¾ƒå¤§çš„æ•°ä½œä¸ºæ–°çš„ä»£è¡¨èŠ‚ç‚¹
                if (aF != bF) {
                    int big = aF > bF ? aF : bF;
                    int small = big == aF ? bF : aF;
                    fatherMap.put(small, big);
                    rankMap.put(big, rankMap.get(bF) + rankMap.get(aF));
                    rankMap.remove(small);
                }
            }
        }

        // éå† rankMap, æ‰¾åˆ°æœ€å¤§é›†åˆåŒ…å«çš„æ•°å­—ä¸ªæ•°
        public int getMaxRank() {
            int max = Integer.MIN_VALUE;
            for (int key : rankMap.keySet()) {
                max = Math.max(rankMap.get(key), max);
            }
            return max;
        }
    }
}
```

### LC200. å²›å±¿æ•°é‡

ã€é¢˜ç›®é“¾æ¥ã€‘ï¼š

- LeetCodeï¼š[200. å²›å±¿æ•°é‡ â€” Medium](https://leetcode-cn.com/problems/number-of-islands/)

ã€é¢˜ç›®æè¿°ã€‘ï¼š

ç»™ä½ ä¸€ä¸ªç”± '1'ï¼ˆé™†åœ°ï¼‰å’Œ '0'ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚

å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚

æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šgrid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
è¾“å‡ºï¼š1
```


ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šgrid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
è¾“å‡ºï¼š3
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼š

å…³äºè¿é€šæ€§é—®é¢˜ï¼Œå¹¶æŸ¥é›†ä¹Ÿæ˜¯å¸¸ç”¨çš„æ•°æ®ç»“æ„ã€‚

æ€è·¯ï¼š

ä½¿ç”¨å¹¶æŸ¥é›†ä¸­ç»´æŠ¤è¿é€šåˆ†é‡çš„ä¸ªæ•°ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼š

- ç›¸é‚»çš„é™†åœ°ï¼ˆåªéœ€è¦å‘å³çœ‹å’Œå‘ä¸‹çœ‹ï¼‰åˆå¹¶ï¼Œåªè¦å‘ç”Ÿè¿‡åˆå¹¶ï¼Œå²›å±¿çš„æ•°é‡å°±å‡å°‘ 1ï¼›
- åœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼ŒåŒæ—¶è®°å½•æ°´åŸŸç½‘æ ¼çš„æ•°é‡ï¼›
- å¹¶æŸ¥é›†ä¸­è¿é€šåˆ†é‡çš„ä¸ªæ•° - æ°´åŸŸç½‘æ ¼çš„ä¸ªæ•°ï¼Œå°±æ˜¯å²›å±¿æ•°é‡ã€‚

è¿™é‡Œæœ‰ä¸¤ä¸ªå°æŠ€å·§ï¼š

- ç¬¬ä¸€ä¸ªå°æŠ€å·§ï¼š**æŠŠäºŒç»´æ•°ç»„çš„åæ ‡è½¬æ¢æˆä¸€ç»´çš„ï¼ŒèŠ‚çœå­˜å‚¨ç©ºé—´**ã€‚å…¶ä¸­ `(i * col + j, x * col + y)` æ˜¯å¸¸ç”¨çš„äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„æ–¹æ³•ã€‚`newX = x / col, newY = y % col`
- ç¬¬äºŒä¸ªå°æŠ€å·§ï¼šä½¿ç”¨æ–¹å‘æ•°ç»„æ˜¯ä¸Šä¸‹å·¦å³æœç´¢çš„å¸¸ç”¨æ‰‹æ³•

ã€å…·ä½“ä»£ç ã€‘ï¼š

```java
class Solution {
    
    private int rows; // è¡Œ
    private int cols; // åˆ—
    
    public int numIslands(char[][] grid) {
        rows = grid.length;
        if (rows == 0) {
            return 0;
        }
        cols = grid[0].length;
        
        int waterCount = 0; // æ°´åŸŸç½‘æ ¼çš„æ•°é‡
        UnionFindSet unionFindSet = new UnionFindSet(rows * cols);
        int[][] directions = {{1, 0}, {0, 1}}; // å‘å³æˆ–å‘ä¸‹ç§»åŠ¨
        for (int i = 0; i < rows; i ++) {
            for (int j = 0; j < cols; j ++) {
                if (grid[i][j] == '0') {
                    waterCount ++;
                }
                else {
                    // æ­¤æ—¶ grid[i][j] == '1'
                    for (int[] direction : directions) {
                        int newX = i + direction[0];
                        int newY = j + direction[1];
                        // å…ˆåˆ¤æ–­åæ ‡åˆæ³•ï¼Œå†æ£€æŸ¥å…¶å³è¾¹ä¸€æ ¼å’Œä¸‹è¾¹ä¸€æ ¼æ˜¯å¦æ˜¯é™†åœ°
                        if (newX < rows && newY < cols &&
                           grid[newX][newY] == '1') {
                               // åˆå¹¶ä¸¤å—é™†åœ°
                               unionFindSet.union(getIndex(i, j), getIndex(newX, newY));
                        }
                    }
                }
            }
        }
        
        return unionFindSet.getCount() - waterCount;
        
    }
    
    
    // å°†äºŒç»´ç½‘ç»œä¸­çš„åæ ‡è½¬æ¢ä¸ºä¸€ç»´åæ ‡, èŠ‚çœå­˜å‚¨ç©ºé—´
    public int getIndex(int i, int j) {
        return i * cols + j; 
    }
    
    class UnionFindSet {
        private int count; // è¿é€šåˆ†é‡çš„ä¸ªæ•°
        private int[] father; // key: äºŒç»´ç½‘æ ¼å¯¹åº”çš„ä¸€ç»´åæ ‡, value: father èŠ‚ç‚¹
        
        public UnionFindSet (int n) {
            count = n;
            father = new int[n];
            for (int i = 0; i < n; i ++) {
                father[i] = i;
            }
        }
        
        public int findFather(int x) {
            Stack<Integer> path = new Stack<>();
            while (father[x] != x) {
                path.push(x);
                x = father[x];
            }
            
            // è·¯å¾„å‹ç¼©
            while (!path.isEmpty()) {
                father[path.pop()] = x;
            }
            
            return x;
        }
        
        // åˆå¹¶ä¸¤å—é™†åœ°(éšä¾¿è°åšä»£è¡¨éƒ½è¡Œ)
        public void union(int a, int b) {
            int aF = findFather(a);
            int bF = findFather(b);
            if (aF != bF) {
                father[aF] = bF;
                count --;
            }
        }
        
        public int getCount() {
            return count;
        }
    }
}
```

### LC990. ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§

ã€é¢˜ç›®é“¾æ¥ã€‘ï¼š

- LeetCodeï¼š[990. ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

ã€é¢˜ç›®æè¿°ã€‘ï¼š

ç»™å®šä¸€ä¸ªç”±è¡¨ç¤ºå˜é‡ä¹‹é—´å…³ç³»çš„å­—ç¬¦ä¸²æ–¹ç¨‹ç»„æˆçš„æ•°ç»„ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²æ–¹ç¨‹ equations[i] çš„é•¿åº¦ä¸º 4ï¼Œå¹¶é‡‡ç”¨ä¸¤ç§ä¸åŒçš„å½¢å¼ä¹‹ä¸€ï¼š"a==b" æˆ– "a!=b"ã€‚åœ¨è¿™é‡Œï¼Œa å’Œ b æ˜¯å°å†™å­—æ¯ï¼ˆä¸ä¸€å®šä¸åŒï¼‰ï¼Œè¡¨ç¤ºå•å­—æ¯å˜é‡åã€‚

åªæœ‰å½“å¯ä»¥å°†æ•´æ•°åˆ†é…ç»™å˜é‡åï¼Œä»¥ä¾¿æ»¡è¶³æ‰€æœ‰ç»™å®šçš„æ–¹ç¨‹æ—¶æ‰è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚ 

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼š["a==b","b!=a"]
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šå¦‚æœæˆ‘ä»¬æŒ‡å®šï¼Œa = 1 ä¸” b = 1ï¼Œé‚£ä¹ˆå¯ä»¥æ»¡è¶³ç¬¬ä¸€ä¸ªæ–¹ç¨‹ï¼Œä½†æ— æ³•æ»¡è¶³ç¬¬äºŒä¸ªæ–¹ç¨‹ã€‚æ²¡æœ‰åŠæ³•åˆ†é…å˜é‡åŒæ—¶æ»¡è¶³è¿™ä¸¤ä¸ªæ–¹ç¨‹ã€‚
```


ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼š["b==a","a==b"]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šæˆ‘ä»¬å¯ä»¥æŒ‡å®š a = 1 ä¸” b = 1 ä»¥æ»¡è¶³æ»¡è¶³è¿™ä¸¤ä¸ªæ–¹ç¨‹ã€‚
```


ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼š["a==b","b==c","a==c"]
è¾“å‡ºï¼štrue
```


ç¤ºä¾‹ 4ï¼š

```
è¾“å…¥ï¼š["a==b","b!=c","c==a"]
è¾“å‡ºï¼šfalse
```


ç¤ºä¾‹ 5ï¼š

```
è¾“å…¥ï¼š["c==c","b==d","x!=z"]
è¾“å‡ºï¼štrue
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼š

**æˆ‘ä»¬å¯ä»¥å°†æ¯ä¸€ä¸ªå˜é‡çœ‹ä½œå›¾ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼ŒæŠŠç›¸ç­‰çš„å…³ç³» == çœ‹ä½œæ˜¯è¿æ¥ä¸¤ä¸ªèŠ‚ç‚¹çš„è¾¹ï¼Œé‚£ä¹ˆç”±äºè¡¨ç¤ºç›¸ç­‰å…³ç³»çš„ç­‰å¼æ–¹ç¨‹å…·æœ‰ä¼ é€’æ€§ï¼Œå³å¦‚æœ a==b å’Œ b==c æˆç«‹ï¼Œåˆ™ a==c ä¹Ÿæˆç«‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ<u>æ‰€æœ‰ç›¸ç­‰çš„å˜é‡å±äºåŒä¸€ä¸ªè¿é€šåˆ†é‡</u>ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¹¶æŸ¥é›†æ¥ç»´æŠ¤è¿™ç§è¿é€šåˆ†é‡çš„å…³ç³»ã€‚**

é¦–å…ˆéå†æ‰€æœ‰çš„ç­‰å¼ï¼Œæ„é€ å¹¶æŸ¥é›†ã€‚åŒä¸€ä¸ªç­‰å¼ä¸­çš„ä¸¤ä¸ªå˜é‡å±äºåŒä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå› æ­¤å°†ä¸¤ä¸ªå˜é‡è¿›è¡Œåˆå¹¶ã€‚

ç„¶åéå†æ‰€æœ‰çš„ä¸ç­‰å¼ã€‚åŒä¸€ä¸ªä¸ç­‰å¼ä¸­çš„ä¸¤ä¸ªå˜é‡ä¸èƒ½å±äºåŒä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå› æ­¤å¯¹ä¸¤ä¸ªå˜é‡åˆ†åˆ«æŸ¥æ‰¾å…¶æ‰€åœ¨çš„è¿é€šåˆ†é‡ï¼Œå¦‚æœä¸¤ä¸ªå˜é‡åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡ä¸­ï¼Œåˆ™äº§ç”ŸçŸ›ç›¾ï¼Œè¿”å› falseã€‚

å¦‚æœéå†å®Œæ‰€æœ‰çš„ä¸ç­‰å¼æ²¡æœ‰å‘ç°çŸ›ç›¾ï¼Œåˆ™è¿”å› trueã€‚

ã€å…·ä½“ä»£ç ã€‘ï¼š

è¿™é‡Œçš„å°æŠ€å·§å°±æ˜¯æŠŠè‹±æ–‡å­—æ¯è½¬æ¢æˆäº†æ•°å­—ï¼ŒèŠ‚çœå­˜å‚¨ç©ºé—´ã€‚

å¦å¤–ï¼Œæœ¬é¢˜ä¸éœ€è¦ rankMap äº†ï¼Œå› ä¸ºé¢˜ç›®å¹¶ä¸å…³å¿ƒæ¯ä¸ªé›†åˆä¸­çš„å…ƒç´ æ•°é‡ã€‚

```java
class Solution {
    public boolean equationsPossible(String[] equations) {
        UnionFindSet unionFindSet = new UnionFindSet(26); // 26 ä¸ªè‹±æ–‡å­—æ¯
        for (String str : equations) {
            // å¦‚æœæ˜¯ç­‰å·ï¼Œåˆ™åˆå¹¶ç­‰å·ä¸¤è¾¹çš„æ•°å­—æ‰€åœ¨é›†åˆ
            if (str.charAt(1) == '=') {
                int index1 = str.charAt(0) - 'a'; // å¯¹åº”çš„æ•°å­—ä¸‹æ ‡ 0 è¡¨ç¤º aã€1 è¡¨ç¤º b ......
                int index2 = str.charAt(3) - 'a';
                unionFindSet.union(index1, index2);
            }
        }

        // éå†ä¸ç­‰å¼, å¦‚æœä¸ç­‰å¼ä¸¤è¾¹çš„æ•°å­—åœ¨åŒä¸€ä¸ªé›†åˆå†…ï¼Œåˆ™è¿”å› false
        for (String str : equations) {
            if (str.charAt(1) == '!') {
                int index1 = str.charAt(0) - 'a';
                int index2 = str.charAt(3) - 'a';
                if (unionFindSet.findFather(index1) == unionFindSet.findFather(index2)) {
                    return false;
                }
            }
        }

        return true;
    }

    class UnionFindSet {
        private int[] father; // ä¸‹æ ‡ï¼š0 è¡¨ç¤º aã€1 è¡¨ç¤º b, value: å¯¹åº”çš„ father èŠ‚ç‚¹

        public UnionFindSet (int n) {
            father = new int[n];
            for (int i = 0; i < n; i ++) {
                father[i] = i;
            }
        }

        // æ‰¾åˆ°èŠ‚ç‚¹ x æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
        public int findFather(int x) {
            Stack<Integer> path = new Stack<>();
            while (father[x] != x) {
                path.push(father[x]);
                x = father[x];
            }

            // è·¯å¾„å‹ç¼©
            while (!path.isEmpty()) {
                father[path.pop()] = x;
            }

            return x;
        }

        // åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆ(æœ¬é¢˜éšä¾¿è°åšä»£è¡¨éƒ½è¡Œ)
        public void union (int a, int b) {
            int aF = findFather(a);
            int bF = findFather(b);
            if (aF != bF) {
                father[aF] = bF;
            }
        }
    }
}
```

### LC399. é™¤æ³•æ±‚å€¼

ã€é¢˜ç›®é“¾æ¥ã€‘ï¼š

- LeetCodeï¼š[399. é™¤æ³•æ±‚å€¼ â€” Medium](https://leetcode-cn.com/problems/evaluate-division/)

ã€é¢˜ç›®æè¿°ã€‘ï¼š

ç»™ä½ ä¸€ä¸ªå˜é‡å¯¹æ•°ç»„ equations å’Œä¸€ä¸ªå®æ•°å€¼æ•°ç»„ values ä½œä¸ºå·²çŸ¥æ¡ä»¶ï¼Œå…¶ä¸­ equations[i] = [Ai, Bi] å’Œ values[i] å…±åŒè¡¨ç¤ºç­‰å¼ Ai / Bi = values[i] ã€‚æ¯ä¸ª Ai æˆ– Bi æ˜¯ä¸€ä¸ªè¡¨ç¤ºå•ä¸ªå˜é‡çš„å­—ç¬¦ä¸²ã€‚

å¦æœ‰ä¸€äº›ä»¥æ•°ç»„ queries è¡¨ç¤ºçš„é—®é¢˜ï¼Œå…¶ä¸­ queries[j] = [Cj, Dj] è¡¨ç¤ºç¬¬ j ä¸ªé—®é¢˜ï¼Œè¯·ä½ æ ¹æ®å·²çŸ¥æ¡ä»¶æ‰¾å‡º Cj / Dj = ? çš„ç»“æœä½œä¸ºç­”æ¡ˆã€‚

è¿”å› æ‰€æœ‰é—®é¢˜çš„ç­”æ¡ˆ ã€‚å¦‚æœå­˜åœ¨æŸä¸ªæ— æ³•ç¡®å®šçš„ç­”æ¡ˆï¼Œåˆ™ç”¨ -1.0 æ›¿ä»£è¿™ä¸ªç­”æ¡ˆã€‚å¦‚æœé—®é¢˜ä¸­å‡ºç°äº†ç»™å®šçš„å·²çŸ¥æ¡ä»¶ä¸­æ²¡æœ‰å‡ºç°çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿéœ€è¦ç”¨ -1.0 æ›¿ä»£è¿™ä¸ªç­”æ¡ˆã€‚

æ³¨æ„ï¼šè¾“å…¥æ€»æ˜¯æœ‰æ•ˆçš„ã€‚ä½ å¯ä»¥å‡è®¾é™¤æ³•è¿ç®—ä¸­ä¸ä¼šå‡ºç°é™¤æ•°ä¸º 0 çš„æƒ…å†µï¼Œä¸”ä¸å­˜åœ¨ä»»ä½•çŸ›ç›¾çš„ç»“æœã€‚

ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šequations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
è¾“å‡ºï¼š[6.00000,0.50000,-1.00000,1.00000,-1.00000]
è§£é‡Šï¼š
æ¡ä»¶ï¼ša / b = 2.0, b / c = 3.0
é—®é¢˜ï¼ša / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
ç»“æœï¼š[6.0, 0.5, -1.0, 1.0, -1.0 ]
```


ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šequations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
è¾“å‡ºï¼š[3.75000,0.40000,5.00000,0.20000]
```


ç¤ºä¾‹ 3ï¼š

```
è¾“å…¥ï¼šequations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
è¾“å‡ºï¼š[0.50000,2.00000,-1.00000,-1.00000]
```

ã€è§£é¢˜æ€è·¯ã€‘ï¼š

è¿™é“é¢˜å…¶å®å°±æ˜¯ä¸ª**å¸¦æƒå¹¶æŸ¥é›†**ã€‚

è¿™é“é¢˜æ˜¯åœ¨ã€ŒLeetCodeã€ç¬¬ 990 é¢˜ï¼ˆç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§ï¼‰çš„åŸºç¡€ä¸Šï¼Œåœ¨å˜é‡å’Œå˜é‡ä¹‹é—´æœ‰äº†å€æ•°å…³ç³»ã€‚ç”±äº å˜é‡ä¹‹é—´çš„å€æ•°å…³ç³»å…·æœ‰ä¼ é€’æ€§ï¼Œå¤„ç†æœ‰ä¼ é€’æ€§å…³ç³»çš„é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ã€Œå¹¶æŸ¥é›†ã€ï¼Œæˆ‘ä»¬éœ€è¦åœ¨å¹¶æŸ¥é›†çš„ã€Œåˆå¹¶ã€ä¸ã€ŒæŸ¥è¯¢ã€æ“ä½œä¸­ ç»´æŠ¤è¿™äº›å˜é‡ä¹‹é—´çš„å€æ•°å…³ç³»ã€‚

è¯¦ç»†è§£é¢˜æ€è·¯çœ‹è¿™é‡Œï¼š[ğŸ¦ 399. é™¤æ³•æ±‚å€¼ - é™¤æ³•æ±‚å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/)

ã€å…·ä½“ä»£ç ã€‘ï¼š

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        // æ„é€ å¹¶æŸ¥é›†
        int equationSize = equations.size();
        UnionFindSet unionFindSet = new UnionFindSet(2 * equationSize);

        Map<String, Integer> map = new HashMap<>();
        int id = 0;
        for (int i = 0; i < equationSize; i ++) {
            // é¢„å¤„ç†ï¼Œå°†å˜é‡çš„å€¼ä¸idè¿›è¡Œæ˜ å°„ï¼Œä½¿å¾—å¹¶æŸ¥é›†åº•å±‚ä½¿ç”¨æ•°ç»„å®ç°ï¼Œæ–¹ä¾¿ç¼–ç 
            String str1 = equations.get(i).get(0); // ç¬¬ä¸€ä¸ªå­—ç¬¦
            String str2 = equations.get(i).get(1); // ç¬¬äºŒä¸ªå­—ç¬¦
            if (!map.containsKey(str1)) {
                map.put(str1, id);
                id ++;
            }
            if (!map.containsKey(str2)) {
                map.put(str2, id);
                id ++;
            }

            // åˆå¹¶
            unionFindSet.union(map.get(str1), map.get(str2), values[i]);
        }

        // æŸ¥è¯¢
        int querySize = queries.size();
        double[] res = new double[querySize];
        for (int i = 0; i < querySize; i ++) {
            String var1 = queries.get(i).get(0); // ç¬¬ä¸€ä¸ªå­—ç¬¦
            String var2 = queries.get(i).get(1); // ç¬¬ä¸€ä¸ªå­—ç¬¦

            if (map.get(var1) == null || map.get(var2) == null) {
                res[i] = -1.0;
            }
            else {
                res[i] = unionFindSet.isSameSet(map.get(var1), map.get(var2));
            }
        }

        return res;
    }

    class UnionFindSet {
        private int[] father; // ä¸‹æ ‡: å­—ç¬¦å¯¹åº”çš„æ•°å­—, value: å¯¹åº”çš„ father èŠ‚ç‚¹
        private double[] weight; // ä¸‹æ ‡: å­—ç¬¦å¯¹åº”çš„æ•°å­—, value: è¯¥èŠ‚ç‚¹åˆ° father èŠ‚ç‚¹è·¯å¾„çš„æƒå€¼

        public UnionFindSet(int n) {
            father = new int[n];
            weight = new double[n];
            for (int i = 0; i < n; i ++) {
                father[i] = i;
                weight[i] = 1.0d;
            }
        }

        // æ‰¾åˆ°èŠ‚ç‚¹ x æ‰€åœ¨é›†åˆçš„ä»£è¡¨èŠ‚ç‚¹
        public int findFather(int x) {
            Stack<Integer> path = new Stack<>();
            while (father[x] != x) {
                path.push(x);
                x = father[x];
            }
            // è·¯å¾„å‹ç¼©
            while (!path.isEmpty()) {
                int origin = path.pop();
                // æ›´æ–°æƒå€¼
                weight[origin] = weight[origin] * weight[father[origin]];

                father[origin] = x;
            }

            return x;
        }

        // åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆ(æœ¬é¢˜éšä¾¿è°åšä»£è¡¨éƒ½è¡Œ, è¿™é‡Œæˆ‘ä»¬è§„å®šä»¥ bF åšä»£è¡¨)
        // value è¡¨ç¤º a å’Œ b ä¸¤ä¸ªè¿é€šèŠ‚ç‚¹è·¯å¾„çš„æƒå€¼
        public void union(int a, int b, double value) {
            int aF = findFather(a);
            int bF = findFather(b);
            if (aF != bF) {
                father[aF] = bF;
                // æ›´æ–°æƒå€¼
                weight[aF] = weight[b] * value / weight[a];
            }
        }

        // åˆ¤æ–­ a å’Œ b æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼ˆæ˜¯å¦è¿é€šï¼‰, å¦‚æœæ˜¯, åˆ™è¿”å› a/b çš„ç»“æœ
        public double isSameSet(int a, int b) {
            int aF = findFather(a);
            int bF = findFather(b);
            if (aF == bF) {
                return weight[a] / weight[b];
            }

            return -1.0d;
        }
    }
}
```

